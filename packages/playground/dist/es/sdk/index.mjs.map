{"version":3,"file":"sdk\\index.mjs","sources":["webpack://@sqaitech/playground/./src/sdk/index.ts"],"sourcesContent":["import type { DeviceAction } from '@sqaitech/core';\r\nimport { PLAYGROUND_SERVER_PORT } from '@sqaitech/shared/constants';\r\nimport type { BasePlaygroundAdapter } from '../adapters/base';\r\nimport { LocalExecutionAdapter } from '../adapters/local-execution';\r\nimport { RemoteExecutionAdapter } from '../adapters/remote-execution';\r\nimport type {\r\n  ExecutionOptions,\r\n  FormValue,\r\n  PlaygroundAgent,\r\n  PlaygroundConfig,\r\n  ValidationResult,\r\n} from '../types';\r\n\r\nexport class PlaygroundSDK {\r\n  private adapter: BasePlaygroundAdapter;\r\n\r\n  constructor(config: PlaygroundConfig) {\r\n    this.adapter = this.createAdapter(\r\n      config.type,\r\n      config.serverUrl,\r\n      config.agent,\r\n    );\r\n  }\r\n\r\n  private createAdapter(\r\n    type: string,\r\n    serverUrl?: string,\r\n    agent?: PlaygroundAgent,\r\n  ): BasePlaygroundAdapter {\r\n    switch (type) {\r\n      case 'local-execution':\r\n        if (!agent) {\r\n          throw new Error('Agent is required for local execution');\r\n        }\r\n        return new LocalExecutionAdapter(agent);\r\n      case 'remote-execution': {\r\n        // Use provided serverUrl first, then fallback to localhost if current page origin is file:// or default\r\n        const finalServerUrl =\r\n          serverUrl ||\r\n          (typeof window !== 'undefined' &&\r\n          window.location.protocol.includes('http')\r\n            ? window.location.origin\r\n            : `http://localhost:${PLAYGROUND_SERVER_PORT}`);\r\n\r\n        return new RemoteExecutionAdapter(finalServerUrl);\r\n      }\r\n      default:\r\n        throw new Error(`Unsupported execution type: ${type}`);\r\n    }\r\n  }\r\n\r\n  async executeAction(\r\n    actionType: string,\r\n    value: FormValue,\r\n    options: ExecutionOptions,\r\n  ): Promise<unknown> {\r\n    const result = await this.adapter.executeAction(actionType, value, options);\r\n\r\n    // Stop any active polling for this request after execution completes\r\n    if (options.requestId) {\r\n      this.stopProgressPolling(options.requestId);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  async getActionSpace(context?: unknown): Promise<DeviceAction<unknown>[]> {\r\n    // Both adapters now accept context parameter\r\n    // Local will prioritize internal agent, Remote will use server + fallback\r\n    return this.adapter.getActionSpace(context);\r\n  }\r\n\r\n  validateStructuredParams(\r\n    value: FormValue,\r\n    action: DeviceAction<unknown> | undefined,\r\n  ): ValidationResult {\r\n    return this.adapter.validateParams(value, action);\r\n  }\r\n\r\n  formatErrorMessage(error: any): string {\r\n    return this.adapter.formatErrorMessage(error);\r\n  }\r\n\r\n  createDisplayContent(\r\n    value: FormValue,\r\n    needsStructuredParams: boolean,\r\n    action: DeviceAction<unknown> | undefined,\r\n  ): string {\r\n    return this.adapter.createDisplayContent(\r\n      value,\r\n      needsStructuredParams,\r\n      action,\r\n    );\r\n  }\r\n\r\n  // Get adapter ID (works for both remote and local execution)\r\n  get id(): string | undefined {\r\n    if (this.adapter instanceof RemoteExecutionAdapter) {\r\n      return this.adapter.id;\r\n    }\r\n    if (this.adapter instanceof LocalExecutionAdapter) {\r\n      return this.adapter.id;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  // Server communication methods (for remote execution)\r\n  async checkStatus(): Promise<boolean> {\r\n    if (this.adapter instanceof RemoteExecutionAdapter) {\r\n      return this.adapter.checkStatus();\r\n    }\r\n    return true; // For local execution, always return true\r\n  }\r\n\r\n  async overrideConfig(aiConfig: any): Promise<void> {\r\n    if (this.adapter instanceof RemoteExecutionAdapter) {\r\n      return this.adapter.overrideConfig(aiConfig);\r\n    }\r\n    // For local execution, this is a no-op\r\n  }\r\n\r\n  async getTaskProgress(requestId: string): Promise<{ tip?: string }> {\r\n    if (this.adapter instanceof RemoteExecutionAdapter) {\r\n      return this.adapter.getTaskProgress(requestId);\r\n    }\r\n    if (this.adapter instanceof LocalExecutionAdapter) {\r\n      return this.adapter.getTaskProgress(requestId);\r\n    }\r\n    return { tip: undefined }; // Fallback\r\n  }\r\n\r\n  // Cancel task (for remote execution)\r\n  async cancelTask(requestId: string): Promise<any> {\r\n    // Stop progress polling for this request\r\n    this.stopProgressPolling(requestId);\r\n\r\n    if (this.adapter instanceof RemoteExecutionAdapter) {\r\n      return this.adapter.cancelTask(requestId);\r\n    }\r\n    return { error: 'Cancel task not supported in local execution mode' };\r\n  }\r\n\r\n  // Progress callback management\r\n  onProgressUpdate(callback: (tip: string) => void): void {\r\n    // Pass the callback to the adapter if it supports it\r\n    if (this.adapter instanceof RemoteExecutionAdapter) {\r\n      this.adapter.setProgressCallback(callback);\r\n    } else if (this.adapter instanceof LocalExecutionAdapter) {\r\n      this.adapter.setProgressCallback(callback);\r\n    }\r\n  }\r\n\r\n  // Start progress polling for remote execution (deprecated - now handled by adapter)\r\n  startProgressPolling(requestId: string): void {\r\n    // This method is now handled by the RemoteExecutionAdapter automatically\r\n    // when executeAction is called with a requestId\r\n    console.warn(\r\n      'startProgressPolling is deprecated - polling is now automatic',\r\n    );\r\n  }\r\n\r\n  // Stop progress polling for a specific request (deprecated - now handled by adapter)\r\n  stopProgressPolling(requestId: string): void {\r\n    // This method is now handled by the RemoteExecutionAdapter automatically\r\n    console.warn(\r\n      'stopProgressPolling is deprecated - polling cleanup is now automatic',\r\n    );\r\n  }\r\n\r\n  // Cancel execution - supports both remote and local\r\n  async cancelExecution(requestId: string): Promise<void> {\r\n    this.stopProgressPolling(requestId);\r\n\r\n    if (this.adapter instanceof RemoteExecutionAdapter) {\r\n      await this.adapter.cancelTask(requestId);\r\n    } else if (this.adapter instanceof LocalExecutionAdapter) {\r\n      // For local execution, we might need to implement agent cancellation\r\n      console.warn('Local execution cancellation not fully implemented');\r\n    }\r\n  }\r\n\r\n  // Screenshot method for remote execution\r\n  async getScreenshot(): Promise<{\r\n    screenshot: string;\r\n    timestamp: number;\r\n  } | null> {\r\n    if (this.adapter instanceof RemoteExecutionAdapter) {\r\n      return this.adapter.getScreenshot();\r\n    }\r\n    return null; // For local execution, not supported yet\r\n  }\r\n\r\n  // Get interface information (type and description)\r\n  async getInterfaceInfo(): Promise<{\r\n    type: string;\r\n    description?: string;\r\n  } | null> {\r\n    if (this.adapter instanceof LocalExecutionAdapter) {\r\n      return this.adapter.getInterfaceInfo();\r\n    }\r\n    if (this.adapter instanceof RemoteExecutionAdapter) {\r\n      return this.adapter.getInterfaceInfo();\r\n    }\r\n    return null;\r\n  }\r\n}\r\n"],"names":["PlaygroundSDK","type","serverUrl","agent","Error","LocalExecutionAdapter","finalServerUrl","window","PLAYGROUND_SERVER_PORT","RemoteExecutionAdapter","actionType","value","options","result","context","action","error","needsStructuredParams","aiConfig","requestId","undefined","callback","console","config"],"mappings":"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"}