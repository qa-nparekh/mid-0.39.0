{"version":3,"file":"adapters\\local-execution.mjs","sources":["webpack://@sqaitech/playground/./src/adapters/local-execution.ts"],"sourcesContent":["import type { DeviceAction } from '@sqaitech/core';\r\nimport { overrideAIConfig } from '@sqaitech/shared/env';\r\nimport { uuid } from '@sqaitech/shared/utils';\r\nimport { executeAction, parseStructuredParams } from '../common';\r\nimport type { ExecutionOptions, FormValue, PlaygroundAgent } from '../types';\r\nimport { BasePlaygroundAdapter } from './base';\r\n\r\nexport class LocalExecutionAdapter extends BasePlaygroundAdapter {\r\n  private agent: PlaygroundAgent;\r\n  private taskProgressTips: Record<string, string> = {};\r\n  private progressCallback?: (tip: string) => void;\r\n  private readonly _id: string; // Unique identifier for this local adapter instance\r\n  private currentRequestId?: string; // Track current request to prevent stale callbacks\r\n\r\n  constructor(agent: PlaygroundAgent) {\r\n    super();\r\n    this.agent = agent;\r\n    this._id = uuid(); // Generate unique ID for local adapter\r\n  }\r\n\r\n  // Get adapter ID\r\n  get id(): string {\r\n    return this._id;\r\n  }\r\n\r\n  setProgressCallback(callback: (tip: string) => void): void {\r\n    // Clear any existing callback before setting new one\r\n    this.progressCallback = undefined;\r\n    // Set the new callback\r\n    this.progressCallback = callback;\r\n  }\r\n\r\n  private cleanup(requestId: string): void {\r\n    delete this.taskProgressTips[requestId];\r\n  }\r\n\r\n  async parseStructuredParams(\r\n    action: DeviceAction<unknown>,\r\n    params: Record<string, unknown>,\r\n    options: ExecutionOptions,\r\n  ): Promise<unknown[]> {\r\n    // Use shared implementation from common.ts\r\n    return await parseStructuredParams(action, params, options);\r\n  }\r\n\r\n  formatErrorMessage(error: any): string {\r\n    const errorMessage = error?.message || '';\r\n    if (errorMessage.includes('of different extension')) {\r\n      return 'Conflicting extension detected. Please disable the suspicious plugins and refresh the page. Guide: https://midscenejs.com/quick-experience.html#faq';\r\n    }\r\n    return this.formatBasicErrorMessage(error);\r\n  }\r\n\r\n  // Local execution - use base implementation\r\n  // (inherits default executeAction from BasePlaygroundAdapter)\r\n\r\n  // Local execution gets actionSpace from internal agent (parameter is for backward compatibility)\r\n  async getActionSpace(context?: unknown): Promise<DeviceAction<unknown>[]> {\r\n    // Priority 1: Use agent's getActionSpace method\r\n    if (this.agent?.getActionSpace) {\r\n      return await this.agent.getActionSpace();\r\n    }\r\n\r\n    // Priority 2: Use agent's interface.actionSpace method\r\n    if (\r\n      this.agent &&\r\n      'interface' in this.agent &&\r\n      typeof this.agent.interface === 'object'\r\n    ) {\r\n      const page = this.agent.interface as {\r\n        actionSpace?: () => Promise<DeviceAction<unknown>[]>;\r\n      };\r\n      if (page?.actionSpace) {\r\n        return await page.actionSpace();\r\n      }\r\n    }\r\n\r\n    // Priority 3: Fallback to context parameter (for backward compatibility with tests)\r\n    if (context && typeof context === 'object' && 'actionSpace' in context) {\r\n      const contextPage = context as {\r\n        actionSpace: () => Promise<DeviceAction<unknown>[]>;\r\n      };\r\n      return await contextPage.actionSpace();\r\n    }\r\n\r\n    return [];\r\n  }\r\n\r\n  // Local execution doesn't use a server, so always return true\r\n  async checkStatus(): Promise<boolean> {\r\n    return true;\r\n  }\r\n\r\n  async overrideConfig(aiConfig: Record<string, unknown>): Promise<void> {\r\n    // For local execution, use the shared env override function\r\n    overrideAIConfig(aiConfig);\r\n  }\r\n\r\n  async executeAction(\r\n    actionType: string,\r\n    value: FormValue,\r\n    options: ExecutionOptions,\r\n  ): Promise<unknown> {\r\n    // Get actionSpace using our simplified getActionSpace method\r\n    const actionSpace = await this.getActionSpace();\r\n    let originalOnTaskStartTip: ((tip: string) => void) | undefined;\r\n\r\n    // Setup progress tracking if requestId is provided\r\n    if (options.requestId && this.agent) {\r\n      // Track current request ID to prevent stale callbacks\r\n      this.currentRequestId = options.requestId;\r\n      originalOnTaskStartTip = this.agent.onTaskStartTip;\r\n\r\n      // Set up a fresh callback\r\n      this.agent.onTaskStartTip = (tip: string) => {\r\n        // Only process if this is still the current request\r\n        if (this.currentRequestId !== options.requestId) {\r\n          return;\r\n        }\r\n\r\n        // Store tip for our progress tracking\r\n        this.taskProgressTips[options.requestId!] = tip;\r\n\r\n        // Call the direct progress callback set via setProgressCallback\r\n        if (this.progressCallback) {\r\n          this.progressCallback(tip);\r\n        }\r\n\r\n        if (typeof originalOnTaskStartTip === 'function') {\r\n          originalOnTaskStartTip(tip);\r\n        }\r\n      };\r\n    }\r\n\r\n    try {\r\n      // Call the base implementation with the original signature\r\n      const result = await executeAction(\r\n        this.agent,\r\n        actionType,\r\n        actionSpace,\r\n        value,\r\n        options,\r\n      );\r\n\r\n      // For local execution, we need to package the result with dump and reportHTML\r\n      // similar to how the server does it\r\n      const response = {\r\n        result,\r\n        dump: null as unknown,\r\n        reportHTML: null as string | null,\r\n        error: null as string | null,\r\n      };\r\n\r\n      try {\r\n        // Get dump and reportHTML from agent like the server does\r\n        if (this.agent.dumpDataString) {\r\n          const dumpString = this.agent.dumpDataString();\r\n          if (dumpString) {\r\n            response.dump = JSON.parse(dumpString);\r\n          }\r\n        }\r\n\r\n        if (this.agent.reportHTMLString) {\r\n          response.reportHTML = this.agent.reportHTMLString() || null;\r\n        }\r\n\r\n        // Write out action dumps\r\n        if (this.agent.writeOutActionDumps) {\r\n          this.agent.writeOutActionDumps();\r\n        }\r\n      } catch (error: unknown) {\r\n        console.error('Failed to get dump/reportHTML from agent:', error);\r\n      }\r\n\r\n      this.agent.resetDump();\r\n\r\n      return response;\r\n    } finally {\r\n      // Always clean up progress tracking to prevent memory leaks\r\n      if (options.requestId) {\r\n        this.cleanup(options.requestId);\r\n        // Clear the agent callback to prevent accumulation\r\n        if (this.agent) {\r\n          this.agent.onTaskStartTip = originalOnTaskStartTip;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  async getTaskProgress(requestId: string): Promise<{ tip?: string }> {\r\n    // Return the stored tip for this requestId\r\n    return { tip: this.taskProgressTips[requestId] || undefined };\r\n  }\r\n\r\n  // Local execution task cancellation - minimal implementation\r\n  async cancelTask(\r\n    _requestId: string,\r\n  ): Promise<{ error?: string; success?: boolean }> {\r\n    if (!this.agent) {\r\n      return { error: 'No active agent found for this requestId' };\r\n    }\r\n\r\n    try {\r\n      await this.agent.destroy?.();\r\n      return { success: true };\r\n    } catch (error: unknown) {\r\n      const errorMessage =\r\n        error instanceof Error ? error.message : 'Unknown error';\r\n      console.error(`Failed to cancel agent: ${errorMessage}`);\r\n      return { error: `Failed to cancel: ${errorMessage}` };\r\n    }\r\n  }\r\n\r\n  // Get interface information from the agent\r\n  async getInterfaceInfo(): Promise<{\r\n    type: string;\r\n    description?: string;\r\n  } | null> {\r\n    if (!this.agent?.interface) {\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      const type = this.agent.interface.interfaceType || 'Unknown';\r\n      const description = this.agent.interface.describe?.() || undefined;\r\n\r\n      return {\r\n        type,\r\n        description,\r\n      };\r\n    } catch (error: unknown) {\r\n      console.error('Failed to get interface info:', error);\r\n      return null;\r\n    }\r\n  }\r\n}\r\n"],"names":["LocalExecutionAdapter","BasePlaygroundAdapter","callback","undefined","requestId","action","params","options","parseStructuredParams","error","errorMessage","context","_this_agent","page","contextPage","aiConfig","overrideAIConfig","actionType","value","actionSpace","originalOnTaskStartTip","tip","result","executeAction","response","dumpString","JSON","console","_requestId","Error","_this_agent_interface","type","description","agent","uuid"],"mappings":"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"}