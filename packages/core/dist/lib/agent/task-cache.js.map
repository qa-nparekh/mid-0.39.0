{"version":3,"file":"agent\\task-cache.js","sources":["webpack://@sqaitech/core/webpack/runtime/compat_get_default_export","webpack://@sqaitech/core/webpack/runtime/define_property_getters","webpack://@sqaitech/core/webpack/runtime/has_own_property","webpack://@sqaitech/core/webpack/runtime/make_namespace_object","webpack://@sqaitech/core/./src/agent/task-cache.ts"],"sourcesContent":["// getDefaultExport function for compatibility with non-ESM modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};\n","__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n        if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n            Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n        }\n    }\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import assert from 'node:assert';\r\nimport { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs';\r\nimport { dirname, join } from 'node:path';\r\nimport { isDeepStrictEqual } from 'node:util';\r\nimport type { TUserPrompt } from '@/ai-model';\r\nimport type { ElementCacheFeature } from '@/types';\r\nimport { getMidsceneRunSubDir } from '@sqaitech/shared/common';\r\nimport {\r\n  SQAI_CACHE_MAX_FILENAME_LENGTH,\r\n  globalConfigManager,\r\n} from '@sqaitech/shared/env';\r\nimport { getDebug } from '@sqaitech/shared/logger';\r\nimport { ifInBrowser, ifInWorker } from '@sqaitech/shared/utils';\r\nimport { generateHashId } from '@sqaitech/shared/utils';\r\nimport { replaceIllegalPathCharsAndSpace } from '@sqaitech/shared/utils';\r\nimport yaml from 'js-yaml';\r\nimport semver from 'semver';\r\nimport { getSqaiVersion } from './utils';\r\n\r\nconst DEFAULT_CACHE_MAX_FILENAME_LENGTH = 200;\r\n\r\nexport const debug = getDebug('cache');\r\n\r\nexport interface PlanningCache {\r\n  type: 'plan';\r\n  prompt: string;\r\n  yamlWorkflow: string;\r\n}\r\n\r\nexport interface LocateCache {\r\n  type: 'locate';\r\n  prompt: TUserPrompt;\r\n  cache?: ElementCacheFeature;\r\n  /** @deprecated kept for backward compatibility */\r\n  xpaths?: string[];\r\n}\r\n\r\nexport interface MatchCacheResult<T extends PlanningCache | LocateCache> {\r\n  cacheContent: T;\r\n  updateFn: (cb: (cache: T) => void) => void;\r\n}\r\n\r\nexport type CacheFileContent = {\r\n  sqaiVersion: string;\r\n  cacheId: string;\r\n  caches: Array<PlanningCache | LocateCache>;\r\n};\r\n\r\nconst lowestSupportedSqaiVersion = '0.5.0'; // SQAI rebrand - invalidates pre-0.5.0 cache\r\nexport const cacheFileExt = '.cache.yaml';\r\n\r\nexport class TaskCache {\r\n  cacheId: string;\r\n\r\n  cacheFilePath?: string;\r\n\r\n  cache: CacheFileContent;\r\n\r\n  isCacheResultUsed: boolean; // a flag to indicate if the cache result should be used\r\n  cacheOriginalLength: number;\r\n\r\n  readOnlyMode: boolean; // a flag to indicate if the cache is in read-only mode\r\n\r\n  writeOnlyMode: boolean; // a flag to indicate if the cache is in write-only mode\r\n\r\n  private matchedCacheIndices: Set<string> = new Set(); // Track matched records\r\n\r\n  constructor(\r\n    cacheId: string,\r\n    isCacheResultUsed: boolean,\r\n    cacheFilePath?: string,\r\n    options: { readOnly?: boolean; writeOnly?: boolean } = {},\r\n  ) {\r\n    assert(cacheId, 'cacheId is required');\r\n    let safeCacheId = replaceIllegalPathCharsAndSpace(cacheId);\r\n    const cacheMaxFilenameLength =\r\n      globalConfigManager.getEnvConfigInNumber(\r\n        SQAI_CACHE_MAX_FILENAME_LENGTH,\r\n      ) || DEFAULT_CACHE_MAX_FILENAME_LENGTH;\r\n    if (Buffer.byteLength(safeCacheId, 'utf8') > cacheMaxFilenameLength) {\r\n      const prefix = safeCacheId.slice(0, 32);\r\n      const hash = generateHashId(undefined, safeCacheId);\r\n      safeCacheId = `${prefix}-${hash}`;\r\n    }\r\n    this.cacheId = safeCacheId;\r\n\r\n    this.cacheFilePath =\r\n      ifInBrowser || ifInWorker\r\n        ? undefined\r\n        : cacheFilePath ||\r\n          join(getMidsceneRunSubDir('cache'), `${this.cacheId}${cacheFileExt}`);\r\n    const readOnlyMode = Boolean(options?.readOnly);\r\n    const writeOnlyMode = Boolean(options?.writeOnly);\r\n\r\n    if (readOnlyMode && writeOnlyMode) {\r\n      throw new Error('TaskCache cannot be both read-only and write-only');\r\n    }\r\n\r\n    this.isCacheResultUsed = writeOnlyMode ? false : isCacheResultUsed;\r\n    this.readOnlyMode = readOnlyMode;\r\n    this.writeOnlyMode = writeOnlyMode;\r\n\r\n    let cacheContent;\r\n    if (this.cacheFilePath && !this.writeOnlyMode) {\r\n      cacheContent = this.loadCacheFromFile();\r\n    }\r\n    if (!cacheContent) {\r\n      cacheContent = {\r\n        sqaiVersion: getSqaiVersion(),\r\n        cacheId: this.cacheId,\r\n        caches: [],\r\n      };\r\n    }\r\n    this.cache = cacheContent;\r\n    this.cacheOriginalLength = this.isCacheResultUsed\r\n      ? this.cache.caches.length\r\n      : 0;\r\n  }\r\n\r\n  matchCache(\r\n    prompt: TUserPrompt,\r\n    type: 'plan' | 'locate',\r\n  ): MatchCacheResult<PlanningCache | LocateCache> | undefined {\r\n    if (!this.isCacheResultUsed) {\r\n      return undefined;\r\n    }\r\n    // Find the first unused matching cache\r\n    for (let i = 0; i < this.cacheOriginalLength; i++) {\r\n      const item = this.cache.caches[i];\r\n      const promptStr =\r\n        typeof prompt === 'string' ? prompt : JSON.stringify(prompt);\r\n      const key = `${type}:${promptStr}:${i}`;\r\n      if (\r\n        item.type === type &&\r\n        isDeepStrictEqual(item.prompt, prompt) &&\r\n        !this.matchedCacheIndices.has(key)\r\n      ) {\r\n        if (item.type === 'locate') {\r\n          const locateItem = item as LocateCache;\r\n          if (!locateItem.cache && Array.isArray(locateItem.xpaths)) {\r\n            locateItem.cache = { xpaths: locateItem.xpaths };\r\n          }\r\n          if ('xpaths' in locateItem) {\r\n            locateItem.xpaths = undefined;\r\n          }\r\n        }\r\n        this.matchedCacheIndices.add(key);\r\n        debug(\r\n          'cache found and marked as used, type: %s, prompt: %s, index: %d',\r\n          type,\r\n          prompt,\r\n          i,\r\n        );\r\n        return {\r\n          cacheContent: item,\r\n          updateFn: (cb: (cache: PlanningCache | LocateCache) => void) => {\r\n            debug(\r\n              'will call updateFn to update cache, type: %s, prompt: %s, index: %d',\r\n              type,\r\n              prompt,\r\n              i,\r\n            );\r\n            cb(item);\r\n\r\n            if (this.readOnlyMode) {\r\n              debug(\r\n                'read-only mode, cache updated in memory but not flushed to file',\r\n              );\r\n              return;\r\n            }\r\n\r\n            debug(\r\n              'cache updated, will flush to file, type: %s, prompt: %s, index: %d',\r\n              type,\r\n              prompt,\r\n              i,\r\n            );\r\n            this.flushCacheToFile();\r\n          },\r\n        };\r\n      }\r\n    }\r\n    debug('no unused cache found, type: %s, prompt: %s', type, prompt);\r\n    return undefined;\r\n  }\r\n\r\n  matchPlanCache(prompt: string): MatchCacheResult<PlanningCache> | undefined {\r\n    return this.matchCache(prompt, 'plan') as\r\n      | MatchCacheResult<PlanningCache>\r\n      | undefined;\r\n  }\r\n\r\n  matchLocateCache(\r\n    prompt: TUserPrompt,\r\n  ): MatchCacheResult<LocateCache> | undefined {\r\n    return this.matchCache(prompt, 'locate') as\r\n      | MatchCacheResult<LocateCache>\r\n      | undefined;\r\n  }\r\n\r\n  appendCache(cache: PlanningCache | LocateCache) {\r\n    debug('will append cache', cache);\r\n    this.cache.caches.push(cache);\r\n\r\n    if (this.readOnlyMode) {\r\n      debug('read-only mode, cache appended to memory but not flushed to file');\r\n      return;\r\n    }\r\n\r\n    this.flushCacheToFile();\r\n  }\r\n\r\n  loadCacheFromFile() {\r\n    const cacheFile = this.cacheFilePath;\r\n    assert(cacheFile, 'cache file path is required');\r\n\r\n    if (!existsSync(cacheFile)) {\r\n      debug('no cache file found, path: %s', cacheFile);\r\n      return undefined;\r\n    }\r\n\r\n    // detect old cache file\r\n    const jsonTypeCacheFile = cacheFile.replace(cacheFileExt, '.json');\r\n    if (existsSync(jsonTypeCacheFile) && this.isCacheResultUsed) {\r\n      console.warn(\r\n        `An outdated cache file from an earlier version of Midscene has been detected. Since version 0.17, we have implemented an improved caching strategy. Please delete the old file located at: ${jsonTypeCacheFile}.`,\r\n      );\r\n      return undefined;\r\n    }\r\n\r\n    try {\r\n      const data = readFileSync(cacheFile, 'utf8');\r\n      const jsonData = yaml.load(data) as CacheFileContent;\r\n\r\n      const version = getSqaiVersion();\r\n      if (!version) {\r\n        debug('no SQAI version info, will not read cache from file');\r\n        return undefined;\r\n      }\r\n\r\n      if (\r\n        semver.lt(jsonData.sqaiVersion, lowestSupportedSqaiVersion) &&\r\n        !jsonData.sqaiVersion.includes('beta') // for internal test\r\n      ) {\r\n        console.warn(\r\n          `You are using an old version of SQAI cache file from before v0.5.0 rebrand. Cache format has changed.\\nPlease delete the existing cache and rebuild it. Sorry for the inconvenience.\\ncache file: ${cacheFile}`,\r\n        );\r\n        return undefined;\r\n      }\r\n\r\n      debug(\r\n        'cache loaded from file, path: %s, cache version: %s, record length: %s',\r\n        cacheFile,\r\n        jsonData.sqaiVersion,\r\n        jsonData.caches.length,\r\n      );\r\n      jsonData.sqaiVersion = getSqaiVersion(); // update the version\r\n      return jsonData;\r\n    } catch (err) {\r\n      debug(\r\n        'cache file exists but load failed, path: %s, error: %s',\r\n        cacheFile,\r\n        err,\r\n      );\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  flushCacheToFile(options?: { cleanUnused?: boolean }) {\r\n    const version = getSqaiVersion();\r\n    if (!version) {\r\n      debug('no SQAI version info, will not write cache to file');\r\n      return;\r\n    }\r\n\r\n    if (!this.cacheFilePath) {\r\n      debug('no cache file path, will not write cache to file');\r\n      return;\r\n    }\r\n\r\n    // Clean unused caches if requested\r\n    if (options?.cleanUnused) {\r\n      // Skip cleaning in write-only mode or when cache is not used\r\n      if (this.isCacheResultUsed) {\r\n        const originalLength = this.cache.caches.length;\r\n\r\n        // Collect indices of used caches\r\n        const usedIndices = new Set<number>();\r\n        for (const key of this.matchedCacheIndices) {\r\n          // key format: \"type:prompt:index\"\r\n          const parts = key.split(':');\r\n          const index = Number.parseInt(parts[parts.length - 1], 10);\r\n          if (!Number.isNaN(index)) {\r\n            usedIndices.add(index);\r\n          }\r\n        }\r\n\r\n        // Filter: keep used caches and newly added caches\r\n        this.cache.caches = this.cache.caches.filter((_, index) => {\r\n          const isUsed = usedIndices.has(index);\r\n          const isNew = index >= this.cacheOriginalLength;\r\n          return isUsed || isNew;\r\n        });\r\n\r\n        const removedCount = originalLength - this.cache.caches.length;\r\n        if (removedCount > 0) {\r\n          debug('cleaned %d unused cache record(s)', removedCount);\r\n        } else {\r\n          debug('no unused cache to clean');\r\n        }\r\n      } else {\r\n        debug('skip cleaning: cache is not used for reading');\r\n      }\r\n    }\r\n\r\n    try {\r\n      const dir = dirname(this.cacheFilePath);\r\n      if (!existsSync(dir)) {\r\n        mkdirSync(dir, { recursive: true });\r\n        debug('created cache directory: %s', dir);\r\n      }\r\n\r\n      // Sort caches to ensure plan entries come before locate entries for better readability\r\n      // Create a sorted copy for writing to disk while keeping in-memory order unchanged\r\n      const sortedCaches = [...this.cache.caches].sort((a, b) => {\r\n        if (a.type === 'plan' && b.type === 'locate') return -1;\r\n        if (a.type === 'locate' && b.type === 'plan') return 1;\r\n        return 0;\r\n      });\r\n\r\n      const cacheToWrite = {\r\n        ...this.cache,\r\n        caches: sortedCaches,\r\n      };\r\n\r\n      const yamlData = yaml.dump(cacheToWrite);\r\n      writeFileSync(this.cacheFilePath, yamlData);\r\n      debug('cache flushed to file: %s', this.cacheFilePath);\r\n    } catch (err) {\r\n      debug(\r\n        'write cache to file failed, path: %s, error: %s',\r\n        this.cacheFilePath,\r\n        err,\r\n      );\r\n    }\r\n  }\r\n\r\n  updateOrAppendCacheRecord(\r\n    newRecord: PlanningCache | LocateCache,\r\n    cachedRecord?: MatchCacheResult<PlanningCache | LocateCache>,\r\n  ) {\r\n    if (cachedRecord) {\r\n      // update existing record\r\n      if (newRecord.type === 'plan') {\r\n        cachedRecord.updateFn((cache) => {\r\n          (cache as PlanningCache).yamlWorkflow = newRecord.yamlWorkflow;\r\n        });\r\n      } else {\r\n        cachedRecord.updateFn((cache) => {\r\n          const locateCache = cache as LocateCache;\r\n          locateCache.cache = newRecord.cache;\r\n          if ('xpaths' in locateCache) {\r\n            locateCache.xpaths = undefined;\r\n          }\r\n        });\r\n      }\r\n    } else {\r\n      this.appendCache(newRecord);\r\n    }\r\n  }\r\n}\r\n"],"names":["__webpack_require__","module","getter","definition","key","Object","obj","prop","Symbol","DEFAULT_CACHE_MAX_FILENAME_LENGTH","debug","getDebug","lowestSupportedSqaiVersion","cacheFileExt","TaskCache","prompt","type","i","item","promptStr","JSON","isDeepStrictEqual","locateItem","Array","undefined","cb","cache","cacheFile","assert","existsSync","jsonTypeCacheFile","console","data","readFileSync","jsonData","yaml","version","getSqaiVersion","semver","err","options","originalLength","usedIndices","Set","parts","index","Number","_","isUsed","isNew","removedCount","dir","dirname","mkdirSync","sortedCaches","a","b","cacheToWrite","yamlData","writeFileSync","newRecord","cachedRecord","locateCache","cacheId","isCacheResultUsed","cacheFilePath","safeCacheId","replaceIllegalPathCharsAndSpace","cacheMaxFilenameLength","globalConfigManager","SQAI_CACHE_MAX_FILENAME_LENGTH","Buffer","prefix","hash","generateHashId","ifInBrowser","ifInWorker","join","getMidsceneRunSubDir","readOnlyMode","Boolean","writeOnlyMode","Error","cacheContent"],"mappings":";;;IACAA,oBAAoB,CAAC,GAAG,CAACC;QACxB,IAAIC,SAASD,UAAUA,OAAO,UAAU,GACvC,IAAOA,MAAM,CAAC,UAAU,GACxB,IAAOA;QACRD,oBAAoB,CAAC,CAACE,QAAQ;YAAE,GAAGA;QAAO;QAC1C,OAAOA;IACR;;;ICPAF,oBAAoB,CAAC,GAAG,CAAC,UAASG;QACjC,IAAI,IAAIC,OAAOD,WACR,IAAGH,oBAAoB,CAAC,CAACG,YAAYC,QAAQ,CAACJ,oBAAoB,CAAC,CAAC,UAASI,MACzEC,OAAO,cAAc,CAAC,UAASD,KAAK;YAAE,YAAY;YAAM,KAAKD,UAAU,CAACC,IAAI;QAAC;IAGzF;;;ICNAJ,oBAAoB,CAAC,GAAG,CAACM,KAAKC,OAAUF,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAACC,KAAKC;;;ICClFP,oBAAoB,CAAC,GAAG,CAAC;QACxB,IAAG,AAAkB,eAAlB,OAAOQ,UAA0BA,OAAO,WAAW,EACrDH,OAAO,cAAc,CAAC,UAASG,OAAO,WAAW,EAAE;YAAE,OAAO;QAAS;QAEtEH,OAAO,cAAc,CAAC,UAAS,cAAc;YAAE,OAAO;QAAK;IAC5D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACaA,MAAMI,oCAAoC;AAEnC,MAAMC,QAAQC,AAAAA,IAAAA,uBAAAA,QAAAA,AAAAA,EAAS;AA2B9B,MAAMC,6BAA6B;AAC5B,MAAMC,eAAe;AAErB,MAAMC;IAoEX,WACEC,MAAmB,EACnBC,IAAuB,EACoC;QAC3D,IAAI,CAAC,IAAI,CAAC,iBAAiB,EACzB;QAGF,IAAK,IAAIC,IAAI,GAAGA,IAAI,IAAI,CAAC,mBAAmB,EAAEA,IAAK;YACjD,MAAMC,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,CAACD,EAAE;YACjC,MAAME,YACJ,AAAkB,YAAlB,OAAOJ,SAAsBA,SAASK,KAAK,SAAS,CAACL;YACvD,MAAMX,MAAM,GAAGY,KAAK,CAAC,EAAEG,UAAU,CAAC,EAAEF,GAAG;YACvC,IACEC,KAAK,IAAI,KAAKF,QACdK,AAAAA,IAAAA,mCAAAA,iBAAAA,AAAAA,EAAkBH,KAAK,MAAM,EAAEH,WAC/B,CAAC,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAACX,MAC9B;gBACA,IAAIc,AAAc,aAAdA,KAAK,IAAI,EAAe;oBAC1B,MAAMI,aAAaJ;oBACnB,IAAI,CAACI,WAAW,KAAK,IAAIC,MAAM,OAAO,CAACD,WAAW,MAAM,GACtDA,WAAW,KAAK,GAAG;wBAAE,QAAQA,WAAW,MAAM;oBAAC;oBAEjD,IAAI,YAAYA,YACdA,WAAW,MAAM,GAAGE;gBAExB;gBACA,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAACpB;gBAC7BM,MACE,mEACAM,MACAD,QACAE;gBAEF,OAAO;oBACL,cAAcC;oBACd,UAAU,CAACO;wBACTf,MACE,uEACAM,MACAD,QACAE;wBAEFQ,GAAGP;wBAEH,IAAI,IAAI,CAAC,YAAY,EAAE,YACrBR,MACE;wBAKJA,MACE,sEACAM,MACAD,QACAE;wBAEF,IAAI,CAAC,gBAAgB;oBACvB;gBACF;YACF;QACF;QACAP,MAAM,+CAA+CM,MAAMD;IAE7D;IAEA,eAAeA,MAAc,EAA+C;QAC1E,OAAO,IAAI,CAAC,UAAU,CAACA,QAAQ;IAGjC;IAEA,iBACEA,MAAmB,EACwB;QAC3C,OAAO,IAAI,CAAC,UAAU,CAACA,QAAQ;IAGjC;IAEA,YAAYW,KAAkC,EAAE;QAC9ChB,MAAM,qBAAqBgB;QAC3B,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAACA;QAEvB,IAAI,IAAI,CAAC,YAAY,EAAE,YACrBhB,MAAM;QAIR,IAAI,CAAC,gBAAgB;IACvB;IAEA,oBAAoB;QAClB,MAAMiB,YAAY,IAAI,CAAC,aAAa;QACpCC,+BAAOD,WAAW;QAElB,IAAI,CAACE,AAAAA,IAAAA,iCAAAA,UAAAA,AAAAA,EAAWF,YAAY,YAC1BjB,MAAM,iCAAiCiB;QAKzC,MAAMG,oBAAoBH,UAAU,OAAO,CAACd,cAAc;QAC1D,IAAIgB,AAAAA,IAAAA,iCAAAA,UAAAA,AAAAA,EAAWC,sBAAsB,IAAI,CAAC,iBAAiB,EAAE,YAC3DC,QAAQ,IAAI,CACV,CAAC,2LAA2L,EAAED,kBAAkB,CAAC,CAAC;QAKtN,IAAI;YACF,MAAME,OAAOC,AAAAA,IAAAA,iCAAAA,YAAAA,AAAAA,EAAaN,WAAW;YACrC,MAAMO,WAAWC,2BAAAA,IAAS,CAACH;YAE3B,MAAMI,UAAUC,AAAAA,IAAAA,kCAAAA,cAAAA,AAAAA;YAChB,IAAI,CAACD,SAAS,YACZ1B,MAAM;YAIR,IACE4B,0BAAAA,EAAS,CAACJ,SAAS,WAAW,EAAEtB,+BAChC,CAACsB,SAAS,WAAW,CAAC,QAAQ,CAAC,SAC/B,YACAH,QAAQ,IAAI,CACV,CAAC,kMAAkM,EAAEJ,WAAW;YAKpNjB,MACE,0EACAiB,WACAO,SAAS,WAAW,EACpBA,SAAS,MAAM,CAAC,MAAM;YAExBA,SAAS,WAAW,GAAGG,AAAAA,IAAAA,kCAAAA,cAAAA,AAAAA;YACvB,OAAOH;QACT,EAAE,OAAOK,KAAK;YACZ7B,MACE,0DACAiB,WACAY;YAEF;QACF;IACF;IAEA,iBAAiBC,OAAmC,EAAE;QACpD,MAAMJ,UAAUC,AAAAA,IAAAA,kCAAAA,cAAAA,AAAAA;QAChB,IAAI,CAACD,SAAS,YACZ1B,MAAM;QAIR,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,YACvBA,MAAM;QAKR,IAAI8B,QAAAA,UAAAA,KAAAA,IAAAA,QAAS,WAAW,EAEtB,IAAI,IAAI,CAAC,iBAAiB,EAAE;YAC1B,MAAMC,iBAAiB,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM;YAG/C,MAAMC,cAAc,IAAIC;YACxB,KAAK,MAAMvC,OAAO,IAAI,CAAC,mBAAmB,CAAE;gBAE1C,MAAMwC,QAAQxC,IAAI,KAAK,CAAC;gBACxB,MAAMyC,QAAQC,OAAO,QAAQ,CAACF,KAAK,CAACA,MAAM,MAAM,GAAG,EAAE,EAAE;gBACvD,IAAI,CAACE,OAAO,KAAK,CAACD,QAChBH,YAAY,GAAG,CAACG;YAEpB;YAGA,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,CAACE,GAAGF;gBAC/C,MAAMG,SAASN,YAAY,GAAG,CAACG;gBAC/B,MAAMI,QAAQJ,SAAS,IAAI,CAAC,mBAAmB;gBAC/C,OAAOG,UAAUC;YACnB;YAEA,MAAMC,eAAeT,iBAAiB,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM;YAC1DS,eAAe,IACjBxC,MAAM,qCAAqCwC,gBAE3CxC,MAAM;QAEV,OACEA,MAAM;QAIV,IAAI;YACF,MAAMyC,MAAMC,AAAAA,IAAAA,mCAAAA,OAAAA,AAAAA,EAAQ,IAAI,CAAC,aAAa;YACtC,IAAI,CAACvB,AAAAA,IAAAA,iCAAAA,UAAAA,AAAAA,EAAWsB,MAAM;gBACpBE,IAAAA,iCAAAA,SAAAA,AAAAA,EAAUF,KAAK;oBAAE,WAAW;gBAAK;gBACjCzC,MAAM,+BAA+ByC;YACvC;YAIA,MAAMG,eAAe;mBAAI,IAAI,CAAC,KAAK,CAAC,MAAM;aAAC,CAAC,IAAI,CAAC,CAACC,GAAGC;gBACnD,IAAID,AAAW,WAAXA,EAAE,IAAI,IAAeC,AAAW,aAAXA,EAAE,IAAI,EAAe,OAAO;gBACrD,IAAID,AAAW,aAAXA,EAAE,IAAI,IAAiBC,AAAW,WAAXA,EAAE,IAAI,EAAa,OAAO;gBACrD,OAAO;YACT;YAEA,MAAMC,eAAe;gBACnB,GAAG,IAAI,CAAC,KAAK;gBACb,QAAQH;YACV;YAEA,MAAMI,WAAWvB,2BAAAA,IAAS,CAACsB;YAC3BE,IAAAA,iCAAAA,aAAAA,AAAAA,EAAc,IAAI,CAAC,aAAa,EAAED;YAClChD,MAAM,6BAA6B,IAAI,CAAC,aAAa;QACvD,EAAE,OAAO6B,KAAK;YACZ7B,MACE,mDACA,IAAI,CAAC,aAAa,EAClB6B;QAEJ;IACF;IAEA,0BACEqB,SAAsC,EACtCC,YAA4D,EAC5D;QACA,IAAIA,cAEF,IAAID,AAAmB,WAAnBA,UAAU,IAAI,EAChBC,aAAa,QAAQ,CAAC,CAACnC;YACpBA,MAAwB,YAAY,GAAGkC,UAAU,YAAY;QAChE;aAEAC,aAAa,QAAQ,CAAC,CAACnC;YACrB,MAAMoC,cAAcpC;YACpBoC,YAAY,KAAK,GAAGF,UAAU,KAAK;YACnC,IAAI,YAAYE,aACdA,YAAY,MAAM,GAAGtC;QAEzB;aAGF,IAAI,CAAC,WAAW,CAACoC;IAErB;IA9SA,YACEG,OAAe,EACfC,iBAA0B,EAC1BC,aAAsB,EACtBzB,UAAuD,CAAC,CAAC,CACzD;QApBF;QAEA;QAEA;QAEA;QACA;QAEA;QAEA;QAEA,uBAAQ,uBAAmC,IAAIG;QAQ7Cf,+BAAOmC,SAAS;QAChB,IAAIG,cAAcC,AAAAA,IAAAA,sBAAAA,+BAAAA,AAAAA,EAAgCJ;QAClD,MAAMK,yBACJC,oBAAAA,mBAAAA,CAAAA,oBAAwC,CACtCC,oBAAAA,8BAA8BA,KAC3B7D;QACP,IAAI8D,OAAO,UAAU,CAACL,aAAa,UAAUE,wBAAwB;YACnE,MAAMI,SAASN,YAAY,KAAK,CAAC,GAAG;YACpC,MAAMO,OAAOC,AAAAA,IAAAA,sBAAAA,cAAAA,AAAAA,EAAelD,QAAW0C;YACvCA,cAAc,GAAGM,OAAO,CAAC,EAAEC,MAAM;QACnC;QACA,IAAI,CAAC,OAAO,GAAGP;QAEf,IAAI,CAAC,aAAa,GAChBS,sBAAAA,WAAWA,IAAIC,sBAAAA,UAAUA,GACrBpD,SACAyC,iBACAY,AAAAA,IAAAA,mCAAAA,IAAAA,AAAAA,EAAKC,AAAAA,IAAAA,uBAAAA,oBAAAA,AAAAA,EAAqB,UAAU,GAAG,IAAI,CAAC,OAAO,GAAGjE,cAAc;QAC1E,MAAMkE,eAAeC,QAAQxC,QAAAA,UAAAA,KAAAA,IAAAA,QAAS,QAAQ;QAC9C,MAAMyC,gBAAgBD,QAAQxC,QAAAA,UAAAA,KAAAA,IAAAA,QAAS,SAAS;QAEhD,IAAIuC,gBAAgBE,eAClB,MAAM,IAAIC,MAAM;QAGlB,IAAI,CAAC,iBAAiB,GAAGD,gBAAgB,QAAQjB;QACjD,IAAI,CAAC,YAAY,GAAGe;QACpB,IAAI,CAAC,aAAa,GAAGE;QAErB,IAAIE;QACJ,IAAI,IAAI,CAAC,aAAa,IAAI,CAAC,IAAI,CAAC,aAAa,EAC3CA,eAAe,IAAI,CAAC,iBAAiB;QAEvC,IAAI,CAACA,cACHA,eAAe;YACb,aAAa9C,AAAAA,IAAAA,kCAAAA,cAAAA,AAAAA;YACb,SAAS,IAAI,CAAC,OAAO;YACrB,QAAQ,EAAE;QACZ;QAEF,IAAI,CAAC,KAAK,GAAG8C;QACb,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,iBAAiB,GAC7C,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,GACxB;IACN;AA6PF"}