{"version":3,"file":"agent\\tasks.mjs","sources":["webpack://@sqai/core/./src/agent/tasks.ts"],"sourcesContent":["import {\r\n  ConversationHistory,\r\n  findAllMidsceneLocatorField,\r\n  parseActionParam,\r\n  plan,\r\n  uiTarsPlanning,\r\n} from '@/ai-model';\r\nimport { Executor } from '@/ai-model/action-executor';\r\nimport type { TMultimodalPrompt, TUserPrompt } from '@/ai-model/common';\r\nimport type { AbstractInterface } from '@/device';\r\nimport type Insight from '@/insight';\r\nimport type {\r\n  AIUsageInfo,\r\n  DetailedLocateParam,\r\n  DumpSubscriber,\r\n  ElementCacheFeature,\r\n  ExecutionRecorderItem,\r\n  ExecutionTaskActionApply,\r\n  ExecutionTaskApply,\r\n  ExecutionTaskHitBy,\r\n  ExecutionTaskInsightLocateApply,\r\n  ExecutionTaskInsightQueryApply,\r\n  ExecutionTaskPlanning,\r\n  ExecutionTaskPlanningApply,\r\n  ExecutionTaskProgressOptions,\r\n  ExecutorContext,\r\n  InsightDump,\r\n  InsightExtractOption,\r\n  InsightExtractParam,\r\n  InterfaceType,\r\n  LocateResultElement,\r\n  MidsceneYamlFlowItem,\r\n  PlanningAIResponse,\r\n  PlanningAction,\r\n  PlanningActionParamError,\r\n  PlanningActionParamSleep,\r\n  PlanningActionParamWaitFor,\r\n  PlanningLocateParam,\r\n} from '@/types';\r\nimport { sleep } from '@/utils';\r\nimport {\r\n  type IModelConfig,\r\n  SQAI_REPLANNING_CYCLE_LIMIT,\r\n  globalConfigManager,\r\n} from '@sqai/shared/env';\r\nimport { getDebug } from '@sqai/shared/logger';\r\nimport { assert } from '@sqai/shared/utils';\r\nimport type { TaskCache } from './task-cache';\r\nimport { taskTitleStr } from './ui-utils';\r\nimport {\r\n  matchElementFromCache,\r\n  matchElementFromPlan,\r\n  parsePrompt,\r\n} from './utils';\r\n\r\ninterface ExecutionResult<OutputType = any> {\r\n  output: OutputType;\r\n  thought?: string;\r\n  executor: Executor;\r\n}\r\n\r\nconst debug = getDebug('device-task-executor');\r\nconst defaultReplanningCycleLimit = 10;\r\nconst defaultVlmUiTarsReplanningCycleLimit = 40;\r\n\r\nexport function locatePlanForLocate(param: string | DetailedLocateParam) {\r\n  const locate = typeof param === 'string' ? { prompt: param } : param;\r\n  const locatePlan: PlanningAction<PlanningLocateParam> = {\r\n    type: 'Locate',\r\n    locate,\r\n    param: locate,\r\n    thought: '',\r\n  };\r\n  return locatePlan;\r\n}\r\n\r\nexport class TaskExecutor {\r\n  interface: AbstractInterface;\r\n\r\n  insight: Insight;\r\n\r\n  taskCache?: TaskCache;\r\n\r\n  private conversationHistory: ConversationHistory;\r\n\r\n  onTaskStartCallback?: ExecutionTaskProgressOptions['onTaskStart'];\r\n\r\n  replanningCycleLimit?: number;\r\n\r\n  // @deprecated use .interface instead\r\n  get page() {\r\n    return this.interface;\r\n  }\r\n\r\n  constructor(\r\n    interfaceInstance: AbstractInterface,\r\n    insight: Insight,\r\n    opts: {\r\n      taskCache?: TaskCache;\r\n      onTaskStart?: ExecutionTaskProgressOptions['onTaskStart'];\r\n      replanningCycleLimit?: number;\r\n    },\r\n  ) {\r\n    this.interface = interfaceInstance;\r\n    this.insight = insight;\r\n    this.taskCache = opts.taskCache;\r\n    this.onTaskStartCallback = opts?.onTaskStart;\r\n    this.replanningCycleLimit = opts.replanningCycleLimit;\r\n    this.conversationHistory = new ConversationHistory();\r\n  }\r\n\r\n  private async recordScreenshot(timing: ExecutionRecorderItem['timing']) {\r\n    const base64 = await this.interface.screenshotBase64();\r\n    const item: ExecutionRecorderItem = {\r\n      type: 'screenshot',\r\n      ts: Date.now(),\r\n      screenshot: base64,\r\n      timing,\r\n    };\r\n    return item;\r\n  }\r\n\r\n  private prependExecutorWithScreenshot(\r\n    taskApply: ExecutionTaskApply,\r\n    appendAfterExecution = false,\r\n  ): ExecutionTaskApply {\r\n    const taskWithScreenshot: ExecutionTaskApply = {\r\n      ...taskApply,\r\n      executor: async (param, context, ...args) => {\r\n        const recorder: ExecutionRecorderItem[] = [];\r\n        const { task } = context;\r\n        // set the recorder before executor in case of error\r\n        task.recorder = recorder;\r\n        const shot = await this.recordScreenshot(`before ${task.type}`);\r\n        recorder.push(shot);\r\n\r\n        const result = await taskApply.executor(param, context, ...args);\r\n\r\n        if (appendAfterExecution) {\r\n          const shot2 = await this.recordScreenshot('after Action');\r\n          recorder.push(shot2);\r\n        }\r\n        return result;\r\n      },\r\n    };\r\n    return taskWithScreenshot;\r\n  }\r\n\r\n  public async convertPlanToExecutable(\r\n    plans: PlanningAction[],\r\n    modelConfig: IModelConfig,\r\n    cacheable?: boolean,\r\n  ) {\r\n    const tasks: ExecutionTaskApply[] = [];\r\n\r\n    const taskForLocatePlan = (\r\n      plan: PlanningAction<PlanningLocateParam>,\r\n      detailedLocateParam: DetailedLocateParam | string,\r\n      onResult?: (result: LocateResultElement) => void,\r\n    ): ExecutionTaskInsightLocateApply => {\r\n      if (typeof detailedLocateParam === 'string') {\r\n        detailedLocateParam = {\r\n          prompt: detailedLocateParam,\r\n        };\r\n      }\r\n      // Apply cacheable option from convertPlanToExecutable if it was explicitly set\r\n      if (cacheable !== undefined) {\r\n        detailedLocateParam = {\r\n          ...detailedLocateParam,\r\n          cacheable,\r\n        };\r\n      }\r\n      const taskFind: ExecutionTaskInsightLocateApply = {\r\n        type: 'Insight',\r\n        subType: 'Locate',\r\n        param: detailedLocateParam,\r\n        thought: plan.thought,\r\n        executor: async (param, taskContext) => {\r\n          const { task } = taskContext;\r\n          assert(\r\n            param?.prompt || param?.id || param?.bbox,\r\n            `No prompt or id or position or bbox to locate, param=${JSON.stringify(\r\n              param,\r\n            )}`,\r\n          );\r\n          let insightDump: InsightDump | undefined;\r\n          let usage: AIUsageInfo | undefined;\r\n          const dumpCollector: DumpSubscriber = (dump) => {\r\n            insightDump = dump;\r\n            usage = dump?.taskInfo?.usage;\r\n\r\n            task.log = {\r\n              dump: insightDump,\r\n            };\r\n\r\n            task.usage = usage;\r\n\r\n            // Store searchAreaUsage in task metadata\r\n            if (dump?.taskInfo?.searchAreaUsage) {\r\n              task.searchAreaUsage = dump.taskInfo.searchAreaUsage;\r\n            }\r\n          };\r\n          this.insight.onceDumpUpdatedFn = dumpCollector;\r\n          const shotTime = Date.now();\r\n\r\n          // Get context through contextRetrieverFn which handles frozen context\r\n          const uiContext = await this.insight.contextRetrieverFn('locate');\r\n          task.uiContext = uiContext;\r\n\r\n          const recordItem: ExecutionRecorderItem = {\r\n            type: 'screenshot',\r\n            ts: shotTime,\r\n            screenshot: uiContext.screenshotBase64,\r\n            timing: 'before Insight',\r\n          };\r\n          task.recorder = [recordItem];\r\n\r\n          // try matching xpath\r\n          const elementFromXpath =\r\n            param.xpath && (this.interface as any).getElementInfoByXpath\r\n              ? await (this.interface as any).getElementInfoByXpath(param.xpath)\r\n              : undefined;\r\n          const userExpectedPathHitFlag = !!elementFromXpath;\r\n\r\n          // try matching cache\r\n          const cachePrompt = param.prompt;\r\n          const locateCacheRecord =\r\n            this.taskCache?.matchLocateCache(cachePrompt);\r\n          const cacheEntry = locateCacheRecord?.cacheContent?.cache;\r\n          const elementFromCache = userExpectedPathHitFlag\r\n            ? null\r\n            : await matchElementFromCache(\r\n                this,\r\n                cacheEntry,\r\n                cachePrompt,\r\n                param.cacheable,\r\n              );\r\n          const cacheHitFlag = !!elementFromCache;\r\n\r\n          // try matching plan\r\n          const elementFromPlan =\r\n            !userExpectedPathHitFlag && !cacheHitFlag\r\n              ? matchElementFromPlan(param, uiContext.tree)\r\n              : undefined;\r\n          const planHitFlag = !!elementFromPlan;\r\n\r\n          // try ai locate\r\n          const elementFromAiLocate =\r\n            !userExpectedPathHitFlag && !cacheHitFlag && !planHitFlag\r\n              ? (\r\n                  await this.insight.locate(\r\n                    param,\r\n                    {\r\n                      // fallback to ai locate\r\n                      context: uiContext,\r\n                    },\r\n                    modelConfig,\r\n                  )\r\n                ).element\r\n              : undefined;\r\n          const aiLocateHitFlag = !!elementFromAiLocate;\r\n\r\n          const element =\r\n            elementFromXpath || // highest priority\r\n            elementFromCache || // second priority\r\n            elementFromPlan || // third priority\r\n            elementFromAiLocate;\r\n\r\n          // update cache\r\n          let currentCacheEntry: ElementCacheFeature | undefined;\r\n          if (\r\n            element &&\r\n            this.taskCache &&\r\n            !cacheHitFlag &&\r\n            param?.cacheable !== false\r\n          ) {\r\n            if (this.interface.cacheFeatureForRect) {\r\n              try {\r\n                const feature = await this.interface.cacheFeatureForRect(\r\n                  element.rect,\r\n                  element.isOrderSensitive !== undefined\r\n                    ? { _orderSensitive: element.isOrderSensitive }\r\n                    : undefined,\r\n                );\r\n                if (feature && Object.keys(feature).length > 0) {\r\n                  debug(\r\n                    'update cache, prompt: %s, cache: %o',\r\n                    cachePrompt,\r\n                    feature,\r\n                  );\r\n                  currentCacheEntry = feature;\r\n                  this.taskCache.updateOrAppendCacheRecord(\r\n                    {\r\n                      type: 'locate',\r\n                      prompt: cachePrompt,\r\n                      cache: feature,\r\n                    },\r\n                    locateCacheRecord,\r\n                  );\r\n                } else {\r\n                  debug(\r\n                    'no cache data returned, skip cache update, prompt: %s',\r\n                    cachePrompt,\r\n                  );\r\n                }\r\n              } catch (error) {\r\n                debug('cacheFeatureForRect failed: %s', error);\r\n              }\r\n            } else {\r\n              debug('cacheFeatureForRect is not supported, skip cache update');\r\n            }\r\n          }\r\n          if (!element) {\r\n            throw new Error(`Element not found: ${param.prompt}`);\r\n          }\r\n\r\n          let hitBy: ExecutionTaskHitBy | undefined;\r\n\r\n          if (userExpectedPathHitFlag) {\r\n            hitBy = {\r\n              from: 'User expected path',\r\n              context: {\r\n                xpath: param.xpath,\r\n              },\r\n            };\r\n          } else if (cacheHitFlag) {\r\n            hitBy = {\r\n              from: 'Cache',\r\n              context: {\r\n                cacheEntry,\r\n                cacheToSave: currentCacheEntry,\r\n              },\r\n            };\r\n          } else if (planHitFlag) {\r\n            hitBy = {\r\n              from: 'Planning',\r\n              context: {\r\n                id: elementFromPlan?.id,\r\n                bbox: elementFromPlan?.bbox,\r\n              },\r\n            };\r\n          } else if (aiLocateHitFlag) {\r\n            hitBy = {\r\n              from: 'AI model',\r\n              context: {\r\n                prompt: param.prompt,\r\n              },\r\n            };\r\n          }\r\n\r\n          onResult?.(element);\r\n\r\n          return {\r\n            output: {\r\n              element,\r\n            },\r\n            uiContext,\r\n            hitBy,\r\n          };\r\n        },\r\n      };\r\n      return taskFind;\r\n    };\r\n\r\n    for (const plan of plans) {\r\n      if (plan.type === 'Locate') {\r\n        if (\r\n          !plan.locate ||\r\n          plan.locate === null ||\r\n          plan.locate?.id === null ||\r\n          plan.locate?.id === 'null'\r\n        ) {\r\n          debug('Locate action with id is null, will be ignored', plan);\r\n          continue;\r\n        }\r\n        const taskLocate = taskForLocatePlan(plan, plan.locate);\r\n\r\n        tasks.push(taskLocate);\r\n      } else if (plan.type === 'Error') {\r\n        const taskActionError: ExecutionTaskActionApply<PlanningActionParamError> =\r\n          {\r\n            type: 'Action',\r\n            subType: 'Error',\r\n            param: plan.param,\r\n            thought: plan.thought || plan.param?.thought,\r\n            locate: plan.locate,\r\n            executor: async () => {\r\n              throw new Error(\r\n                plan?.thought || plan.param?.thought || 'error without thought',\r\n              );\r\n            },\r\n          };\r\n        tasks.push(taskActionError);\r\n      } else if (plan.type === 'Finished') {\r\n        const taskActionFinished: ExecutionTaskActionApply<null> = {\r\n          type: 'Action',\r\n          subType: 'Finished',\r\n          param: null,\r\n          thought: plan.thought,\r\n          locate: plan.locate,\r\n          executor: async (param) => {},\r\n        };\r\n        tasks.push(taskActionFinished);\r\n      } else if (plan.type === 'Sleep') {\r\n        const taskActionSleep: ExecutionTaskActionApply<PlanningActionParamSleep> =\r\n          {\r\n            type: 'Action',\r\n            subType: 'Sleep',\r\n            param: plan.param,\r\n            thought: plan.thought,\r\n            locate: plan.locate,\r\n            executor: async (taskParam) => {\r\n              await sleep(taskParam?.timeMs || 3000);\r\n            },\r\n          };\r\n        tasks.push(taskActionSleep);\r\n      } else {\r\n        // action in action space\r\n        const planType = plan.type;\r\n        const actionSpace = await this.interface.actionSpace();\r\n        const action = actionSpace.find((action) => action.name === planType);\r\n        const param = plan.param;\r\n\r\n        if (!action) {\r\n          throw new Error(`Action type '${planType}' not found`);\r\n        }\r\n\r\n        // find all params that needs location\r\n        const locateFields = action\r\n          ? findAllMidsceneLocatorField(action.paramSchema)\r\n          : [];\r\n\r\n        const requiredLocateFields = action\r\n          ? findAllMidsceneLocatorField(action.paramSchema, true)\r\n          : [];\r\n\r\n        locateFields.forEach((field) => {\r\n          if (param[field]) {\r\n            const locatePlan = locatePlanForLocate(param[field]);\r\n            debug(\r\n              'will prepend locate param for field',\r\n              `action.type=${planType}`,\r\n              `param=${JSON.stringify(param[field])}`,\r\n              `locatePlan=${JSON.stringify(locatePlan)}`,\r\n            );\r\n            const locateTask = taskForLocatePlan(\r\n              locatePlan,\r\n              param[field],\r\n              (result) => {\r\n                param[field] = result;\r\n              },\r\n            );\r\n            tasks.push(locateTask);\r\n          } else {\r\n            assert(\r\n              !requiredLocateFields.includes(field),\r\n              `Required locate field '${field}' is not provided for action ${planType}`,\r\n            );\r\n            debug(`field '${field}' is not provided for action ${planType}`);\r\n          }\r\n        });\r\n\r\n        const task: ExecutionTaskApply<\r\n          'Action',\r\n          any,\r\n          { success: boolean; action: string; param: any },\r\n          void\r\n        > = {\r\n          type: 'Action',\r\n          subType: planType,\r\n          thought: plan.thought,\r\n          param: plan.param,\r\n          executor: async (param, context) => {\r\n            debug(\r\n              'executing action',\r\n              planType,\r\n              param,\r\n              `context.element.center: ${context.element?.center}`,\r\n            );\r\n\r\n            // Get context for actionSpace operations to ensure size info is available\r\n            const uiContext = await this.insight.contextRetrieverFn('locate');\r\n            context.task.uiContext = uiContext;\r\n\r\n            requiredLocateFields.forEach((field) => {\r\n              assert(\r\n                param[field],\r\n                `field '${field}' is required for action ${planType} but not provided. Cannot execute action ${planType}.`,\r\n              );\r\n            });\r\n\r\n            try {\r\n              await Promise.all([\r\n                (async () => {\r\n                  if (this.interface.beforeInvokeAction) {\r\n                    debug('will call \"beforeInvokeAction\" for interface');\r\n                    await this.interface.beforeInvokeAction(action.name, param);\r\n                    debug('called \"beforeInvokeAction\" for interface');\r\n                  }\r\n                })(),\r\n                sleep(200),\r\n              ]);\r\n            } catch (originalError: any) {\r\n              const originalMessage =\r\n                originalError?.message || String(originalError);\r\n              throw new Error(\r\n                `error in running beforeInvokeAction for ${action.name}: ${originalMessage}`,\r\n                { cause: originalError },\r\n              );\r\n            }\r\n\r\n            // Validate and parse parameters with defaults\r\n            if (action.paramSchema) {\r\n              try {\r\n                param = parseActionParam(param, action.paramSchema);\r\n              } catch (error: any) {\r\n                throw new Error(\r\n                  `Invalid parameters for action ${action.name}: ${error.message}\\nParameters: ${JSON.stringify(param)}`,\r\n                  { cause: error },\r\n                );\r\n              }\r\n            }\r\n\r\n            debug('calling action', action.name);\r\n            const actionFn = action.call.bind(this.interface);\r\n            await actionFn(param, context);\r\n            debug('called action', action.name);\r\n\r\n            await sleep(300); // wait for the action to complete\r\n\r\n            try {\r\n              if (this.interface.afterInvokeAction) {\r\n                debug('will call \"afterInvokeAction\" for interface');\r\n                await this.interface.afterInvokeAction(action.name, param);\r\n                debug('called \"afterInvokeAction\" for interface');\r\n              }\r\n            } catch (originalError: any) {\r\n              const originalMessage =\r\n                originalError?.message || String(originalError);\r\n              throw new Error(\r\n                `error in running afterInvokeAction for ${action.name}: ${originalMessage}`,\r\n                { cause: originalError },\r\n              );\r\n            }\r\n            // Return a proper result for report generation\r\n            return {\r\n              output: {\r\n                success: true,\r\n                action: planType,\r\n                param: param,\r\n              },\r\n            };\r\n          },\r\n        };\r\n        tasks.push(task);\r\n      }\r\n    }\r\n\r\n    const wrappedTasks = tasks.map(\r\n      (task: ExecutionTaskApply, index: number) => {\r\n        if (task.type === 'Action') {\r\n          return this.prependExecutorWithScreenshot(\r\n            task,\r\n            index === tasks.length - 1,\r\n          );\r\n        }\r\n        return task;\r\n      },\r\n    );\r\n\r\n    return {\r\n      tasks: wrappedTasks,\r\n    };\r\n  }\r\n\r\n  private async setupPlanningContext(executorContext: ExecutorContext) {\r\n    const shotTime = Date.now();\r\n    const uiContext = await this.insight.contextRetrieverFn('locate');\r\n    const recordItem: ExecutionRecorderItem = {\r\n      type: 'screenshot',\r\n      ts: shotTime,\r\n      screenshot: uiContext.screenshotBase64,\r\n      timing: 'before Planning',\r\n    };\r\n\r\n    executorContext.task.recorder = [recordItem];\r\n    (executorContext.task as ExecutionTaskPlanning).uiContext = uiContext;\r\n\r\n    return {\r\n      uiContext,\r\n    };\r\n  }\r\n\r\n  async loadYamlFlowAsPlanning(userInstruction: string, yamlString: string) {\r\n    const taskExecutor = new Executor(taskTitleStr('Action', userInstruction), {\r\n      onTaskStart: this.onTaskStartCallback,\r\n    });\r\n\r\n    const task: ExecutionTaskPlanningApply = {\r\n      type: 'Planning',\r\n      subType: 'LoadYaml',\r\n      locate: null,\r\n      param: {\r\n        userInstruction,\r\n      },\r\n      executor: async (param, executorContext) => {\r\n        await this.setupPlanningContext(executorContext);\r\n        return {\r\n          output: {\r\n            actions: [],\r\n            more_actions_needed_by_instruction: false,\r\n            log: '',\r\n            yamlString,\r\n          },\r\n          cache: {\r\n            hit: true,\r\n          },\r\n          hitBy: {\r\n            from: 'Cache',\r\n            context: {\r\n              yamlString,\r\n            },\r\n          },\r\n        };\r\n      },\r\n    };\r\n\r\n    await taskExecutor.append(task);\r\n    await taskExecutor.flush();\r\n\r\n    return {\r\n      executor: taskExecutor,\r\n    };\r\n  }\r\n\r\n  private createPlanningTask(\r\n    userInstruction: string,\r\n    actionContext: string | undefined,\r\n    modelConfig: IModelConfig,\r\n  ): ExecutionTaskPlanningApply {\r\n    const task: ExecutionTaskPlanningApply = {\r\n      type: 'Planning',\r\n      subType: 'Plan',\r\n      locate: null,\r\n      param: {\r\n        userInstruction,\r\n      },\r\n      executor: async (param, executorContext) => {\r\n        const startTime = Date.now();\r\n        const { uiContext } = await this.setupPlanningContext(executorContext);\r\n        const { vlMode } = modelConfig;\r\n        const uiTarsModelVersion =\r\n          vlMode === 'vlm-ui-tars' ? modelConfig.uiTarsModelVersion : undefined;\r\n\r\n        assert(\r\n          this.interface.actionSpace,\r\n          'actionSpace for device is not implemented',\r\n        );\r\n        const actionSpace = await this.interface.actionSpace();\r\n        debug(\r\n          'actionSpace for this interface is:',\r\n          actionSpace.map((action) => action.name).join(', '),\r\n        );\r\n        assert(Array.isArray(actionSpace), 'actionSpace must be an array');\r\n        if (actionSpace.length === 0) {\r\n          console.warn(\r\n            `ActionSpace for ${this.interface.interfaceType} is empty. This may lead to unexpected behavior.`,\r\n          );\r\n        }\r\n\r\n        const planResult = await (uiTarsModelVersion ? uiTarsPlanning : plan)(\r\n          param.userInstruction,\r\n          {\r\n            context: uiContext,\r\n            actionContext,\r\n            interfaceType: this.interface.interfaceType as InterfaceType,\r\n            actionSpace,\r\n            modelConfig,\r\n            conversationHistory: this.conversationHistory,\r\n          },\r\n        );\r\n        debug('planResult', JSON.stringify(planResult, null, 2));\r\n\r\n        const {\r\n          actions,\r\n          log,\r\n          more_actions_needed_by_instruction,\r\n          error,\r\n          usage,\r\n          rawResponse,\r\n          sleep,\r\n        } = planResult;\r\n\r\n        executorContext.task.log = {\r\n          ...(executorContext.task.log || {}),\r\n          rawResponse,\r\n        };\r\n        executorContext.task.usage = usage;\r\n\r\n        const finalActions = actions || [];\r\n\r\n        if (sleep) {\r\n          const timeNow = Date.now();\r\n          const timeRemaining = sleep - (timeNow - startTime);\r\n          if (timeRemaining > 0) {\r\n            finalActions.push({\r\n              type: 'Sleep',\r\n              param: {\r\n                timeMs: timeRemaining,\r\n              },\r\n              locate: null,\r\n            } as PlanningAction<PlanningActionParamSleep>);\r\n          }\r\n        }\r\n\r\n        if (finalActions.length === 0) {\r\n          assert(\r\n            !more_actions_needed_by_instruction || sleep,\r\n            error ? `Failed to plan: ${error}` : 'No plan found',\r\n          );\r\n        }\r\n\r\n        return {\r\n          output: {\r\n            actions: finalActions,\r\n            more_actions_needed_by_instruction,\r\n            log,\r\n            yamlFlow: planResult.yamlFlow,\r\n          },\r\n          cache: {\r\n            hit: false,\r\n          },\r\n          uiContext,\r\n        };\r\n      },\r\n    };\r\n\r\n    return task;\r\n  }\r\n\r\n  async runPlans(\r\n    title: string,\r\n    plans: PlanningAction[],\r\n    modelConfig: IModelConfig,\r\n  ): Promise<ExecutionResult> {\r\n    const taskExecutor = new Executor(title, {\r\n      onTaskStart: this.onTaskStartCallback,\r\n    });\r\n    const { tasks } = await this.convertPlanToExecutable(plans, modelConfig);\r\n    await taskExecutor.append(tasks);\r\n    const result = await taskExecutor.flush();\r\n    const { output } = result!;\r\n    return {\r\n      output,\r\n      executor: taskExecutor,\r\n    };\r\n  }\r\n\r\n  private getReplanningCycleLimit(isVlmUiTars: boolean) {\r\n    return (\r\n      this.replanningCycleLimit ||\r\n      globalConfigManager.getEnvConfigInNumber(\r\n        SQAI_REPLANNING_CYCLE_LIMIT,\r\n      ) ||\r\n      (isVlmUiTars\r\n        ? defaultVlmUiTarsReplanningCycleLimit\r\n        : defaultReplanningCycleLimit)\r\n    );\r\n  }\r\n\r\n  async action(\r\n    userPrompt: string,\r\n    modelConfig: IModelConfig,\r\n    actionContext?: string,\r\n    cacheable?: boolean,\r\n  ): Promise<\r\n    ExecutionResult<\r\n      | {\r\n          yamlFlow?: MidsceneYamlFlowItem[]; // for cache use\r\n        }\r\n      | undefined\r\n    >\r\n  > {\r\n    this.conversationHistory.reset();\r\n\r\n    const taskExecutor = new Executor(taskTitleStr('Action', userPrompt), {\r\n      onTaskStart: this.onTaskStartCallback,\r\n    });\r\n\r\n    let replanCount = 0;\r\n    const yamlFlow: MidsceneYamlFlowItem[] = [];\r\n    const replanningCycleLimit = this.getReplanningCycleLimit(\r\n      modelConfig.vlMode === 'vlm-ui-tars',\r\n    );\r\n\r\n    // Main planning loop - unified plan/replan logic\r\n    while (true) {\r\n      if (replanCount > replanningCycleLimit) {\r\n        const errorMsg = `Replanning ${replanningCycleLimit} times, which is more than the limit, please split the task into multiple steps`;\r\n\r\n        return this.appendErrorPlan(taskExecutor, errorMsg, modelConfig);\r\n      }\r\n\r\n      // Create planning task (automatically includes execution history if available)\r\n      const planningTask = this.createPlanningTask(\r\n        userPrompt,\r\n        actionContext,\r\n        modelConfig,\r\n      );\r\n\r\n      await taskExecutor.append(planningTask);\r\n      const result = await taskExecutor.flush();\r\n      const planResult: PlanningAIResponse = result?.output;\r\n      if (taskExecutor.isInErrorState()) {\r\n        return {\r\n          output: planResult,\r\n          executor: taskExecutor,\r\n        };\r\n      }\r\n\r\n      // Execute planned actions\r\n      const plans = planResult.actions || [];\r\n      yamlFlow.push(...(planResult.yamlFlow || []));\r\n\r\n      let executables: Awaited<ReturnType<typeof this.convertPlanToExecutable>>;\r\n      try {\r\n        executables = await this.convertPlanToExecutable(\r\n          plans,\r\n          modelConfig,\r\n          cacheable,\r\n        );\r\n        taskExecutor.append(executables.tasks);\r\n      } catch (error) {\r\n        return this.appendErrorPlan(\r\n          taskExecutor,\r\n          `Error converting plans to executable tasks: ${error}, plans: ${JSON.stringify(\r\n            plans,\r\n          )}`,\r\n          modelConfig,\r\n        );\r\n      }\r\n\r\n      await taskExecutor.flush();\r\n      if (taskExecutor.isInErrorState()) {\r\n        return {\r\n          output: undefined,\r\n          executor: taskExecutor,\r\n        };\r\n      }\r\n\r\n      // Check if task is complete\r\n      if (!planResult.more_actions_needed_by_instruction) {\r\n        break;\r\n      }\r\n\r\n      // Increment replan count for next iteration\r\n      replanCount++;\r\n    }\r\n\r\n    return {\r\n      output: {\r\n        yamlFlow,\r\n      },\r\n      executor: taskExecutor,\r\n    };\r\n  }\r\n\r\n  private createTypeQueryTask(\r\n    type: 'Query' | 'Boolean' | 'Number' | 'String' | 'Assert' | 'WaitFor',\r\n    demand: InsightExtractParam,\r\n    modelConfig: IModelConfig,\r\n    opt?: InsightExtractOption,\r\n    multimodalPrompt?: TMultimodalPrompt,\r\n  ) {\r\n    const queryTask: ExecutionTaskInsightQueryApply = {\r\n      type: 'Insight',\r\n      subType: type,\r\n      locate: null,\r\n      param: {\r\n        dataDemand: multimodalPrompt\r\n          ? ({\r\n              demand,\r\n              multimodalPrompt,\r\n            } as never)\r\n          : demand, // for user param presentation in report right sidebar\r\n      },\r\n      executor: async (param, taskContext) => {\r\n        const { task } = taskContext;\r\n        let insightDump: InsightDump | undefined;\r\n        const dumpCollector: DumpSubscriber = (dump) => {\r\n          insightDump = dump;\r\n        };\r\n        this.insight.onceDumpUpdatedFn = dumpCollector;\r\n\r\n        // Get context for query operations\r\n        const shotTime = Date.now();\r\n        const uiContext = await this.insight.contextRetrieverFn('extract');\r\n        task.uiContext = uiContext;\r\n\r\n        const recordItem: ExecutionRecorderItem = {\r\n          type: 'screenshot',\r\n          ts: shotTime,\r\n          screenshot: uiContext.screenshotBase64,\r\n          timing: 'before Extract',\r\n        };\r\n        task.recorder = [recordItem];\r\n\r\n        const ifTypeRestricted = type !== 'Query';\r\n        let demandInput = demand;\r\n        let keyOfResult = 'result';\r\n        if (ifTypeRestricted && (type === 'Assert' || type === 'WaitFor')) {\r\n          keyOfResult = 'StatementIsTruthy';\r\n          const booleanPrompt =\r\n            type === 'Assert'\r\n              ? `Boolean, whether the following statement is true: ${demand}`\r\n              : `Boolean, the user wants to do some 'wait for' operation, please check whether the following statement is true: ${demand}`;\r\n          demandInput = {\r\n            [keyOfResult]: booleanPrompt,\r\n          };\r\n        } else if (ifTypeRestricted) {\r\n          demandInput = {\r\n            [keyOfResult]: `${type}, ${demand}`,\r\n          };\r\n        }\r\n\r\n        const { data, usage, thought } = await this.insight.extract<any>(\r\n          demandInput,\r\n          modelConfig,\r\n          opt,\r\n          multimodalPrompt,\r\n        );\r\n\r\n        let outputResult = data;\r\n        if (ifTypeRestricted) {\r\n          // If AI returned a plain string instead of structured format, use it directly\r\n          if (typeof data === 'string') {\r\n            outputResult = data;\r\n          } else if (type === 'WaitFor') {\r\n            if (data === null || data === undefined) {\r\n              outputResult = false;\r\n            } else {\r\n              outputResult = (data as any)[keyOfResult];\r\n            }\r\n          } else if (data === null || data === undefined) {\r\n            outputResult = null;\r\n          } else {\r\n            assert(\r\n              data?.[keyOfResult] !== undefined,\r\n              'No result in query data',\r\n            );\r\n            outputResult = (data as any)[keyOfResult];\r\n          }\r\n        }\r\n\r\n        if (type === 'Assert' && !outputResult) {\r\n          task.usage = usage;\r\n          task.thought = thought;\r\n          throw new Error(`Assertion failed: ${thought}`);\r\n        }\r\n\r\n        return {\r\n          output: outputResult,\r\n          log: insightDump,\r\n          usage,\r\n          thought,\r\n        };\r\n      },\r\n    };\r\n\r\n    return queryTask;\r\n  }\r\n  async createTypeQueryExecution<T>(\r\n    type: 'Query' | 'Boolean' | 'Number' | 'String' | 'Assert',\r\n    demand: InsightExtractParam,\r\n    modelConfig: IModelConfig,\r\n    opt?: InsightExtractOption,\r\n    multimodalPrompt?: TMultimodalPrompt,\r\n  ): Promise<ExecutionResult<T>> {\r\n    const taskExecutor = new Executor(\r\n      taskTitleStr(\r\n        type,\r\n        typeof demand === 'string' ? demand : JSON.stringify(demand),\r\n      ),\r\n      {\r\n        onTaskStart: this.onTaskStartCallback,\r\n      },\r\n    );\r\n\r\n    const queryTask = await this.createTypeQueryTask(\r\n      type,\r\n      demand,\r\n      modelConfig,\r\n      opt,\r\n      multimodalPrompt,\r\n    );\r\n\r\n    await taskExecutor.append(this.prependExecutorWithScreenshot(queryTask));\r\n    const result = await taskExecutor.flush();\r\n\r\n    if (!result) {\r\n      throw new Error(\r\n        'result of taskExecutor.flush() is undefined in function createTypeQueryTask',\r\n      );\r\n    }\r\n\r\n    const { output, thought } = result;\r\n\r\n    return {\r\n      output,\r\n      thought,\r\n      executor: taskExecutor,\r\n    };\r\n  }\r\n\r\n  private async appendErrorPlan(\r\n    taskExecutor: Executor,\r\n    errorMsg: string,\r\n    modelConfig: IModelConfig,\r\n  ) {\r\n    const errorPlan: PlanningAction<PlanningActionParamError> = {\r\n      type: 'Error',\r\n      param: {\r\n        thought: errorMsg,\r\n      },\r\n      locate: null,\r\n    };\r\n    const { tasks } = await this.convertPlanToExecutable(\r\n      [errorPlan],\r\n      modelConfig,\r\n    );\r\n    await taskExecutor.append(this.prependExecutorWithScreenshot(tasks[0]));\r\n    await taskExecutor.flush();\r\n\r\n    return {\r\n      output: undefined,\r\n      executor: taskExecutor,\r\n    };\r\n  }\r\n\r\n  async taskForSleep(timeMs: number, modelConfig: IModelConfig) {\r\n    const sleepPlan: PlanningAction<PlanningActionParamSleep> = {\r\n      type: 'Sleep',\r\n      param: {\r\n        timeMs,\r\n      },\r\n      locate: null,\r\n    };\r\n    // The convertPlanToExecutable requires modelConfig as a parameter but will not consume it when type is Sleep\r\n    const { tasks: sleepTasks } = await this.convertPlanToExecutable(\r\n      [sleepPlan],\r\n      modelConfig,\r\n    );\r\n\r\n    return this.prependExecutorWithScreenshot(sleepTasks[0]);\r\n  }\r\n\r\n  async waitFor(\r\n    assertion: TUserPrompt,\r\n    opt: PlanningActionParamWaitFor,\r\n    modelConfig: IModelConfig,\r\n  ): Promise<ExecutionResult<void>> {\r\n    const { textPrompt, multimodalPrompt } = parsePrompt(assertion);\r\n\r\n    const description = `waitFor: ${textPrompt}`;\r\n    const taskExecutor = new Executor(taskTitleStr('WaitFor', description), {\r\n      onTaskStart: this.onTaskStartCallback,\r\n    });\r\n    const { timeoutMs, checkIntervalMs } = opt;\r\n\r\n    assert(assertion, 'No assertion for waitFor');\r\n    assert(timeoutMs, 'No timeoutMs for waitFor');\r\n    assert(checkIntervalMs, 'No checkIntervalMs for waitFor');\r\n\r\n    assert(\r\n      checkIntervalMs <= timeoutMs,\r\n      `wrong config for waitFor: checkIntervalMs must be less than timeoutMs, config: {checkIntervalMs: ${checkIntervalMs}, timeoutMs: ${timeoutMs}}`,\r\n    );\r\n\r\n    const overallStartTime = Date.now();\r\n    let startTime = Date.now();\r\n    let errorThought = '';\r\n    while (Date.now() - overallStartTime < timeoutMs) {\r\n      startTime = Date.now();\r\n      const queryTask = await this.createTypeQueryTask(\r\n        'WaitFor',\r\n        textPrompt,\r\n        modelConfig,\r\n        {\r\n          doNotThrowError: true,\r\n        },\r\n        multimodalPrompt,\r\n      );\r\n\r\n      await taskExecutor.append(this.prependExecutorWithScreenshot(queryTask));\r\n      const result = (await taskExecutor.flush()) as\r\n        | {\r\n            output: boolean;\r\n            thought?: string;\r\n          }\r\n        | undefined;\r\n\r\n      if (result?.output) {\r\n        return {\r\n          output: undefined,\r\n          executor: taskExecutor,\r\n        };\r\n      }\r\n\r\n      errorThought =\r\n        result?.thought ||\r\n        (!result && `No result from assertion: ${textPrompt}`) ||\r\n        `unknown error when waiting for assertion: ${textPrompt}`;\r\n      const now = Date.now();\r\n      if (now - startTime < checkIntervalMs) {\r\n        const timeRemaining = checkIntervalMs - (now - startTime);\r\n        const sleepTask = await this.taskForSleep(timeRemaining, modelConfig);\r\n        await taskExecutor.append(sleepTask);\r\n      }\r\n    }\r\n\r\n    return this.appendErrorPlan(\r\n      taskExecutor,\r\n      `waitFor timeout: ${errorThought}`,\r\n      modelConfig,\r\n    );\r\n  }\r\n}\r\n"],"names":["debug","getDebug","defaultReplanningCycleLimit","defaultVlmUiTarsReplanningCycleLimit","locatePlanForLocate","param","locate","locatePlan","TaskExecutor","timing","base64","item","Date","taskApply","appendAfterExecution","taskWithScreenshot","context","args","recorder","task","shot","result","shot2","plans","modelConfig","cacheable","tasks","taskForLocatePlan","plan","detailedLocateParam","onResult","undefined","taskFind","taskContext","_this_taskCache","_locateCacheRecord_cacheContent","assert","JSON","insightDump","usage","dumpCollector","dump","_dump_taskInfo","_dump_taskInfo1","shotTime","uiContext","recordItem","elementFromXpath","userExpectedPathHitFlag","cachePrompt","locateCacheRecord","cacheEntry","elementFromCache","matchElementFromCache","cacheHitFlag","elementFromPlan","matchElementFromPlan","planHitFlag","elementFromAiLocate","aiLocateHitFlag","element","currentCacheEntry","feature","Object","error","Error","hitBy","_plan_locate","_plan_locate1","taskLocate","_plan_param","taskActionError","taskActionFinished","taskActionSleep","taskParam","sleep","planType","actionSpace","action","locateFields","findAllMidsceneLocatorField","requiredLocateFields","field","locateTask","_context_element","Promise","originalError","originalMessage","String","parseActionParam","actionFn","wrappedTasks","index","executorContext","userInstruction","yamlString","taskExecutor","Executor","taskTitleStr","actionContext","startTime","vlMode","uiTarsModelVersion","Array","console","planResult","uiTarsPlanning","actions","log","more_actions_needed_by_instruction","rawResponse","finalActions","timeNow","timeRemaining","title","output","isVlmUiTars","globalConfigManager","SQAI_REPLANNING_CYCLE_LIMIT","userPrompt","replanCount","yamlFlow","replanningCycleLimit","errorMsg","planningTask","executables","type","demand","opt","multimodalPrompt","queryTask","ifTypeRestricted","demandInput","keyOfResult","booleanPrompt","data","thought","outputResult","errorPlan","timeMs","sleepPlan","sleepTasks","assertion","textPrompt","parsePrompt","description","timeoutMs","checkIntervalMs","overallStartTime","errorThought","now","sleepTask","interfaceInstance","insight","opts","ConversationHistory"],"mappings":"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"}