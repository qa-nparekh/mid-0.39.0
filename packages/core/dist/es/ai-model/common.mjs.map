{"version":3,"file":"ai-model\\common.mjs","sources":["webpack://@sqaitech/core/./src/ai-model/common.ts"],"sourcesContent":["import type {\r\n  AIUsageInfo,\r\n  BaseElement,\r\n  DeviceAction,\r\n  ElementTreeNode,\r\n  MidsceneYamlFlowItem,\r\n  PlanningAction,\r\n  Rect,\r\n  Size,\r\n} from '@/types';\r\nimport { assert } from '@sqaitech/shared/utils';\r\n\r\nimport type { ChatCompletionMessageParam } from 'openai/resources/index';\r\n\r\nimport type { PlanningLocateParam } from '@/types';\r\nimport { NodeType } from '@sqaitech/shared/constants';\r\nimport type { TVlModeTypes } from '@sqaitech/shared/env';\r\nimport { treeToList } from '@sqaitech/shared/extractor';\r\nimport { compositeElementInfoImg } from '@sqaitech/shared/img';\r\nimport { getDebug } from '@sqaitech/shared/logger';\r\nimport { z } from 'zod';\r\n\r\nexport type AIArgs = ChatCompletionMessageParam[];\r\n\r\nexport enum AIActionType {\r\n  ASSERT = 0,\r\n  INSPECT_ELEMENT = 1,\r\n  EXTRACT_DATA = 2,\r\n  PLAN = 3,\r\n  DESCRIBE_ELEMENT = 4,\r\n  TEXT = 5,\r\n}\r\n\r\nconst defaultBboxSize = 20; // must be even number\r\nconst debugInspectUtils = getDebug('ai:common');\r\n\r\n// transform the param of locate from qwen mode\r\nexport function fillBboxParam(\r\n  locate: PlanningLocateParam,\r\n  width: number,\r\n  height: number,\r\n  rightLimit: number,\r\n  bottomLimit: number,\r\n  vlMode: TVlModeTypes | undefined,\r\n) {\r\n  // The Qwen model might have hallucinations of naming bbox as bbox_2d.\r\n  if ((locate as any).bbox_2d && !locate?.bbox) {\r\n    locate.bbox = (locate as any).bbox_2d;\r\n    // biome-ignore lint/performance/noDelete: <explanation>\r\n    delete (locate as any).bbox_2d;\r\n  }\r\n\r\n  if (locate?.bbox) {\r\n    locate.bbox = adaptBbox(\r\n      locate.bbox,\r\n      width,\r\n      height,\r\n      rightLimit,\r\n      bottomLimit,\r\n      vlMode,\r\n    );\r\n  }\r\n\r\n  return locate;\r\n}\r\n\r\nexport function adaptQwenBbox(\r\n  bbox: number[],\r\n): [number, number, number, number] {\r\n  if (bbox.length < 2) {\r\n    const msg = `invalid bbox data for qwen-vl mode: ${JSON.stringify(bbox)} `;\r\n    throw new Error(msg);\r\n  }\r\n\r\n  const result: [number, number, number, number] = [\r\n    Math.round(bbox[0]),\r\n    Math.round(bbox[1]),\r\n    typeof bbox[2] === 'number'\r\n      ? Math.round(bbox[2])\r\n      : Math.round(bbox[0] + defaultBboxSize),\r\n    typeof bbox[3] === 'number'\r\n      ? Math.round(bbox[3])\r\n      : Math.round(bbox[1] + defaultBboxSize),\r\n  ];\r\n  return result;\r\n}\r\n\r\nexport function adaptDoubaoBbox(\r\n  bbox: string[] | number[] | string,\r\n  width: number,\r\n  height: number,\r\n): [number, number, number, number] {\r\n  assert(\r\n    width > 0 && height > 0,\r\n    'width and height must be greater than 0 in doubao mode',\r\n  );\r\n\r\n  if (typeof bbox === 'string') {\r\n    assert(\r\n      /^(\\d+)\\s(\\d+)\\s(\\d+)\\s(\\d+)$/.test(bbox.trim()),\r\n      `invalid bbox data string for doubao-vision mode: ${bbox}`,\r\n    );\r\n    const splitted = bbox.split(' ');\r\n    if (splitted.length === 4) {\r\n      return [\r\n        Math.round((Number(splitted[0]) * width) / 1000),\r\n        Math.round((Number(splitted[1]) * height) / 1000),\r\n        Math.round((Number(splitted[2]) * width) / 1000),\r\n        Math.round((Number(splitted[3]) * height) / 1000),\r\n      ];\r\n    }\r\n    throw new Error(`invalid bbox data string for doubao-vision mode: ${bbox}`);\r\n  }\r\n\r\n  if (Array.isArray(bbox) && Array.isArray(bbox[0])) {\r\n    bbox = bbox[0];\r\n  }\r\n\r\n  let bboxList: number[] = [];\r\n  if (Array.isArray(bbox) && typeof bbox[0] === 'string') {\r\n    bbox.forEach((item) => {\r\n      if (typeof item === 'string' && item.includes(',')) {\r\n        const [x, y] = item.split(',');\r\n        bboxList.push(Number(x.trim()), Number(y.trim()));\r\n      } else if (typeof item === 'string' && item.includes(' ')) {\r\n        const [x, y] = item.split(' ');\r\n        bboxList.push(Number(x.trim()), Number(y.trim()));\r\n      } else {\r\n        bboxList.push(Number(item));\r\n      }\r\n    });\r\n  } else {\r\n    bboxList = bbox as any;\r\n  }\r\n\r\n  if (bboxList.length === 4 || bboxList.length === 5) {\r\n    return [\r\n      Math.round((bboxList[0] * width) / 1000),\r\n      Math.round((bboxList[1] * height) / 1000),\r\n      Math.round((bboxList[2] * width) / 1000),\r\n      Math.round((bboxList[3] * height) / 1000),\r\n    ];\r\n  }\r\n\r\n  // treat the bbox as a center point\r\n  if (\r\n    bboxList.length === 6 ||\r\n    bboxList.length === 2 ||\r\n    bboxList.length === 3 ||\r\n    bboxList.length === 7\r\n  ) {\r\n    return [\r\n      Math.max(\r\n        0,\r\n        Math.round((bboxList[0] * width) / 1000) - defaultBboxSize / 2,\r\n      ),\r\n      Math.max(\r\n        0,\r\n        Math.round((bboxList[1] * height) / 1000) - defaultBboxSize / 2,\r\n      ),\r\n      Math.min(\r\n        width,\r\n        Math.round((bboxList[0] * width) / 1000) + defaultBboxSize / 2,\r\n      ),\r\n      Math.min(\r\n        height,\r\n        Math.round((bboxList[1] * height) / 1000) + defaultBboxSize / 2,\r\n      ),\r\n    ];\r\n  }\r\n\r\n  if (bbox.length === 8) {\r\n    return [\r\n      Math.round((bboxList[0] * width) / 1000),\r\n      Math.round((bboxList[1] * height) / 1000),\r\n      Math.round((bboxList[4] * width) / 1000),\r\n      Math.round((bboxList[5] * height) / 1000),\r\n    ];\r\n  }\r\n\r\n  const msg = `invalid bbox data for doubao-vision mode: ${JSON.stringify(bbox)} `;\r\n  throw new Error(msg);\r\n}\r\n\r\nexport function adaptBbox(\r\n  bbox: number[],\r\n  width: number,\r\n  height: number,\r\n  rightLimit: number,\r\n  bottomLimit: number,\r\n  vlMode: TVlModeTypes | undefined,\r\n): [number, number, number, number] {\r\n  let result: [number, number, number, number] = [0, 0, 0, 0];\r\n  if (vlMode === 'doubao-vision' || vlMode === 'vlm-ui-tars') {\r\n    result = adaptDoubaoBbox(bbox, width, height);\r\n  } else if (vlMode === 'gemini') {\r\n    result = adaptGeminiBbox(bbox, width, height);\r\n  } else if (vlMode === 'qwen3-vl') {\r\n    result = normalized01000(bbox, width, height);\r\n  } else {\r\n    result = adaptQwenBbox(bbox);\r\n  }\r\n\r\n  result[2] = Math.min(result[2], rightLimit);\r\n  result[3] = Math.min(result[3], bottomLimit);\r\n\r\n  return result;\r\n}\r\n\r\n// x1, y1, x2, y2 -> 0-1000\r\nexport function normalized01000(\r\n  bbox: number[],\r\n  width: number,\r\n  height: number,\r\n): [number, number, number, number] {\r\n  return [\r\n    Math.round((bbox[0] * width) / 1000),\r\n    Math.round((bbox[1] * height) / 1000),\r\n    Math.round((bbox[2] * width) / 1000),\r\n    Math.round((bbox[3] * height) / 1000),\r\n  ];\r\n}\r\n\r\n// y1, x1, y2, x2 -> 0-1000\r\nexport function adaptGeminiBbox(\r\n  bbox: number[],\r\n  width: number,\r\n  height: number,\r\n): [number, number, number, number] {\r\n  const left = Math.round((bbox[1] * width) / 1000);\r\n  const top = Math.round((bbox[0] * height) / 1000);\r\n  const right = Math.round((bbox[3] * width) / 1000);\r\n  const bottom = Math.round((bbox[2] * height) / 1000);\r\n  return [left, top, right, bottom];\r\n}\r\n\r\nexport function adaptBboxToRect(\r\n  bbox: number[],\r\n  width: number,\r\n  height: number,\r\n  offsetX = 0,\r\n  offsetY = 0,\r\n  rightLimit = width,\r\n  bottomLimit = height,\r\n  vlMode?: TVlModeTypes | undefined,\r\n): Rect {\r\n  debugInspectUtils(\r\n    'adaptBboxToRect',\r\n    bbox,\r\n    width,\r\n    height,\r\n    'offset',\r\n    offsetX,\r\n    offsetY,\r\n    'limit',\r\n    rightLimit,\r\n    bottomLimit,\r\n    'vlMode',\r\n    vlMode,\r\n  );\r\n  const [left, top, right, bottom] = adaptBbox(\r\n    bbox,\r\n    width,\r\n    height,\r\n    rightLimit,\r\n    bottomLimit,\r\n    vlMode,\r\n  );\r\n\r\n  // Calculate initial rect dimensions\r\n  const rectLeft = left;\r\n  const rectTop = top;\r\n  let rectWidth = right - left;\r\n  let rectHeight = bottom - top;\r\n\r\n  // Ensure the rect doesn't exceed image boundaries\r\n  // If right edge exceeds width, adjust the width\r\n  if (rectLeft + rectWidth > width) {\r\n    rectWidth = width - rectLeft;\r\n  }\r\n\r\n  // If bottom edge exceeds height, adjust the height\r\n  if (rectTop + rectHeight > height) {\r\n    rectHeight = height - rectTop;\r\n  }\r\n\r\n  // Ensure minimum dimensions (width and height should be at least 1)\r\n  rectWidth = Math.max(1, rectWidth);\r\n  rectHeight = Math.max(1, rectHeight);\r\n\r\n  const rect = {\r\n    left: rectLeft + offsetX,\r\n    top: rectTop + offsetY,\r\n    width: rectWidth,\r\n    height: rectHeight,\r\n  };\r\n  debugInspectUtils('adaptBboxToRect, result=', rect);\r\n\r\n  return rect;\r\n}\r\n\r\nlet warned = false;\r\nexport function warnGPT4oSizeLimit(size: Size, modelName: string) {\r\n  if (warned) return;\r\n  if (modelName.toLowerCase().includes('gpt-4o')) {\r\n    const warningMsg = `GPT-4o has a maximum image input size of 2000x768 or 768x2000, but got ${size.width}x${size.height}. Please set your interface to a smaller resolution. Otherwise, the result may be inaccurate.`;\r\n\r\n    if (\r\n      Math.max(size.width, size.height) > 2000 ||\r\n      Math.min(size.width, size.height) > 768\r\n    ) {\r\n      console.warn(warningMsg);\r\n      warned = true;\r\n    }\r\n  } else if (size.width > 1800 || size.height > 1800) {\r\n    console.warn(\r\n      `The image size seems too large (${size.width}x${size.height}). It may lead to more token usage, slower response, and inaccurate result.`,\r\n    );\r\n    warned = true;\r\n  }\r\n}\r\n\r\nexport function mergeRects(rects: Rect[]) {\r\n  const minLeft = Math.min(...rects.map((r) => r.left));\r\n  const minTop = Math.min(...rects.map((r) => r.top));\r\n  const maxRight = Math.max(...rects.map((r) => r.left + r.width));\r\n  const maxBottom = Math.max(...rects.map((r) => r.top + r.height));\r\n  return {\r\n    left: minLeft,\r\n    top: minTop,\r\n    width: maxRight - minLeft,\r\n    height: maxBottom - minTop,\r\n  };\r\n}\r\n\r\n// expand the search area to at least 300 x 300, or add a default padding\r\nexport function expandSearchArea(\r\n  rect: Rect,\r\n  screenSize: Size,\r\n  vlMode: TVlModeTypes | undefined,\r\n) {\r\n  const minEdgeSize = vlMode === 'doubao-vision' ? 500 : 300;\r\n  const defaultPadding = 160;\r\n\r\n  // Calculate padding needed to reach minimum edge size\r\n  const paddingSizeHorizontal =\r\n    rect.width < minEdgeSize\r\n      ? Math.ceil((minEdgeSize - rect.width) / 2)\r\n      : defaultPadding;\r\n  const paddingSizeVertical =\r\n    rect.height < minEdgeSize\r\n      ? Math.ceil((minEdgeSize - rect.height) / 2)\r\n      : defaultPadding;\r\n\r\n  // Calculate new dimensions (ensure minimum edge size)\r\n  let newWidth = Math.max(minEdgeSize, rect.width + paddingSizeHorizontal * 2);\r\n  let newHeight = Math.max(minEdgeSize, rect.height + paddingSizeVertical * 2);\r\n\r\n  // Calculate initial position with padding\r\n  let newLeft = rect.left - paddingSizeHorizontal;\r\n  let newTop = rect.top - paddingSizeVertical;\r\n\r\n  // Ensure the rect doesn't exceed screen boundaries by adjusting position\r\n  // If the rect goes beyond the right edge, shift it left\r\n  if (newLeft + newWidth > screenSize.width) {\r\n    newLeft = screenSize.width - newWidth;\r\n  }\r\n\r\n  // If the rect goes beyond the bottom edge, shift it up\r\n  if (newTop + newHeight > screenSize.height) {\r\n    newTop = screenSize.height - newHeight;\r\n  }\r\n\r\n  // Ensure the rect doesn't go beyond the left/top edges\r\n  newLeft = Math.max(0, newLeft);\r\n  newTop = Math.max(0, newTop);\r\n\r\n  // If after position adjustment, the rect still exceeds screen boundaries,\r\n  // clamp the dimensions to fit within screen\r\n  if (newLeft + newWidth > screenSize.width) {\r\n    newWidth = screenSize.width - newLeft;\r\n  }\r\n  if (newTop + newHeight > screenSize.height) {\r\n    newHeight = screenSize.height - newTop;\r\n  }\r\n\r\n  rect.left = newLeft;\r\n  rect.top = newTop;\r\n  rect.width = newWidth;\r\n  rect.height = newHeight;\r\n\r\n  return rect;\r\n}\r\n\r\nexport async function markupImageForLLM(\r\n  screenshotBase64: string,\r\n  tree: ElementTreeNode<BaseElement>,\r\n  size: Size,\r\n) {\r\n  const elementsInfo = treeToList(tree);\r\n  const elementsPositionInfoWithoutText = elementsInfo!.filter(\r\n    (elementInfo) => {\r\n      if (elementInfo.attributes.nodeType === NodeType.TEXT) {\r\n        return false;\r\n      }\r\n      return true;\r\n    },\r\n  );\r\n\r\n  const imagePayload = await compositeElementInfoImg({\r\n    inputImgBase64: screenshotBase64,\r\n    elementsPositionInfo: elementsPositionInfoWithoutText,\r\n    size,\r\n  });\r\n  return imagePayload;\r\n}\r\n\r\nexport function buildYamlFlowFromPlans(\r\n  plans: PlanningAction[],\r\n  actionSpace: DeviceAction<any>[],\r\n  sleep?: number,\r\n): MidsceneYamlFlowItem[] {\r\n  const flow: MidsceneYamlFlowItem[] = [];\r\n\r\n  for (const plan of plans) {\r\n    const verb = plan.type;\r\n\r\n    const action = actionSpace.find((action) => action.name === verb);\r\n    if (!action) {\r\n      console.warn(\r\n        `Cannot convert action ${verb} to yaml flow. Will ignore it.`,\r\n      );\r\n      continue;\r\n    }\r\n\r\n    const flowKey = action.interfaceAlias || verb;\r\n    const flowParam = action.paramSchema\r\n      ? dumpActionParam(plan.param || {}, action.paramSchema)\r\n      : {};\r\n\r\n    const flowItem: MidsceneYamlFlowItem = {\r\n      [flowKey]: '',\r\n      ...flowParam,\r\n    };\r\n\r\n    flow.push(flowItem);\r\n  }\r\n\r\n  if (sleep) {\r\n    flow.push({\r\n      sleep,\r\n    });\r\n  }\r\n\r\n  return flow;\r\n}\r\n\r\n// Zod schemas for shared types\r\nexport const PointSchema = z.object({\r\n  left: z.number(),\r\n  top: z.number(),\r\n});\r\n\r\nexport const SizeSchema = z.object({\r\n  width: z.number(),\r\n  height: z.number(),\r\n  dpr: z.number().optional(),\r\n});\r\n\r\nexport const RectSchema = PointSchema.and(SizeSchema).and(\r\n  z.object({\r\n    zoom: z.number().optional(),\r\n  }),\r\n);\r\n\r\n// Zod schema for TMultimodalPrompt\r\nexport const TMultimodalPromptSchema = z.object({\r\n  images: z\r\n    .array(\r\n      z.object({\r\n        name: z.string(),\r\n        url: z.string(),\r\n      }),\r\n    )\r\n    .optional(),\r\n  convertHttpImage2Base64: z.boolean().optional(),\r\n});\r\n\r\n// Zod schema for TUserPrompt\r\nexport const TUserPromptSchema = z.union([\r\n  z.string(),\r\n  z\r\n    .object({\r\n      prompt: z.string(),\r\n    })\r\n    .and(TMultimodalPromptSchema.partial()),\r\n]);\r\n\r\n// Generate TypeScript types from Zod schemas\r\nexport type TMultimodalPrompt = z.infer<typeof TMultimodalPromptSchema>;\r\nexport type TUserPrompt = z.infer<typeof TUserPromptSchema>;\r\n\r\nconst locateFieldFlagName = 'SQAI_location_field_flag';\r\n\r\n// Schema for locator field input (when users provide locate parameters)\r\nconst MidsceneLocationInput = z\r\n  .object({\r\n    prompt: TUserPromptSchema,\r\n    deepThink: z.boolean().optional(),\r\n    cacheable: z.boolean().optional(),\r\n    xpath: z.union([z.string(), z.boolean()]).optional(),\r\n  })\r\n  .passthrough();\r\n\r\n// Schema for locator field result (when AI returns locate results)\r\nconst MidsceneLocationResult = z\r\n  .object({\r\n    [locateFieldFlagName]: z.literal(true),\r\n    prompt: TUserPromptSchema,\r\n\r\n    // optional fields\r\n    deepThink: z.boolean().optional(), // only available in vl model\r\n    cacheable: z.boolean().optional(),\r\n    xpath: z.boolean().optional(), // preset result for xpath\r\n\r\n    // these two fields will only appear in the result\r\n    center: z.tuple([z.number(), z.number()]),\r\n    rect: RectSchema,\r\n  })\r\n  .passthrough();\r\n\r\n// Export the result type - this is used for runtime results that include center and rect\r\nexport type MidsceneLocationResultType = z.infer<typeof MidsceneLocationResult>;\r\n\r\n// Export the input type - this is the inferred type from getMidsceneLocationSchema()\r\nexport type MidsceneLocationInputType = z.infer<typeof MidsceneLocationInput>;\r\n\r\n/**\r\n * Returns the schema for locator fields.\r\n * This now returns the input schema which is more permissive and suitable for validation.\r\n */\r\nexport const getMidsceneLocationSchema = () => {\r\n  return MidsceneLocationInput;\r\n};\r\n\r\nexport const ifMidsceneLocatorField = (field: any): boolean => {\r\n  // Handle optional fields by getting the inner type\r\n  let actualField = field;\r\n  if (actualField._def?.typeName === 'ZodOptional') {\r\n    actualField = actualField._def.innerType;\r\n  }\r\n\r\n  // Check if this is a ZodObject\r\n  if (actualField._def?.typeName === 'ZodObject') {\r\n    const shape = actualField._def.shape();\r\n\r\n    // Method 1: Check for the location field flag (for result schema)\r\n    if (locateFieldFlagName in shape) {\r\n      return true;\r\n    }\r\n\r\n    // Method 2: Check if it's the input schema by checking for 'prompt' field\r\n    // Input schema has 'prompt' as a required field\r\n    if ('prompt' in shape && shape.prompt) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nexport const dumpMidsceneLocatorField = (field: any): string => {\r\n  assert(\r\n    ifMidsceneLocatorField(field),\r\n    'field is not a midscene locator field',\r\n  );\r\n\r\n  // If field is a string, return it directly\r\n  if (typeof field === 'string') {\r\n    return field;\r\n  }\r\n\r\n  // If field is an object with prompt property\r\n  if (field && typeof field === 'object' && field.prompt) {\r\n    // If prompt is a string, return it directly\r\n    if (typeof field.prompt === 'string') {\r\n      return field.prompt;\r\n    }\r\n    // If prompt is a TUserPrompt object, extract the prompt string\r\n    if (typeof field.prompt === 'object' && field.prompt.prompt) {\r\n      return field.prompt.prompt; // TODO: dump images if necessary\r\n    }\r\n  }\r\n\r\n  // Fallback: try to convert to string\r\n  return String(field);\r\n};\r\n\r\nexport const findAllMidsceneLocatorField = (\r\n  zodType?: z.ZodType<any>,\r\n  requiredOnly?: boolean,\r\n): string[] => {\r\n  if (!zodType) {\r\n    return [];\r\n  }\r\n\r\n  // Check if this is a ZodObject by checking if it has a shape property\r\n  const zodObject = zodType as any;\r\n  if (zodObject._def?.typeName === 'ZodObject' && zodObject.shape) {\r\n    const keys = Object.keys(zodObject.shape);\r\n    return keys.filter((key) => {\r\n      const field = zodObject.shape[key];\r\n      if (!ifMidsceneLocatorField(field)) {\r\n        return false;\r\n      }\r\n\r\n      // If requiredOnly is true, filter out optional fields\r\n      if (requiredOnly) {\r\n        return field._def?.typeName !== 'ZodOptional';\r\n      }\r\n\r\n      return true;\r\n    });\r\n  }\r\n\r\n  // For other ZodType instances, we can't extract field names\r\n  return [];\r\n};\r\n\r\nexport const dumpActionParam = (\r\n  jsonObject: Record<string, any>,\r\n  zodSchema: z.ZodType<any>,\r\n): Record<string, any> => {\r\n  const locatorFields = findAllMidsceneLocatorField(zodSchema);\r\n  const result = { ...jsonObject };\r\n\r\n  for (const fieldName of locatorFields) {\r\n    const fieldValue = result[fieldName];\r\n    if (fieldValue) {\r\n      // If it's already a string, keep it as is\r\n      if (typeof fieldValue === 'string') {\r\n        result[fieldName] = fieldValue;\r\n      } else if (typeof fieldValue === 'object') {\r\n        // Check if this field is actually a MidsceneLocationType object\r\n        if (fieldValue.prompt) {\r\n          // If prompt is a string, use it directly\r\n          if (typeof fieldValue.prompt === 'string') {\r\n            result[fieldName] = fieldValue.prompt;\r\n          } else if (\r\n            typeof fieldValue.prompt === 'object' &&\r\n            fieldValue.prompt.prompt\r\n          ) {\r\n            // If prompt is a TUserPrompt object, extract the prompt string\r\n            result[fieldName] = fieldValue.prompt.prompt;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nexport const loadActionParam = (\r\n  jsonObject: Record<string, any>,\r\n  zodSchema: z.ZodType<any>,\r\n): Record<string, any> => {\r\n  const locatorFields = findAllMidsceneLocatorField(zodSchema);\r\n  const result = { ...jsonObject };\r\n\r\n  for (const fieldName of locatorFields) {\r\n    const fieldValue = result[fieldName];\r\n    if (fieldValue && typeof fieldValue === 'string') {\r\n      result[fieldName] = {\r\n        [locateFieldFlagName]: true,\r\n        prompt: fieldValue,\r\n      };\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Parse and validate action parameters using Zod schema.\r\n * All fields are validated through Zod, EXCEPT locator fields which are skipped.\r\n * Default values defined in the schema are automatically applied.\r\n *\r\n * Locator fields are special business logic fields with complex validation requirements,\r\n * so they are intentionally excluded from Zod parsing and use existing validation logic.\r\n */\r\nexport const parseActionParam = (\r\n  rawParam: Record<string, any>,\r\n  zodSchema: z.ZodType<any>,\r\n): Record<string, any> => {\r\n  // Handle undefined or null rawParam by providing an empty object\r\n  const param = rawParam ?? {};\r\n\r\n  // Find all locate fields in the schema\r\n  const locateFields = findAllMidsceneLocatorField(zodSchema);\r\n\r\n  // If there are no locate fields, just do normal validation\r\n  if (locateFields.length === 0) {\r\n    return zodSchema.parse(param);\r\n  }\r\n\r\n  // Extract locate field values to restore later\r\n  const locateFieldValues: Record<string, any> = {};\r\n  for (const fieldName of locateFields) {\r\n    if (fieldName in param) {\r\n      locateFieldValues[fieldName] = param[fieldName];\r\n    }\r\n  }\r\n\r\n  // Build params for validation - skip locate fields and use dummy values\r\n  const paramsForValidation: Record<string, any> = {};\r\n  for (const key in param) {\r\n    if (locateFields.includes(key)) {\r\n      // Use dummy value to satisfy schema validation\r\n      paramsForValidation[key] = { prompt: '_dummy_' };\r\n    } else {\r\n      paramsForValidation[key] = param[key];\r\n    }\r\n  }\r\n\r\n  // Validate with dummy locate values\r\n  const validated = zodSchema.parse(paramsForValidation);\r\n\r\n  // Restore the actual locate field values (unvalidated, as per business requirement)\r\n  for (const fieldName in locateFieldValues) {\r\n    validated[fieldName] = locateFieldValues[fieldName];\r\n  }\r\n\r\n  return validated;\r\n};\r\n"],"names":["AIActionType","defaultBboxSize","debugInspectUtils","getDebug","fillBboxParam","locate","width","height","rightLimit","bottomLimit","vlMode","adaptBbox","adaptQwenBbox","bbox","msg","JSON","Error","result","Math","adaptDoubaoBbox","assert","splitted","Number","Array","bboxList","item","x","y","adaptGeminiBbox","normalized01000","left","top","right","bottom","adaptBboxToRect","offsetX","offsetY","rectLeft","rectTop","rectWidth","rectHeight","rect","warned","warnGPT4oSizeLimit","size","modelName","warningMsg","console","mergeRects","rects","minLeft","r","minTop","maxRight","maxBottom","expandSearchArea","screenSize","minEdgeSize","defaultPadding","paddingSizeHorizontal","paddingSizeVertical","newWidth","newHeight","newLeft","newTop","markupImageForLLM","screenshotBase64","tree","elementsInfo","treeToList","elementsPositionInfoWithoutText","elementInfo","NodeType","imagePayload","compositeElementInfoImg","buildYamlFlowFromPlans","plans","actionSpace","sleep","flow","plan","verb","action","flowKey","flowParam","dumpActionParam","flowItem","PointSchema","z","SizeSchema","RectSchema","TMultimodalPromptSchema","TUserPromptSchema","locateFieldFlagName","MidsceneLocationInput","getMidsceneLocationSchema","ifMidsceneLocatorField","field","_actualField__def","_actualField__def1","actualField","shape","dumpMidsceneLocatorField","String","findAllMidsceneLocatorField","zodType","requiredOnly","_zodObject__def","zodObject","keys","Object","key","_field__def","jsonObject","zodSchema","locatorFields","fieldName","fieldValue","loadActionParam","parseActionParam","rawParam","param","locateFields","locateFieldValues","paramsForValidation","validated"],"mappings":"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"}