{"version":3,"file":"types.mjs","sources":["webpack://@sqaitech/core/./src/types.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\r\n\r\nimport type { NodeType } from '@sqaitech/shared/constants';\r\nimport type { TModelConfigFn } from '@sqaitech/shared/env';\r\nimport type {\r\n  BaseElement,\r\n  ElementTreeNode,\r\n  Rect,\r\n  Size,\r\n} from '@sqaitech/shared/types';\r\nimport type { z } from 'zod';\r\nimport type { TUserPrompt } from './ai-model/common';\r\nimport type { DetailedLocateParam, MidsceneYamlFlowItem } from './yaml';\r\n\r\nexport type {\r\n  ElementTreeNode,\r\n  BaseElement,\r\n  Rect,\r\n  Size,\r\n  Point,\r\n} from '@sqaitech/shared/types';\r\nexport * from './yaml';\r\n\r\nexport type AIUsageInfo = Record<string, any> & {\r\n  prompt_tokens: number | undefined;\r\n  completion_tokens: number | undefined;\r\n  total_tokens: number | undefined;\r\n  time_cost: number | undefined;\r\n  model_name: string | undefined;\r\n  model_description: string | undefined;\r\n  intent: string | undefined;\r\n};\r\n\r\n/**\r\n * openai\r\n *\r\n */\r\nexport enum AIResponseFormat {\r\n  JSON = 'json_object',\r\n  TEXT = 'text',\r\n}\r\n\r\nexport type AISingleElementResponseById = {\r\n  id: string;\r\n  reason?: string;\r\n  text?: string;\r\n  xpaths?: string[];\r\n};\r\n\r\nexport type AISingleElementResponseByPosition = {\r\n  position?: {\r\n    x: number;\r\n    y: number;\r\n  };\r\n  bbox?: [number, number, number, number];\r\n  reason: string;\r\n  text: string;\r\n};\r\n\r\nexport type AISingleElementResponse = AISingleElementResponseById;\r\nexport interface AIElementLocatorResponse {\r\n  elements: {\r\n    id: string;\r\n    reason?: string;\r\n    text?: string;\r\n    xpaths?: string[];\r\n  }[];\r\n  bbox?: [number, number, number, number];\r\n  isOrderSensitive?: boolean;\r\n  errors?: string[];\r\n}\r\n\r\nexport interface AIElementCoordinatesResponse {\r\n  bbox: [number, number, number, number];\r\n  isOrderSensitive?: boolean;\r\n  errors?: string[];\r\n}\r\n\r\nexport type AIElementResponse =\r\n  | AIElementLocatorResponse\r\n  | AIElementCoordinatesResponse;\r\n\r\nexport interface AIDataExtractionResponse<DataDemand> {\r\n  data: DataDemand;\r\n  errors?: string[];\r\n  thought?: string;\r\n}\r\n\r\nexport interface AISectionLocatorResponse {\r\n  bbox: [number, number, number, number];\r\n  references_bbox?: [number, number, number, number][];\r\n  error?: string;\r\n}\r\n\r\nexport interface AIAssertionResponse {\r\n  pass: boolean;\r\n  thought: string;\r\n}\r\n\r\nexport interface AIDescribeElementResponse {\r\n  description: string;\r\n  error?: string;\r\n}\r\n\r\nexport interface LocatorValidatorOption {\r\n  centerDistanceThreshold?: number;\r\n}\r\n\r\nexport interface LocateValidatorResult {\r\n  pass: boolean;\r\n  rect: Rect;\r\n  center: [number, number];\r\n  centerDistance?: number;\r\n}\r\n\r\nexport interface AgentDescribeElementAtPointResult {\r\n  prompt: string;\r\n  deepThink: boolean;\r\n  verifyResult?: LocateValidatorResult;\r\n}\r\n\r\n/**\r\n * context\r\n */\r\n\r\nexport abstract class UIContext<ElementType extends BaseElement = BaseElement> {\r\n  abstract screenshotBase64: string;\r\n\r\n  abstract tree: ElementTreeNode<ElementType>;\r\n\r\n  abstract size: Size;\r\n\r\n  abstract _isFrozen?: boolean;\r\n}\r\n\r\nexport type EnsureObject<T> = { [K in keyof T]: any };\r\n\r\nexport type InsightAction = 'locate' | 'extract' | 'assert' | 'describe';\r\n\r\nexport type InsightExtractParam = string | Record<string, string>;\r\n\r\nexport type ElementCacheFeature = Record<string, unknown>;\r\n\r\nexport type LocateResultElement = {\r\n  center: [number, number];\r\n  rect: Rect;\r\n  id: string;\r\n  indexId?: number;\r\n  xpaths: string[];\r\n  attributes: {\r\n    nodeType: NodeType;\r\n    [key: string]: string;\r\n  };\r\n  isOrderSensitive?: boolean;\r\n};\r\n\r\nexport interface LocateResult {\r\n  element: LocateResultElement | null;\r\n  rect?: Rect;\r\n}\r\n\r\nexport interface InsightTaskInfo {\r\n  durationMs: number;\r\n  formatResponse?: string;\r\n  rawResponse?: string;\r\n  usage?: AIUsageInfo;\r\n  searchArea?: Rect;\r\n  searchAreaRawResponse?: string;\r\n  searchAreaUsage?: AIUsageInfo;\r\n}\r\n\r\nexport interface DumpMeta {\r\n  logTime: number;\r\n}\r\n\r\nexport interface ReportDumpWithAttributes {\r\n  dumpString: string;\r\n  attributes?: Record<string, any>;\r\n}\r\n\r\nexport interface InsightDump extends DumpMeta {\r\n  type: 'locate' | 'extract' | 'assert';\r\n  logId: string;\r\n  userQuery: {\r\n    element?: TUserPrompt;\r\n    dataDemand?: InsightExtractParam;\r\n    assertion?: TUserPrompt;\r\n  };\r\n  matchedElement: BaseElement[];\r\n  matchedRect?: Rect;\r\n  deepThink?: boolean;\r\n  data: any;\r\n  assertionPass?: boolean;\r\n  assertionThought?: string;\r\n  taskInfo: InsightTaskInfo;\r\n  error?: string;\r\n  output?: any;\r\n}\r\n\r\nexport type PartialInsightDumpFromSDK = Omit<\r\n  InsightDump,\r\n  'logTime' | 'logId' | 'model_name'\r\n>;\r\n\r\nexport type DumpSubscriber = (dump: InsightDump) => Promise<void> | void;\r\n\r\n// intermediate variables to optimize the return value by AI\r\nexport interface LiteUISection {\r\n  name: string;\r\n  description: string;\r\n  sectionCharacteristics: string;\r\n  textIds: string[];\r\n}\r\n\r\nexport type ElementById = (id: string) => BaseElement | null;\r\n\r\nexport type InsightAssertionResponse = AIAssertionResponse & {\r\n  usage?: AIUsageInfo;\r\n};\r\n\r\n/**\r\n * agent\r\n */\r\n\r\nexport type OnTaskStartTip = (tip: string) => Promise<void> | void;\r\n\r\nexport interface AgentWaitForOpt {\r\n  checkIntervalMs?: number;\r\n  timeoutMs?: number;\r\n}\r\n\r\nexport interface AgentAssertOpt {\r\n  keepRawResponse?: boolean;\r\n}\r\n\r\n/**\r\n * planning\r\n *\r\n */\r\n\r\nexport interface PlanningLocateParam extends DetailedLocateParam {\r\n  id?: string;\r\n  bbox?: [number, number, number, number];\r\n}\r\n\r\nexport interface PlanningAction<ParamType = any> {\r\n  thought?: string;\r\n  type: string;\r\n  param: ParamType;\r\n  locate?: PlanningLocateParam | null;\r\n}\r\n\r\nexport interface PlanningAIResponse {\r\n  action?: PlanningAction; // this is the qwen mode\r\n  actions?: PlanningAction[];\r\n  more_actions_needed_by_instruction: boolean;\r\n  log: string;\r\n  sleep?: number;\r\n  error?: string;\r\n  usage?: AIUsageInfo;\r\n  rawResponse?: string;\r\n  yamlFlow?: MidsceneYamlFlowItem[];\r\n  yamlString?: string;\r\n}\r\n\r\nexport type PlanningActionParamTap = null;\r\nexport type PlanningActionParamHover = null;\r\nexport type PlanningActionParamRightClick = null;\r\n\r\nexport interface PlanningActionParamInputOrKeyPress {\r\n  value: string;\r\n  autoDismissKeyboard?: boolean;\r\n}\r\n\r\nexport interface PlanningActionParamSleep {\r\n  timeMs: number;\r\n}\r\n\r\nexport interface PlanningActionParamError {\r\n  thought: string;\r\n}\r\n\r\nexport type PlanningActionParamWaitFor = AgentWaitForOpt & {};\r\n\r\nexport interface AndroidLongPressParam {\r\n  duration?: number;\r\n}\r\n\r\nexport interface AndroidPullParam {\r\n  direction: 'up' | 'down';\r\n  distance?: number;\r\n  duration?: number;\r\n}\r\n/**\r\n * misc\r\n */\r\n\r\nexport interface Color {\r\n  name: string;\r\n  hex: string;\r\n}\r\n\r\nexport interface BaseAgentParserOpt {\r\n  selector?: string;\r\n}\r\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\r\nexport interface PuppeteerParserOpt extends BaseAgentParserOpt {}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\r\nexport interface PlaywrightParserOpt extends BaseAgentParserOpt {}\r\n\r\n/*\r\naction\r\n*/\r\nexport interface ExecutionTaskProgressOptions {\r\n  onTaskStart?: (task: ExecutionTask) => Promise<void> | void;\r\n}\r\n\r\nexport interface ExecutionRecorderItem {\r\n  type: 'screenshot';\r\n  ts: number;\r\n  screenshot?: string;\r\n  timing?: string;\r\n}\r\n\r\nexport type ExecutionTaskType =\r\n  | 'Planning'\r\n  | 'Insight'\r\n  | 'Action'\r\n  | 'Assertion'\r\n  | 'Log';\r\n\r\nexport interface ExecutorContext {\r\n  task: ExecutionTask;\r\n  element?: LocateResultElement | null;\r\n}\r\n\r\nexport interface ExecutionTaskApply<\r\n  Type extends ExecutionTaskType = any,\r\n  TaskParam = any,\r\n  TaskOutput = any,\r\n  TaskLog = any,\r\n> {\r\n  type: Type;\r\n  subType?: string;\r\n  param?: TaskParam;\r\n  thought?: string;\r\n  locate?: PlanningLocateParam | null;\r\n  uiContext?: UIContext;\r\n  executor: (\r\n    param: TaskParam,\r\n    context: ExecutorContext,\r\n  ) => // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\r\n    | Promise<ExecutionTaskReturn<TaskOutput, TaskLog> | undefined | void>\r\n    | undefined\r\n    | void;\r\n}\r\n\r\nexport interface ExecutionTaskHitBy {\r\n  from: string;\r\n  context: Record<string, any>;\r\n}\r\n\r\nexport interface ExecutionTaskReturn<TaskOutput = unknown, TaskLog = unknown> {\r\n  output?: TaskOutput;\r\n  log?: TaskLog;\r\n  recorder?: ExecutionRecorderItem[];\r\n  hitBy?: ExecutionTaskHitBy;\r\n}\r\n\r\nexport type ExecutionTask<\r\n  E extends ExecutionTaskApply<any, any, any> = ExecutionTaskApply<\r\n    any,\r\n    any,\r\n    any\r\n  >,\r\n> = E &\r\n  ExecutionTaskReturn<\r\n    E extends ExecutionTaskApply<any, any, infer TaskOutput, any>\r\n      ? TaskOutput\r\n      : unknown,\r\n    E extends ExecutionTaskApply<any, any, any, infer TaskLog>\r\n      ? TaskLog\r\n      : unknown\r\n  > & {\r\n    status: 'pending' | 'running' | 'finished' | 'failed' | 'cancelled';\r\n    error?: Error;\r\n    errorMessage?: string;\r\n    errorStack?: string;\r\n    timing?: {\r\n      start: number;\r\n      end?: number;\r\n      cost?: number;\r\n    };\r\n    usage?: AIUsageInfo;\r\n    searchAreaUsage?: AIUsageInfo;\r\n  };\r\n\r\nexport interface ExecutionDump extends DumpMeta {\r\n  name: string;\r\n  description?: string;\r\n  tasks: ExecutionTask[];\r\n  aiActionContext?: string;\r\n}\r\n\r\n/*\r\ntask - insight-locate\r\n*/\r\nexport type ExecutionTaskInsightLocateParam = PlanningLocateParam;\r\n\r\nexport interface ExecutionTaskInsightLocateOutput {\r\n  element: LocateResultElement | null;\r\n}\r\n\r\nexport type ExecutionTaskInsightDump = InsightDump;\r\n\r\nexport type ExecutionTaskInsightLocateApply = ExecutionTaskApply<\r\n  'Insight',\r\n  ExecutionTaskInsightLocateParam,\r\n  ExecutionTaskInsightLocateOutput,\r\n  ExecutionTaskInsightDump\r\n>;\r\n\r\nexport type ExecutionTaskInsightLocate =\r\n  ExecutionTask<ExecutionTaskInsightLocateApply>;\r\n\r\n/*\r\ntask - insight-query\r\n*/\r\nexport interface ExecutionTaskInsightQueryParam {\r\n  dataDemand: InsightExtractParam;\r\n}\r\n\r\nexport interface ExecutionTaskInsightQueryOutput {\r\n  data: any;\r\n}\r\n\r\nexport type ExecutionTaskInsightQueryApply = ExecutionTaskApply<\r\n  'Insight',\r\n  ExecutionTaskInsightQueryParam,\r\n  any,\r\n  ExecutionTaskInsightDump\r\n>;\r\n\r\nexport type ExecutionTaskInsightQuery =\r\n  ExecutionTask<ExecutionTaskInsightQueryApply>;\r\n\r\n/*\r\ntask - assertion\r\n*/\r\nexport interface ExecutionTaskInsightAssertionParam {\r\n  assertion: string;\r\n}\r\n\r\nexport type ExecutionTaskInsightAssertionApply = ExecutionTaskApply<\r\n  'Insight',\r\n  ExecutionTaskInsightAssertionParam,\r\n  InsightAssertionResponse,\r\n  ExecutionTaskInsightDump\r\n>;\r\n\r\nexport type ExecutionTaskInsightAssertion =\r\n  ExecutionTask<ExecutionTaskInsightAssertionApply>;\r\n\r\n/*\r\ntask - action (i.e. interact) \r\n*/\r\nexport type ExecutionTaskActionApply<ActionParam = any> = ExecutionTaskApply<\r\n  'Action',\r\n  ActionParam,\r\n  void,\r\n  void\r\n>;\r\n\r\nexport type ExecutionTaskAction = ExecutionTask<ExecutionTaskActionApply>;\r\n\r\n/*\r\ntask - Log\r\n*/\r\n\r\nexport type ExecutionTaskLogApply<\r\n  LogParam = {\r\n    content: string;\r\n  },\r\n> = ExecutionTaskApply<'Log', LogParam, void, void>;\r\n\r\nexport type ExecutionTaskLog = ExecutionTask<ExecutionTaskLogApply>;\r\n\r\n/*\r\ntask - planning\r\n*/\r\n\r\nexport type ExecutionTaskPlanningApply = ExecutionTaskApply<\r\n  'Planning',\r\n  {\r\n    userInstruction: string;\r\n  },\r\n  PlanningAIResponse\r\n>;\r\n\r\nexport type ExecutionTaskPlanning = ExecutionTask<ExecutionTaskPlanningApply>;\r\n\r\n/*\r\nGrouped dump\r\n*/\r\nexport interface GroupedActionDump {\r\n  sdkVersion: string;\r\n  groupName: string;\r\n  groupDescription?: string;\r\n  modelBriefs: string[];\r\n  executions: ExecutionDump[];\r\n}\r\n\r\nexport type InterfaceType =\r\n  | 'puppeteer'\r\n  | 'playwright'\r\n  | 'static'\r\n  | 'chrome-extension-proxy'\r\n  | 'android'\r\n  | string;\r\n\r\nexport interface StreamingCodeGenerationOptions {\r\n  /** Whether to enable streaming output */\r\n  stream?: boolean;\r\n  /** Callback function to handle streaming chunks */\r\n  onChunk?: StreamingCallback;\r\n  /** Callback function to handle streaming completion */\r\n  onComplete?: (finalCode: string) => void;\r\n  /** Callback function to handle streaming errors */\r\n  onError?: (error: Error) => void;\r\n}\r\n\r\nexport type StreamingCallback = (chunk: CodeGenerationChunk) => void;\r\n\r\nexport interface CodeGenerationChunk {\r\n  /** The incremental content chunk */\r\n  content: string;\r\n  /** The reasoning content */\r\n  reasoning_content: string;\r\n  /** The accumulated content so far */\r\n  accumulated: string;\r\n  /** Whether this is the final chunk */\r\n  isComplete: boolean;\r\n  /** Token usage information if available */\r\n  usage?: AIUsageInfo;\r\n}\r\n\r\nexport interface StreamingAIResponse {\r\n  /** The final accumulated content */\r\n  content: string;\r\n  /** Token usage information */\r\n  usage?: AIUsageInfo;\r\n  /** Whether the response was streamed */\r\n  isStreamed: boolean;\r\n}\r\n\r\nexport interface DeviceAction<T = any> {\r\n  name: string;\r\n  description?: string;\r\n  interfaceAlias?: string;\r\n  paramSchema?: z.ZodType<T>;\r\n  call: (param: T, context: ExecutorContext) => Promise<void> | void;\r\n}\r\n\r\n/**\r\n * Web-specific types\r\n */\r\nexport interface WebElementInfo extends BaseElement {\r\n  id: string;\r\n  attributes: {\r\n    nodeType: NodeType;\r\n    [key: string]: string;\r\n  };\r\n}\r\n\r\nexport type WebUIContext = UIContext<WebElementInfo>;\r\n\r\n/**\r\n * Agent\r\n */\r\n\r\nexport type CacheConfig = {\r\n  strategy?: 'read-only' | 'read-write' | 'write-only';\r\n  id: string;\r\n};\r\n\r\nexport type Cache =\r\n  | false // No read, no write\r\n  | true // Will throw error at runtime - deprecated\r\n  | CacheConfig; // Object configuration (requires explicit id)\r\n\r\nexport interface AgentOpt {\r\n  testId?: string;\r\n  // @deprecated\r\n  cacheId?: string; // Keep backward compatibility, but marked as deprecated\r\n  groupName?: string;\r\n  groupDescription?: string;\r\n  /* if auto generate report, default true */\r\n  generateReport?: boolean;\r\n  /* if auto print report msg, default true */\r\n  autoPrintReportMsg?: boolean;\r\n  onTaskStartTip?: OnTaskStartTip;\r\n  aiActionContext?: string;\r\n  /* custom report file name */\r\n  reportFileName?: string;\r\n  modelConfig?: TModelConfigFn;\r\n  cache?: Cache;\r\n  replanningCycleLimit?: number;\r\n}\r\n\r\nexport type TestStatus =\r\n  | 'passed'\r\n  | 'failed'\r\n  | 'timedOut'\r\n  | 'skipped'\r\n  | 'interrupted';\r\n\r\nexport interface ReportFileWithAttributes {\r\n  reportFilePath: string;\r\n  reportAttributes: {\r\n    testDuration: number;\r\n    testStatus: TestStatus;\r\n    testTitle: string;\r\n    testId: string;\r\n    testDescription: string;\r\n  };\r\n}\r\n"],"names":["AIResponseFormat","UIContext"],"mappings":";AAqCO,IAAKA,yBAAgBA,WAAAA,GAAAA,SAAhBA,gBAAgB;;;WAAhBA;;AAwFL,MAAeC;AAQtB"}