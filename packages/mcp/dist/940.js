exports.ids = [
    "940"
];
exports.modules = {
    "../../node_modules/.pnpm/end-of-stream@1.4.4/node_modules/end-of-stream/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        var once = __webpack_require__("../../node_modules/.pnpm/once@1.4.0/node_modules/once/once.js");
        var noop = function() {};
        var isRequest = function(stream) {
            return stream.setHeader && 'function' == typeof stream.abort;
        };
        var isChildProcess = function(stream) {
            return stream.stdio && Array.isArray(stream.stdio) && 3 === stream.stdio.length;
        };
        var eos = function(stream, opts, callback) {
            if ('function' == typeof opts) return eos(stream, null, opts);
            if (!opts) opts = {};
            callback = once(callback || noop);
            var ws = stream._writableState;
            var rs = stream._readableState;
            var readable = opts.readable || false !== opts.readable && stream.readable;
            var writable = opts.writable || false !== opts.writable && stream.writable;
            var cancelled = false;
            var onlegacyfinish = function() {
                if (!stream.writable) onfinish();
            };
            var onfinish = function() {
                writable = false;
                if (!readable) callback.call(stream);
            };
            var onend = function() {
                readable = false;
                if (!writable) callback.call(stream);
            };
            var onexit = function(exitCode) {
                callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
            };
            var onerror = function(err) {
                callback.call(stream, err);
            };
            var onclose = function() {
                process.nextTick(onclosenexttick);
            };
            var onclosenexttick = function() {
                if (cancelled) return;
                if (readable && !(rs && rs.ended && !rs.destroyed)) return callback.call(stream, new Error('premature close'));
                if (writable && !(ws && ws.ended && !ws.destroyed)) return callback.call(stream, new Error('premature close'));
            };
            var onrequest = function() {
                stream.req.on('finish', onfinish);
            };
            if (isRequest(stream)) {
                stream.on('complete', onfinish);
                stream.on('abort', onclose);
                if (stream.req) onrequest();
                else stream.on('request', onrequest);
            } else if (writable && !ws) {
                stream.on('end', onlegacyfinish);
                stream.on('close', onlegacyfinish);
            }
            if (isChildProcess(stream)) stream.on('exit', onexit);
            stream.on('end', onend);
            stream.on('finish', onfinish);
            if (false !== opts.error) stream.on('error', onerror);
            stream.on('close', onclose);
            return function() {
                cancelled = true;
                stream.removeListener('complete', onfinish);
                stream.removeListener('abort', onclose);
                stream.removeListener('request', onrequest);
                if (stream.req) stream.req.removeListener('finish', onfinish);
                stream.removeListener('end', onlegacyfinish);
                stream.removeListener('close', onlegacyfinish);
                stream.removeListener('finish', onfinish);
                stream.removeListener('exit', onexit);
                stream.removeListener('end', onend);
                stream.removeListener('error', onerror);
                stream.removeListener('close', onclose);
            };
        };
        module.exports = eos;
    },
    "../../node_modules/.pnpm/extract-zip@2.0.1/node_modules/extract-zip/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const debug = __webpack_require__("../../node_modules/.pnpm/debug@4.4.0_supports-color@5.5.0/node_modules/debug/src/index.js")('extract-zip');
        const { createWriteStream, promises: fs } = __webpack_require__("fs");
        const getStream = __webpack_require__("../../node_modules/.pnpm/get-stream@5.2.0/node_modules/get-stream/index.js");
        const path = __webpack_require__("path");
        const { promisify } = __webpack_require__("util");
        const stream = __webpack_require__("stream");
        const yauzl = __webpack_require__("../../node_modules/.pnpm/yauzl@2.10.0/node_modules/yauzl/index.js");
        const openZip = promisify(yauzl.open);
        const pipeline = promisify(stream.pipeline);
        class Extractor {
            constructor(zipPath, opts){
                this.zipPath = zipPath;
                this.opts = opts;
            }
            async extract() {
                debug('opening', this.zipPath, 'with opts', this.opts);
                this.zipfile = await openZip(this.zipPath, {
                    lazyEntries: true
                });
                this.canceled = false;
                return new Promise((resolve, reject)=>{
                    this.zipfile.on('error', (err)=>{
                        this.canceled = true;
                        reject(err);
                    });
                    this.zipfile.readEntry();
                    this.zipfile.on('close', ()=>{
                        if (!this.canceled) {
                            debug('zip extraction complete');
                            resolve();
                        }
                    });
                    this.zipfile.on('entry', async (entry)=>{
                        if (this.canceled) return void debug('skipping entry', entry.fileName, {
                            cancelled: this.canceled
                        });
                        debug('zipfile entry', entry.fileName);
                        if (entry.fileName.startsWith('__MACOSX/')) return void this.zipfile.readEntry();
                        const destDir = path.dirname(path.join(this.opts.dir, entry.fileName));
                        try {
                            await fs.mkdir(destDir, {
                                recursive: true
                            });
                            const canonicalDestDir = await fs.realpath(destDir);
                            const relativeDestDir = path.relative(this.opts.dir, canonicalDestDir);
                            if (relativeDestDir.split(path.sep).includes('..')) throw new Error(`Out of bound path "${canonicalDestDir}" found while processing file ${entry.fileName}`);
                            await this.extractEntry(entry);
                            debug('finished processing', entry.fileName);
                            this.zipfile.readEntry();
                        } catch (err) {
                            this.canceled = true;
                            this.zipfile.close();
                            reject(err);
                        }
                    });
                });
            }
            async extractEntry(entry) {
                if (this.canceled) return void debug('skipping entry extraction', entry.fileName, {
                    cancelled: this.canceled
                });
                if (this.opts.onEntry) this.opts.onEntry(entry, this.zipfile);
                const dest = path.join(this.opts.dir, entry.fileName);
                const mode = entry.externalFileAttributes >> 16 & 0xFFFF;
                const IFMT = 61440;
                const IFDIR = 16384;
                const IFLNK = 40960;
                const symlink = (mode & IFMT) === IFLNK;
                let isDir = (mode & IFMT) === IFDIR;
                if (!isDir && entry.fileName.endsWith('/')) isDir = true;
                const madeBy = entry.versionMadeBy >> 8;
                if (!isDir) isDir = 0 === madeBy && 16 === entry.externalFileAttributes;
                debug('extracting entry', {
                    filename: entry.fileName,
                    isDir: isDir,
                    isSymlink: symlink
                });
                const procMode = 511 & this.getExtractedMode(mode, isDir);
                const destDir = isDir ? dest : path.dirname(dest);
                const mkdirOptions = {
                    recursive: true
                };
                if (isDir) mkdirOptions.mode = procMode;
                debug('mkdir', {
                    dir: destDir,
                    ...mkdirOptions
                });
                await fs.mkdir(destDir, mkdirOptions);
                if (isDir) return;
                debug('opening read stream', dest);
                const readStream = await promisify(this.zipfile.openReadStream.bind(this.zipfile))(entry);
                if (symlink) {
                    const link = await getStream(readStream);
                    debug('creating symlink', link, dest);
                    await fs.symlink(link, dest);
                } else await pipeline(readStream, createWriteStream(dest, {
                    mode: procMode
                }));
            }
            getExtractedMode(entryMode, isDir) {
                let mode = entryMode;
                if (0 === mode) if (isDir) {
                    if (this.opts.defaultDirMode) mode = parseInt(this.opts.defaultDirMode, 10);
                    if (!mode) mode = 493;
                } else {
                    if (this.opts.defaultFileMode) mode = parseInt(this.opts.defaultFileMode, 10);
                    if (!mode) mode = 420;
                }
                return mode;
            }
        }
        module.exports = async function(zipPath, opts) {
            debug('creating target directory', opts.dir);
            if (!path.isAbsolute(opts.dir)) throw new Error('Target directory is expected to be absolute');
            await fs.mkdir(opts.dir, {
                recursive: true
            });
            opts.dir = await fs.realpath(opts.dir);
            return new Extractor(zipPath, opts).extract();
        };
    },
    "../../node_modules/.pnpm/fd-slicer@1.1.0/node_modules/fd-slicer/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        var fs = __webpack_require__("fs");
        var util = __webpack_require__("util");
        var stream = __webpack_require__("stream");
        var Readable = stream.Readable;
        var Writable = stream.Writable;
        var PassThrough = stream.PassThrough;
        var Pend = __webpack_require__("../../node_modules/.pnpm/pend@1.2.0/node_modules/pend/index.js");
        var EventEmitter = __webpack_require__("events").EventEmitter;
        exports1.createFromBuffer = createFromBuffer;
        exports1.createFromFd = createFromFd;
        exports1.BufferSlicer = BufferSlicer;
        exports1.FdSlicer = FdSlicer;
        util.inherits(FdSlicer, EventEmitter);
        function FdSlicer(fd, options) {
            options = options || {};
            EventEmitter.call(this);
            this.fd = fd;
            this.pend = new Pend();
            this.pend.max = 1;
            this.refCount = 0;
            this.autoClose = !!options.autoClose;
        }
        FdSlicer.prototype.read = function(buffer, offset, length, position, callback) {
            var self = this;
            self.pend.go(function(cb) {
                fs.read(self.fd, buffer, offset, length, position, function(err, bytesRead, buffer) {
                    cb();
                    callback(err, bytesRead, buffer);
                });
            });
        };
        FdSlicer.prototype.write = function(buffer, offset, length, position, callback) {
            var self = this;
            self.pend.go(function(cb) {
                fs.write(self.fd, buffer, offset, length, position, function(err, written, buffer) {
                    cb();
                    callback(err, written, buffer);
                });
            });
        };
        FdSlicer.prototype.createReadStream = function(options) {
            return new ReadStream(this, options);
        };
        FdSlicer.prototype.createWriteStream = function(options) {
            return new WriteStream(this, options);
        };
        FdSlicer.prototype.ref = function() {
            this.refCount += 1;
        };
        FdSlicer.prototype.unref = function() {
            var self = this;
            self.refCount -= 1;
            if (self.refCount > 0) return;
            if (self.refCount < 0) throw new Error("invalid unref");
            if (self.autoClose) fs.close(self.fd, onCloseDone);
            function onCloseDone(err) {
                if (err) self.emit('error', err);
                else self.emit('close');
            }
        };
        util.inherits(ReadStream, Readable);
        function ReadStream(context, options) {
            options = options || {};
            Readable.call(this, options);
            this.context = context;
            this.context.ref();
            this.start = options.start || 0;
            this.endOffset = options.end;
            this.pos = this.start;
            this.destroyed = false;
        }
        ReadStream.prototype._read = function(n) {
            var self = this;
            if (self.destroyed) return;
            var toRead = Math.min(self._readableState.highWaterMark, n);
            if (null != self.endOffset) toRead = Math.min(toRead, self.endOffset - self.pos);
            if (toRead <= 0) {
                self.destroyed = true;
                self.push(null);
                self.context.unref();
                return;
            }
            self.context.pend.go(function(cb) {
                if (self.destroyed) return cb();
                var buffer = new Buffer(toRead);
                fs.read(self.context.fd, buffer, 0, toRead, self.pos, function(err, bytesRead) {
                    if (err) self.destroy(err);
                    else if (0 === bytesRead) {
                        self.destroyed = true;
                        self.push(null);
                        self.context.unref();
                    } else {
                        self.pos += bytesRead;
                        self.push(buffer.slice(0, bytesRead));
                    }
                    cb();
                });
            });
        };
        ReadStream.prototype.destroy = function(err) {
            if (this.destroyed) return;
            err = err || new Error("stream destroyed");
            this.destroyed = true;
            this.emit('error', err);
            this.context.unref();
        };
        util.inherits(WriteStream, Writable);
        function WriteStream(context, options) {
            options = options || {};
            Writable.call(this, options);
            this.context = context;
            this.context.ref();
            this.start = options.start || 0;
            this.endOffset = null == options.end ? 1 / 0 : +options.end;
            this.bytesWritten = 0;
            this.pos = this.start;
            this.destroyed = false;
            this.on('finish', this.destroy.bind(this));
        }
        WriteStream.prototype._write = function(buffer, encoding, callback) {
            var self = this;
            if (self.destroyed) return;
            if (self.pos + buffer.length > self.endOffset) {
                var err = new Error("maximum file length exceeded");
                err.code = 'ETOOBIG';
                self.destroy();
                callback(err);
                return;
            }
            self.context.pend.go(function(cb) {
                if (self.destroyed) return cb();
                fs.write(self.context.fd, buffer, 0, buffer.length, self.pos, function(err, bytes) {
                    if (err) {
                        self.destroy();
                        cb();
                        callback(err);
                    } else {
                        self.bytesWritten += bytes;
                        self.pos += bytes;
                        self.emit('progress');
                        cb();
                        callback();
                    }
                });
            });
        };
        WriteStream.prototype.destroy = function() {
            if (this.destroyed) return;
            this.destroyed = true;
            this.context.unref();
        };
        util.inherits(BufferSlicer, EventEmitter);
        function BufferSlicer(buffer, options) {
            EventEmitter.call(this);
            options = options || {};
            this.refCount = 0;
            this.buffer = buffer;
            this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;
        }
        BufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {
            var end = position + length;
            var delta = end - this.buffer.length;
            var written = delta > 0 ? delta : length;
            this.buffer.copy(buffer, offset, position, end);
            setImmediate(function() {
                callback(null, written);
            });
        };
        BufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {
            buffer.copy(this.buffer, position, offset, offset + length);
            setImmediate(function() {
                callback(null, length, buffer);
            });
        };
        BufferSlicer.prototype.createReadStream = function(options) {
            options = options || {};
            var readStream = new PassThrough(options);
            readStream.destroyed = false;
            readStream.start = options.start || 0;
            readStream.endOffset = options.end;
            readStream.pos = readStream.endOffset || this.buffer.length;
            var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
            var offset = 0;
            while(true){
                var nextOffset = offset + this.maxChunkSize;
                if (nextOffset >= entireSlice.length) {
                    if (offset < entireSlice.length) readStream.write(entireSlice.slice(offset, entireSlice.length));
                    break;
                }
                readStream.write(entireSlice.slice(offset, nextOffset));
                offset = nextOffset;
            }
            readStream.end();
            readStream.destroy = function() {
                readStream.destroyed = true;
            };
            return readStream;
        };
        BufferSlicer.prototype.createWriteStream = function(options) {
            var bufferSlicer = this;
            options = options || {};
            var writeStream = new Writable(options);
            writeStream.start = options.start || 0;
            writeStream.endOffset = null == options.end ? this.buffer.length : +options.end;
            writeStream.bytesWritten = 0;
            writeStream.pos = writeStream.start;
            writeStream.destroyed = false;
            writeStream._write = function(buffer, encoding, callback) {
                if (writeStream.destroyed) return;
                var end = writeStream.pos + buffer.length;
                if (end > writeStream.endOffset) {
                    var err = new Error("maximum file length exceeded");
                    err.code = 'ETOOBIG';
                    writeStream.destroyed = true;
                    callback(err);
                    return;
                }
                buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);
                writeStream.bytesWritten += buffer.length;
                writeStream.pos = end;
                writeStream.emit('progress');
                callback();
            };
            writeStream.destroy = function() {
                writeStream.destroyed = true;
            };
            return writeStream;
        };
        BufferSlicer.prototype.ref = function() {
            this.refCount += 1;
        };
        BufferSlicer.prototype.unref = function() {
            this.refCount -= 1;
            if (this.refCount < 0) throw new Error("invalid unref");
        };
        function createFromBuffer(buffer, options) {
            return new BufferSlicer(buffer, options);
        }
        function createFromFd(fd, options) {
            return new FdSlicer(fd, options);
        }
    },
    "../../node_modules/.pnpm/get-stream@5.2.0/node_modules/get-stream/buffer-stream.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const { PassThrough: PassThroughStream } = __webpack_require__("stream");
        module.exports = (options)=>{
            options = {
                ...options
            };
            const { array } = options;
            let { encoding } = options;
            const isBuffer = 'buffer' === encoding;
            let objectMode = false;
            if (array) objectMode = !(encoding || isBuffer);
            else encoding = encoding || 'utf8';
            if (isBuffer) encoding = null;
            const stream = new PassThroughStream({
                objectMode
            });
            if (encoding) stream.setEncoding(encoding);
            let length = 0;
            const chunks = [];
            stream.on('data', (chunk)=>{
                chunks.push(chunk);
                if (objectMode) length = chunks.length;
                else length += chunk.length;
            });
            stream.getBufferedValue = ()=>{
                if (array) return chunks;
                return isBuffer ? Buffer.concat(chunks, length) : chunks.join('');
            };
            stream.getBufferedLength = ()=>length;
            return stream;
        };
    },
    "../../node_modules/.pnpm/get-stream@5.2.0/node_modules/get-stream/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const { constants: BufferConstants } = __webpack_require__("buffer");
        const pump = __webpack_require__("../../node_modules/.pnpm/pump@3.0.2/node_modules/pump/index.js");
        const bufferStream = __webpack_require__("../../node_modules/.pnpm/get-stream@5.2.0/node_modules/get-stream/buffer-stream.js");
        class MaxBufferError extends Error {
            constructor(){
                super('maxBuffer exceeded');
                this.name = 'MaxBufferError';
            }
        }
        async function getStream(inputStream, options) {
            if (!inputStream) return Promise.reject(new Error('Expected a stream'));
            options = {
                maxBuffer: 1 / 0,
                ...options
            };
            const { maxBuffer } = options;
            let stream;
            await new Promise((resolve, reject)=>{
                const rejectPromise = (error)=>{
                    if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) error.bufferedData = stream.getBufferedValue();
                    reject(error);
                };
                stream = pump(inputStream, bufferStream(options), (error)=>{
                    if (error) return void rejectPromise(error);
                    resolve();
                });
                stream.on('data', ()=>{
                    if (stream.getBufferedLength() > maxBuffer) rejectPromise(new MaxBufferError());
                });
            });
            return stream.getBufferedValue();
        }
        module.exports = getStream;
        module.exports["default"] = getStream;
        module.exports.buffer = (stream, options)=>getStream(stream, {
                ...options,
                encoding: 'buffer'
            });
        module.exports.array = (stream, options)=>getStream(stream, {
                ...options,
                array: true
            });
        module.exports.MaxBufferError = MaxBufferError;
    },
    "../../node_modules/.pnpm/pump@3.0.2/node_modules/pump/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        var once = __webpack_require__("../../node_modules/.pnpm/once@1.4.0/node_modules/once/once.js");
        var eos = __webpack_require__("../../node_modules/.pnpm/end-of-stream@1.4.4/node_modules/end-of-stream/index.js");
        var fs;
        try {
            fs = __webpack_require__("fs");
        } catch (e) {}
        var noop = function() {};
        var ancient = /^v?\.0/.test(process.version);
        var isFn = function(fn) {
            return 'function' == typeof fn;
        };
        var isFS = function(stream) {
            if (!ancient) return false;
            if (!fs) return false;
            return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close);
        };
        var isRequest = function(stream) {
            return stream.setHeader && isFn(stream.abort);
        };
        var destroyer = function(stream, reading, writing, callback) {
            callback = once(callback);
            var closed = false;
            stream.on('close', function() {
                closed = true;
            });
            eos(stream, {
                readable: reading,
                writable: writing
            }, function(err) {
                if (err) return callback(err);
                closed = true;
                callback();
            });
            var destroyed = false;
            return function(err) {
                if (closed) return;
                if (destroyed) return;
                destroyed = true;
                if (isFS(stream)) return stream.close(noop);
                if (isRequest(stream)) return stream.abort();
                if (isFn(stream.destroy)) return stream.destroy();
                callback(err || new Error('stream was destroyed'));
            };
        };
        var call = function(fn) {
            fn();
        };
        var pipe = function(from, to) {
            return from.pipe(to);
        };
        var pump = function() {
            var streams = Array.prototype.slice.call(arguments);
            var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop;
            if (Array.isArray(streams[0])) streams = streams[0];
            if (streams.length < 2) throw new Error('pump requires two streams per minimum');
            var error;
            var destroys = streams.map(function(stream, i) {
                var reading = i < streams.length - 1;
                var writing = i > 0;
                return destroyer(stream, reading, writing, function(err) {
                    if (!error) error = err;
                    if (err) destroys.forEach(call);
                    if (reading) return;
                    destroys.forEach(call);
                    callback(error);
                });
            });
            return streams.reduce(pipe);
        };
        module.exports = pump;
    },
    "../../node_modules/.pnpm/yauzl@2.10.0/node_modules/yauzl/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        var fs = __webpack_require__("fs");
        var zlib = __webpack_require__("zlib");
        var fd_slicer = __webpack_require__("../../node_modules/.pnpm/fd-slicer@1.1.0/node_modules/fd-slicer/index.js");
        var crc32 = __webpack_require__("../../node_modules/.pnpm/buffer-crc32@0.2.13/node_modules/buffer-crc32/index.js");
        var util = __webpack_require__("util");
        var EventEmitter = __webpack_require__("events").EventEmitter;
        var Transform = __webpack_require__("stream").Transform;
        var PassThrough = __webpack_require__("stream").PassThrough;
        var Writable = __webpack_require__("stream").Writable;
        exports1.open = open;
        exports1.fromFd = fromFd;
        exports1.fromBuffer = fromBuffer;
        exports1.fromRandomAccessReader = fromRandomAccessReader;
        exports1.dosDateTimeToDate = dosDateTimeToDate;
        exports1.validateFileName = validateFileName;
        exports1.ZipFile = ZipFile;
        exports1.Entry = Entry;
        exports1.RandomAccessReader = RandomAccessReader;
        function open(path, options, callback) {
            if ("function" == typeof options) {
                callback = options;
                options = null;
            }
            if (null == options) options = {};
            if (null == options.autoClose) options.autoClose = true;
            if (null == options.lazyEntries) options.lazyEntries = false;
            if (null == options.decodeStrings) options.decodeStrings = true;
            if (null == options.validateEntrySizes) options.validateEntrySizes = true;
            if (null == options.strictFileNames) options.strictFileNames = false;
            if (null == callback) callback = defaultCallback;
            fs.open(path, "r", function(err, fd) {
                if (err) return callback(err);
                fromFd(fd, options, function(err, zipfile) {
                    if (err) fs.close(fd, defaultCallback);
                    callback(err, zipfile);
                });
            });
        }
        function fromFd(fd, options, callback) {
            if ("function" == typeof options) {
                callback = options;
                options = null;
            }
            if (null == options) options = {};
            if (null == options.autoClose) options.autoClose = false;
            if (null == options.lazyEntries) options.lazyEntries = false;
            if (null == options.decodeStrings) options.decodeStrings = true;
            if (null == options.validateEntrySizes) options.validateEntrySizes = true;
            if (null == options.strictFileNames) options.strictFileNames = false;
            if (null == callback) callback = defaultCallback;
            fs.fstat(fd, function(err, stats) {
                if (err) return callback(err);
                var reader = fd_slicer.createFromFd(fd, {
                    autoClose: true
                });
                fromRandomAccessReader(reader, stats.size, options, callback);
            });
        }
        function fromBuffer(buffer, options, callback) {
            if ("function" == typeof options) {
                callback = options;
                options = null;
            }
            if (null == options) options = {};
            options.autoClose = false;
            if (null == options.lazyEntries) options.lazyEntries = false;
            if (null == options.decodeStrings) options.decodeStrings = true;
            if (null == options.validateEntrySizes) options.validateEntrySizes = true;
            if (null == options.strictFileNames) options.strictFileNames = false;
            var reader = fd_slicer.createFromBuffer(buffer, {
                maxChunkSize: 0x10000
            });
            fromRandomAccessReader(reader, buffer.length, options, callback);
        }
        function fromRandomAccessReader(reader, totalSize, options, callback) {
            if ("function" == typeof options) {
                callback = options;
                options = null;
            }
            if (null == options) options = {};
            if (null == options.autoClose) options.autoClose = true;
            if (null == options.lazyEntries) options.lazyEntries = false;
            if (null == options.decodeStrings) options.decodeStrings = true;
            var decodeStrings = !!options.decodeStrings;
            if (null == options.validateEntrySizes) options.validateEntrySizes = true;
            if (null == options.strictFileNames) options.strictFileNames = false;
            if (null == callback) callback = defaultCallback;
            if ("number" != typeof totalSize) throw new Error("expected totalSize parameter to be a number");
            if (totalSize > Number.MAX_SAFE_INTEGER) throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
            reader.ref();
            var eocdrWithoutCommentSize = 22;
            var maxCommentSize = 0xffff;
            var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);
            var buffer = newBuffer(bufferSize);
            var bufferReadStart = totalSize - buffer.length;
            readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {
                if (err) return callback(err);
                for(var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1)if (0x06054b50 === buffer.readUInt32LE(i)) {
                    var eocdrBuffer = buffer.slice(i);
                    var diskNumber = eocdrBuffer.readUInt16LE(4);
                    if (0 !== diskNumber) return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
                    var entryCount = eocdrBuffer.readUInt16LE(10);
                    var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
                    var commentLength = eocdrBuffer.readUInt16LE(20);
                    var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;
                    if (commentLength !== expectedCommentLength) return callback(new Error("invalid comment length. expected: " + expectedCommentLength + ". found: " + commentLength));
                    var comment = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false) : eocdrBuffer.slice(22);
                    if (!(0xffff === entryCount || 0xffffffff === centralDirectoryOffset)) return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
                    var zip64EocdlBuffer = newBuffer(20);
                    var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;
                    readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err) {
                        if (err) return callback(err);
                        if (0x07064b50 !== zip64EocdlBuffer.readUInt32LE(0)) return callback(new Error("invalid zip64 end of central directory locator signature"));
                        var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);
                        var zip64EocdrBuffer = newBuffer(56);
                        readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err) {
                            if (err) return callback(err);
                            if (0x06064b50 !== zip64EocdrBuffer.readUInt32LE(0)) return callback(new Error("invalid zip64 end of central directory record signature"));
                            entryCount = readUInt64LE(zip64EocdrBuffer, 32);
                            centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);
                            return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
                        });
                    });
                    return;
                }
                callback(new Error("end of central directory record signature not found"));
            });
        }
        util.inherits(ZipFile, EventEmitter);
        function ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {
            var self = this;
            EventEmitter.call(self);
            self.reader = reader;
            self.reader.on("error", function(err) {
                emitError(self, err);
            });
            self.reader.once("close", function() {
                self.emit("close");
            });
            self.readEntryCursor = centralDirectoryOffset;
            self.fileSize = fileSize;
            self.entryCount = entryCount;
            self.comment = comment;
            self.entriesRead = 0;
            self.autoClose = !!autoClose;
            self.lazyEntries = !!lazyEntries;
            self.decodeStrings = !!decodeStrings;
            self.validateEntrySizes = !!validateEntrySizes;
            self.strictFileNames = !!strictFileNames;
            self.isOpen = true;
            self.emittedError = false;
            if (!self.lazyEntries) self._readEntry();
        }
        ZipFile.prototype.close = function() {
            if (!this.isOpen) return;
            this.isOpen = false;
            this.reader.unref();
        };
        function emitErrorAndAutoClose(self, err) {
            if (self.autoClose) self.close();
            emitError(self, err);
        }
        function emitError(self, err) {
            if (self.emittedError) return;
            self.emittedError = true;
            self.emit("error", err);
        }
        ZipFile.prototype.readEntry = function() {
            if (!this.lazyEntries) throw new Error("readEntry() called without lazyEntries:true");
            this._readEntry();
        };
        ZipFile.prototype._readEntry = function() {
            var self = this;
            if (self.entryCount === self.entriesRead) return void setImmediate(function() {
                if (self.autoClose) self.close();
                if (self.emittedError) return;
                self.emit("end");
            });
            if (self.emittedError) return;
            var buffer = newBuffer(46);
            readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {
                if (err) return emitErrorAndAutoClose(self, err);
                if (self.emittedError) return;
                var entry = new Entry();
                var signature = buffer.readUInt32LE(0);
                if (0x02014b50 !== signature) return emitErrorAndAutoClose(self, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
                entry.versionMadeBy = buffer.readUInt16LE(4);
                entry.versionNeededToExtract = buffer.readUInt16LE(6);
                entry.generalPurposeBitFlag = buffer.readUInt16LE(8);
                entry.compressionMethod = buffer.readUInt16LE(10);
                entry.lastModFileTime = buffer.readUInt16LE(12);
                entry.lastModFileDate = buffer.readUInt16LE(14);
                entry.crc32 = buffer.readUInt32LE(16);
                entry.compressedSize = buffer.readUInt32LE(20);
                entry.uncompressedSize = buffer.readUInt32LE(24);
                entry.fileNameLength = buffer.readUInt16LE(28);
                entry.extraFieldLength = buffer.readUInt16LE(30);
                entry.fileCommentLength = buffer.readUInt16LE(32);
                entry.internalFileAttributes = buffer.readUInt16LE(36);
                entry.externalFileAttributes = buffer.readUInt32LE(38);
                entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);
                if (0x40 & entry.generalPurposeBitFlag) return emitErrorAndAutoClose(self, new Error("strong encryption is not supported"));
                self.readEntryCursor += 46;
                buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
                readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {
                    if (err) return emitErrorAndAutoClose(self, err);
                    if (self.emittedError) return;
                    var isUtf8 = (0x800 & entry.generalPurposeBitFlag) !== 0;
                    entry.fileName = self.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8) : buffer.slice(0, entry.fileNameLength);
                    var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
                    var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);
                    entry.extraFields = [];
                    var i = 0;
                    while(i < extraFieldBuffer.length - 3){
                        var headerId = extraFieldBuffer.readUInt16LE(i + 0);
                        var dataSize = extraFieldBuffer.readUInt16LE(i + 2);
                        var dataStart = i + 4;
                        var dataEnd = dataStart + dataSize;
                        if (dataEnd > extraFieldBuffer.length) return emitErrorAndAutoClose(self, new Error("extra field length exceeds extra field buffer size"));
                        var dataBuffer = newBuffer(dataSize);
                        extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);
                        entry.extraFields.push({
                            id: headerId,
                            data: dataBuffer
                        });
                        i = dataEnd;
                    }
                    entry.fileComment = self.decodeStrings ? decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8) : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);
                    entry.comment = entry.fileComment;
                    self.readEntryCursor += buffer.length;
                    self.entriesRead += 1;
                    if (0xffffffff === entry.uncompressedSize || 0xffffffff === entry.compressedSize || 0xffffffff === entry.relativeOffsetOfLocalHeader) {
                        var zip64EiefBuffer = null;
                        for(var i = 0; i < entry.extraFields.length; i++){
                            var extraField = entry.extraFields[i];
                            if (0x0001 === extraField.id) {
                                zip64EiefBuffer = extraField.data;
                                break;
                            }
                        }
                        if (null == zip64EiefBuffer) return emitErrorAndAutoClose(self, new Error("expected zip64 extended information extra field"));
                        var index = 0;
                        if (0xffffffff === entry.uncompressedSize) {
                            if (index + 8 > zip64EiefBuffer.length) return emitErrorAndAutoClose(self, new Error("zip64 extended information extra field does not include uncompressed size"));
                            entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);
                            index += 8;
                        }
                        if (0xffffffff === entry.compressedSize) {
                            if (index + 8 > zip64EiefBuffer.length) return emitErrorAndAutoClose(self, new Error("zip64 extended information extra field does not include compressed size"));
                            entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);
                            index += 8;
                        }
                        if (0xffffffff === entry.relativeOffsetOfLocalHeader) {
                            if (index + 8 > zip64EiefBuffer.length) return emitErrorAndAutoClose(self, new Error("zip64 extended information extra field does not include relative header offset"));
                            entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);
                            index += 8;
                        }
                    }
                    if (self.decodeStrings) for(var i = 0; i < entry.extraFields.length; i++){
                        var extraField = entry.extraFields[i];
                        if (0x7075 === extraField.id) {
                            if (extraField.data.length < 6) continue;
                            if (1 !== extraField.data.readUInt8(0)) continue;
                            var oldNameCrc32 = extraField.data.readUInt32LE(1);
                            if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) continue;
                            entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);
                            break;
                        }
                    }
                    if (self.validateEntrySizes && 0 === entry.compressionMethod) {
                        var expectedCompressedSize = entry.uncompressedSize;
                        if (entry.isEncrypted()) expectedCompressedSize += 12;
                        if (entry.compressedSize !== expectedCompressedSize) {
                            var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
                            return emitErrorAndAutoClose(self, new Error(msg));
                        }
                    }
                    if (self.decodeStrings) {
                        if (!self.strictFileNames) entry.fileName = entry.fileName.replace(/\\/g, "/");
                        var errorMessage = validateFileName(entry.fileName, self.validateFileNameOptions);
                        if (null != errorMessage) return emitErrorAndAutoClose(self, new Error(errorMessage));
                    }
                    self.emit("entry", entry);
                    if (!self.lazyEntries) self._readEntry();
                });
            });
        };
        ZipFile.prototype.openReadStream = function(entry, options, callback) {
            var self = this;
            var relativeStart = 0;
            var relativeEnd = entry.compressedSize;
            if (null == callback) {
                callback = options;
                options = {};
            } else {
                if (null != options.decrypt) {
                    if (!entry.isEncrypted()) throw new Error("options.decrypt can only be specified for encrypted entries");
                    if (false !== options.decrypt) throw new Error("invalid options.decrypt value: " + options.decrypt);
                    if (entry.isCompressed()) {
                        if (false !== options.decompress) throw new Error("entry is encrypted and compressed, and options.decompress !== false");
                    }
                }
                if (null != options.decompress) {
                    if (!entry.isCompressed()) throw new Error("options.decompress can only be specified for compressed entries");
                    if (!(false === options.decompress || true === options.decompress)) throw new Error("invalid options.decompress value: " + options.decompress);
                }
                if (null != options.start || null != options.end) {
                    if (entry.isCompressed() && false !== options.decompress) throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
                    if (entry.isEncrypted() && false !== options.decrypt) throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
                }
                if (null != options.start) {
                    relativeStart = options.start;
                    if (relativeStart < 0) throw new Error("options.start < 0");
                    if (relativeStart > entry.compressedSize) throw new Error("options.start > entry.compressedSize");
                }
                if (null != options.end) {
                    relativeEnd = options.end;
                    if (relativeEnd < 0) throw new Error("options.end < 0");
                    if (relativeEnd > entry.compressedSize) throw new Error("options.end > entry.compressedSize");
                    if (relativeEnd < relativeStart) throw new Error("options.end < options.start");
                }
            }
            if (!self.isOpen) return callback(new Error("closed"));
            if (entry.isEncrypted()) {
                if (false !== options.decrypt) return callback(new Error("entry is encrypted, and options.decrypt !== false"));
            }
            self.reader.ref();
            var buffer = newBuffer(30);
            readAndAssertNoEof(self.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {
                try {
                    if (err) return callback(err);
                    var signature = buffer.readUInt32LE(0);
                    if (0x04034b50 !== signature) return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
                    var fileNameLength = buffer.readUInt16LE(26);
                    var extraFieldLength = buffer.readUInt16LE(28);
                    var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;
                    var decompress;
                    if (0 === entry.compressionMethod) decompress = false;
                    else {
                        if (8 !== entry.compressionMethod) return callback(new Error("unsupported compression method: " + entry.compressionMethod));
                        decompress = null != options.decompress ? options.decompress : true;
                    }
                    var fileDataStart = localFileHeaderEnd;
                    var fileDataEnd = fileDataStart + entry.compressedSize;
                    if (0 !== entry.compressedSize) {
                        if (fileDataEnd > self.fileSize) return callback(new Error("file data overflows file bounds: " + fileDataStart + " + " + entry.compressedSize + " > " + self.fileSize));
                    }
                    var readStream = self.reader.createReadStream({
                        start: fileDataStart + relativeStart,
                        end: fileDataStart + relativeEnd
                    });
                    var endpointStream = readStream;
                    if (decompress) {
                        var destroyed = false;
                        var inflateFilter = zlib.createInflateRaw();
                        readStream.on("error", function(err) {
                            setImmediate(function() {
                                if (!destroyed) inflateFilter.emit("error", err);
                            });
                        });
                        readStream.pipe(inflateFilter);
                        if (self.validateEntrySizes) {
                            endpointStream = new AssertByteCountStream(entry.uncompressedSize);
                            inflateFilter.on("error", function(err) {
                                setImmediate(function() {
                                    if (!destroyed) endpointStream.emit("error", err);
                                });
                            });
                            inflateFilter.pipe(endpointStream);
                        } else endpointStream = inflateFilter;
                        endpointStream.destroy = function() {
                            destroyed = true;
                            if (inflateFilter !== endpointStream) inflateFilter.unpipe(endpointStream);
                            readStream.unpipe(inflateFilter);
                            readStream.destroy();
                        };
                    }
                    callback(null, endpointStream);
                } finally{
                    self.reader.unref();
                }
            });
        };
        function Entry() {}
        Entry.prototype.getLastModDate = function() {
            return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);
        };
        Entry.prototype.isEncrypted = function() {
            return (0x1 & this.generalPurposeBitFlag) !== 0;
        };
        Entry.prototype.isCompressed = function() {
            return 8 === this.compressionMethod;
        };
        function dosDateTimeToDate(date, time) {
            var day = 0x1f & date;
            var month = (date >> 5 & 0xf) - 1;
            var year = (date >> 9 & 0x7f) + 1980;
            var millisecond = 0;
            var second = (0x1f & time) * 2;
            var minute = time >> 5 & 0x3f;
            var hour = time >> 11 & 0x1f;
            return new Date(year, month, day, hour, minute, second, millisecond);
        }
        function validateFileName(fileName) {
            if (-1 !== fileName.indexOf("\\")) return "invalid characters in fileName: " + fileName;
            if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) return "absolute path: " + fileName;
            if (-1 !== fileName.split("/").indexOf("..")) return "invalid relative path: " + fileName;
            return null;
        }
        function readAndAssertNoEof(reader, buffer, offset, length, position, callback) {
            if (0 === length) return setImmediate(function() {
                callback(null, newBuffer(0));
            });
            reader.read(buffer, offset, length, position, function(err, bytesRead) {
                if (err) return callback(err);
                if (bytesRead < length) return callback(new Error("unexpected EOF"));
                callback();
            });
        }
        util.inherits(AssertByteCountStream, Transform);
        function AssertByteCountStream(byteCount) {
            Transform.call(this);
            this.actualByteCount = 0;
            this.expectedByteCount = byteCount;
        }
        AssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {
            this.actualByteCount += chunk.length;
            if (this.actualByteCount > this.expectedByteCount) {
                var msg = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
                return cb(new Error(msg));
            }
            cb(null, chunk);
        };
        AssertByteCountStream.prototype._flush = function(cb) {
            if (this.actualByteCount < this.expectedByteCount) {
                var msg = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
                return cb(new Error(msg));
            }
            cb();
        };
        util.inherits(RandomAccessReader, EventEmitter);
        function RandomAccessReader() {
            EventEmitter.call(this);
            this.refCount = 0;
        }
        RandomAccessReader.prototype.ref = function() {
            this.refCount += 1;
        };
        RandomAccessReader.prototype.unref = function() {
            var self = this;
            self.refCount -= 1;
            if (self.refCount > 0) return;
            if (self.refCount < 0) throw new Error("invalid unref");
            self.close(onCloseDone);
            function onCloseDone(err) {
                if (err) return self.emit('error', err);
                self.emit('close');
            }
        };
        RandomAccessReader.prototype.createReadStream = function(options) {
            var start = options.start;
            var end = options.end;
            if (start === end) {
                var emptyStream = new PassThrough();
                setImmediate(function() {
                    emptyStream.end();
                });
                return emptyStream;
            }
            var stream = this._readStreamForRange(start, end);
            var destroyed = false;
            var refUnrefFilter = new RefUnrefFilter(this);
            stream.on("error", function(err) {
                setImmediate(function() {
                    if (!destroyed) refUnrefFilter.emit("error", err);
                });
            });
            refUnrefFilter.destroy = function() {
                stream.unpipe(refUnrefFilter);
                refUnrefFilter.unref();
                stream.destroy();
            };
            var byteCounter = new AssertByteCountStream(end - start);
            refUnrefFilter.on("error", function(err) {
                setImmediate(function() {
                    if (!destroyed) byteCounter.emit("error", err);
                });
            });
            byteCounter.destroy = function() {
                destroyed = true;
                refUnrefFilter.unpipe(byteCounter);
                refUnrefFilter.destroy();
            };
            return stream.pipe(refUnrefFilter).pipe(byteCounter);
        };
        RandomAccessReader.prototype._readStreamForRange = function(start, end) {
            throw new Error("not implemented");
        };
        RandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {
            var readStream = this.createReadStream({
                start: position,
                end: position + length
            });
            var writeStream = new Writable();
            var written = 0;
            writeStream._write = function(chunk, encoding, cb) {
                chunk.copy(buffer, offset + written, 0, chunk.length);
                written += chunk.length;
                cb();
            };
            writeStream.on("finish", callback);
            readStream.on("error", function(error) {
                callback(error);
            });
            readStream.pipe(writeStream);
        };
        RandomAccessReader.prototype.close = function(callback) {
            setImmediate(callback);
        };
        util.inherits(RefUnrefFilter, PassThrough);
        function RefUnrefFilter(context) {
            PassThrough.call(this);
            this.context = context;
            this.context.ref();
            this.unreffedYet = false;
        }
        RefUnrefFilter.prototype._flush = function(cb) {
            this.unref();
            cb();
        };
        RefUnrefFilter.prototype.unref = function(cb) {
            if (this.unreffedYet) return;
            this.unreffedYet = true;
            this.context.unref();
        };
        var cp437 = '\u0000 !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~';
        function decodeBuffer(buffer, start, end, isUtf8) {
            if (isUtf8) return buffer.toString("utf8", start, end);
            var result = "";
            for(var i = start; i < end; i++)result += cp437[buffer[i]];
            return result;
        }
        function readUInt64LE(buffer, offset) {
            var lower32 = buffer.readUInt32LE(offset);
            var upper32 = buffer.readUInt32LE(offset + 4);
            return 0x100000000 * upper32 + lower32;
        }
        var newBuffer;
        newBuffer = "function" == typeof Buffer.allocUnsafe ? function(len) {
            return Buffer.allocUnsafe(len);
        } : function(len) {
            return new Buffer(len);
        };
        function defaultCallback(err) {
            if (err) throw err;
        }
    }
};
