{"version":3,"file":"static/js/popup.5079f993.js","sources":["webpack://chrome-extension/../../packages/web-integration/dist/es/web-element.mjs","webpack://chrome-extension/../../packages/web-integration/dist/es/web-page.mjs","webpack://chrome-extension/./src/utils/bridgeDB.ts","webpack://chrome-extension/./src/utils/indexedDB.ts","webpack://chrome-extension/./src/store.tsx","webpack://chrome-extension/../../packages/recorder/dist/RecordTimeline.js","webpack://chrome-extension/./src/extension/recorder/components/ProgressModal/ThinkingProcessSection.tsx","webpack://chrome-extension/./src/extension/recorder/components/ProgressModal/CodeBlock.tsx","webpack://chrome-extension/./src/extension/recorder/components/ProgressModal/StepList.tsx","webpack://chrome-extension/../../packages/web-integration/dist/es/chrome-extension/agent.mjs","webpack://chrome-extension/../../packages/core/dist/es/ai-model/service-caller/index.mjs","webpack://chrome-extension/../../packages/playground/dist/es/common.mjs","webpack://chrome-extension/../../packages/playground/dist/es/adapters/local-execution.mjs","webpack://chrome-extension/../../packages/playground/dist/es/adapters/remote-execution.mjs","webpack://chrome-extension/../../packages/shared/dist/es/baseDB.mjs","webpack://chrome-extension/../../packages/shared/dist/es/constants/index.mjs","webpack://chrome-extension/webpack/runtime/compat_get_default_export","webpack://chrome-extension/webpack/runtime/create_fake_namespace_object","webpack://chrome-extension/webpack/runtime/define_property_getters","webpack://chrome-extension/webpack/runtime/ensure_chunk","webpack://chrome-extension/webpack/runtime/get javascript chunk filename","webpack://chrome-extension/webpack/runtime/global","webpack://chrome-extension/webpack/runtime/has_own_property","webpack://chrome-extension/webpack/runtime/load_script","webpack://chrome-extension/webpack/runtime/make_namespace_object","webpack://chrome-extension/webpack/runtime/node_module_decorator","webpack://chrome-extension/webpack/runtime/nonce","webpack://chrome-extension/webpack/runtime/on_chunk_loaded","webpack://chrome-extension/webpack/runtime/public_path","webpack://chrome-extension/webpack/runtime/rspack_version","webpack://chrome-extension/webpack/runtime/jsonp_chunk_loading","webpack://chrome-extension/webpack/runtime/rspack_unique_id"],"sourcesContent":["import { traverseTree } from \"@sqaitech/shared/extractor\";\nimport { getDebug } from \"@sqaitech/shared/logger\";\nimport { commonContextParser } from \"@sqaitech/core/agent\";\nfunction _define_property(obj, key, value) {\n    if (key in obj) Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n    });\n    else obj[key] = value;\n    return obj;\n}\nclass WebElementInfoImpl {\n    constructor({ content, rect, id, attributes, indexId, xpaths, isVisible }){\n        _define_property(this, \"content\", void 0);\n        _define_property(this, \"rect\", void 0);\n        _define_property(this, \"center\", void 0);\n        _define_property(this, \"id\", void 0);\n        _define_property(this, \"indexId\", void 0);\n        _define_property(this, \"attributes\", void 0);\n        _define_property(this, \"xpaths\", void 0);\n        _define_property(this, \"isVisible\", void 0);\n        this.content = content;\n        this.rect = rect;\n        this.center = [\n            Math.floor(rect.left + rect.width / 2),\n            Math.floor(rect.top + rect.height / 2)\n        ];\n        this.id = id;\n        this.attributes = attributes;\n        this.indexId = indexId;\n        this.xpaths = xpaths;\n        this.isVisible = isVisible;\n    }\n}\nconst debug = getDebug('web:parse-context');\nasync function WebPageContextParser(page, _opt) {\n    var _page_getElementsNodeTree;\n    const basicContext = await commonContextParser(page, {\n        uploadServerUrl: _opt.uploadServerUrl\n    });\n    debug('will traverse element tree');\n    const tree = await (null == (_page_getElementsNodeTree = page.getElementsNodeTree) ? void 0 : _page_getElementsNodeTree.call(page)) || {\n        node: null,\n        children: []\n    };\n    const webTree = traverseTree(tree, (elementInfo)=>{\n        const { rect, id, content, attributes, indexId, isVisible } = elementInfo;\n        return new WebElementInfoImpl({\n            rect,\n            id,\n            content,\n            attributes,\n            indexId,\n            isVisible\n        });\n    });\n    debug('traverse element tree end');\n    return {\n        ...basicContext,\n        tree: webTree\n    };\n}\nconst limitOpenNewTabScript = `\nif (!window.__MIDSCENE_NEW_TAB_INTERCEPTOR_INITIALIZED__) {\n  window.__MIDSCENE_NEW_TAB_INTERCEPTOR_INITIALIZED__ = true;\n\n  // Intercept the window.open method (only once)\n  window.open = function(url) {\n    console.log('Blocked window.open:', url);\n    window.location.href = url;\n    return null;\n  };\n\n  // Block all a tag clicks with target=\"_blank\" (only once)\n  document.addEventListener('click', function(e) {\n    const target = e.target.closest('a');\n    if (target && target.target === '_blank') {\n      e.preventDefault();\n      console.log('Blocked new tab:', target.href);\n      window.location.href = target.href;\n      target.removeAttribute('target');\n    }\n  }, true);\n}\n`;\nexport { WebElementInfoImpl, WebPageContextParser, limitOpenNewTabScript };\n\n//# sourceMappingURL=web-element.mjs.map","import node_assert from \"node:assert\";\nimport { AbstractInterface, defineActionClearInput, defineActionDoubleClick, defineActionDragAndDrop, defineActionHover, defineActionInput, defineActionKeyboardPress, defineActionLongPress, defineActionRightClick, defineActionScroll, defineActionSwipe, defineActionTap } from \"@sqaitech/core/device\";\nimport { sleep } from \"@sqaitech/core/utils\";\nimport { getDebug } from \"@sqaitech/shared/logger\";\nimport { transformHotkeyInput } from \"@sqaitech/shared/us-keyboard-layout\";\nconst debug = getDebug('web:page');\nfunction normalizeKeyInputs(value) {\n    const inputs = Array.isArray(value) ? value : [\n        value\n    ];\n    const result = [];\n    for (const input of inputs){\n        if ('string' != typeof input) {\n            result.push(input);\n            continue;\n        }\n        const trimmed = input.trim();\n        if (!trimmed) {\n            result.push(input);\n            continue;\n        }\n        let normalized = trimmed;\n        if (normalized.length > 1 && normalized.includes('+')) normalized = normalized.replace(/\\s*\\+\\s*/g, ' ');\n        if (/\\s/.test(normalized)) normalized = normalized.replace(/\\s+/g, ' ');\n        const transformed = transformHotkeyInput(normalized);\n        if (1 === transformed.length && '' === transformed[0] && '' !== trimmed) {\n            result.push(input);\n            continue;\n        }\n        if (0 === transformed.length) {\n            result.push(input);\n            continue;\n        }\n        result.push(...transformed);\n    }\n    return result;\n}\nfunction getKeyCommands(value) {\n    const keys = normalizeKeyInputs(value);\n    return keys.reduce((acc, k)=>{\n        const includeMeta = keys.includes('Meta') || keys.includes('Control');\n        if (includeMeta && ('a' === k || 'A' === k)) return acc.concat([\n            {\n                key: k,\n                command: 'SelectAll'\n            }\n        ]);\n        if (includeMeta && ('c' === k || 'C' === k)) return acc.concat([\n            {\n                key: k,\n                command: 'Copy'\n            }\n        ]);\n        if (includeMeta && ('v' === k || 'V' === k)) return acc.concat([\n            {\n                key: k,\n                command: 'Paste'\n            }\n        ]);\n        return acc.concat([\n            {\n                key: k\n            }\n        ]);\n    }, []);\n}\nclass AbstractWebPage extends AbstractInterface {\n    get mouse() {\n        return {\n            click: async (x, y, options)=>{},\n            wheel: async (deltaX, deltaY)=>{},\n            move: async (x, y)=>{},\n            drag: async (from, to)=>{}\n        };\n    }\n    get keyboard() {\n        return {\n            type: async (text)=>{},\n            press: async (action)=>{}\n        };\n    }\n    async clearInput(element) {}\n}\nconst commonWebActionsForWebPage = (page)=>[\n        defineActionTap(async (param)=>{\n            const element = param.locate;\n            node_assert(element, 'Element not found, cannot tap');\n            await page.mouse.click(element.center[0], element.center[1], {\n                button: 'left'\n            });\n        }),\n        defineActionRightClick(async (param)=>{\n            const element = param.locate;\n            node_assert(element, 'Element not found, cannot right click');\n            await page.mouse.click(element.center[0], element.center[1], {\n                button: 'right'\n            });\n        }),\n        defineActionDoubleClick(async (param)=>{\n            const element = param.locate;\n            node_assert(element, 'Element not found, cannot double click');\n            await page.mouse.click(element.center[0], element.center[1], {\n                button: 'left',\n                count: 2\n            });\n        }),\n        defineActionHover(async (param)=>{\n            const element = param.locate;\n            node_assert(element, 'Element not found, cannot hover');\n            await page.mouse.move(element.center[0], element.center[1]);\n        }),\n        defineActionInput(async (param)=>{\n            const element = param.locate;\n            if (element && 'append' !== param.mode) await page.clearInput(element);\n            if ('clear' === param.mode) return;\n            if (!param || !param.value) return;\n            await page.keyboard.type(param.value);\n        }),\n        defineActionKeyboardPress(async (param)=>{\n            const element = param.locate;\n            if (element) await page.mouse.click(element.center[0], element.center[1], {\n                button: 'left'\n            });\n            const keys = getKeyCommands(param.keyName);\n            await page.keyboard.press(keys);\n        }),\n        defineActionScroll(async (param)=>{\n            const element = param.locate;\n            const startingPoint = element ? {\n                left: element.center[0],\n                top: element.center[1]\n            } : void 0;\n            const scrollToEventName = null == param ? void 0 : param.scrollType;\n            if ('untilTop' === scrollToEventName) await page.scrollUntilTop(startingPoint);\n            else if ('untilBottom' === scrollToEventName) await page.scrollUntilBottom(startingPoint);\n            else if ('untilRight' === scrollToEventName) await page.scrollUntilRight(startingPoint);\n            else if ('untilLeft' === scrollToEventName) await page.scrollUntilLeft(startingPoint);\n            else if ('once' !== scrollToEventName && scrollToEventName) throw new Error(`Unknown scroll event type: ${scrollToEventName}, param: ${JSON.stringify(param)}`);\n            else {\n                if ((null == param ? void 0 : param.direction) !== 'down' && param && param.direction) if ('up' === param.direction) await page.scrollUp(param.distance || void 0, startingPoint);\n                else if ('left' === param.direction) await page.scrollLeft(param.distance || void 0, startingPoint);\n                else if ('right' === param.direction) await page.scrollRight(param.distance || void 0, startingPoint);\n                else throw new Error(`Unknown scroll direction: ${param.direction}`);\n                else await page.scrollDown((null == param ? void 0 : param.distance) || void 0, startingPoint);\n                await sleep(500);\n            }\n        }),\n        defineActionDragAndDrop(async (param)=>{\n            const from = param.from;\n            const to = param.to;\n            node_assert(from, 'missing \"from\" param for drag and drop');\n            node_assert(to, 'missing \"to\" param for drag and drop');\n            await page.mouse.drag({\n                x: from.center[0],\n                y: from.center[1]\n            }, {\n                x: to.center[0],\n                y: to.center[1]\n            });\n        }),\n        defineActionLongPress(async (param)=>{\n            const element = param.locate;\n            node_assert(element, 'Element not found, cannot long press');\n            const duration = null == param ? void 0 : param.duration;\n            await page.longPress(element.center[0], element.center[1], duration);\n        }),\n        defineActionSwipe(async (param)=>{\n            const { width, height } = await page.size();\n            const { start, end } = param;\n            const startPoint = start ? {\n                x: start.center[0],\n                y: start.center[1]\n            } : {\n                x: width / 2,\n                y: height / 2\n            };\n            let endPoint;\n            if (end) endPoint = {\n                x: end.center[0],\n                y: end.center[1]\n            };\n            else if (param.distance) {\n                const direction = param.direction;\n                if (!direction) throw new Error('direction is required for swipe gesture');\n                endPoint = {\n                    x: startPoint.x + ('right' === direction ? param.distance : 'left' === direction ? -param.distance : 0),\n                    y: startPoint.y + ('down' === direction ? param.distance : 'up' === direction ? -param.distance : 0)\n                };\n            } else throw new Error('Either end or distance must be specified for swipe gesture');\n            endPoint.x = Math.max(0, Math.min(endPoint.x, width));\n            endPoint.y = Math.max(0, Math.min(endPoint.y, height));\n            const duration = param.duration;\n            debug(`swipe from ${startPoint.x}, ${startPoint.y} to ${endPoint.x}, ${endPoint.y} with duration ${duration}ms, repeat is set to ${param.repeat}`);\n            let repeat = 'number' == typeof param.repeat ? param.repeat : 1;\n            if (0 === repeat) repeat = 10;\n            for(let i = 0; i < repeat; i++)await page.swipe(startPoint, endPoint, duration);\n        }),\n        defineActionClearInput(async (param)=>{\n            const element = param.locate;\n            node_assert(element, 'Element not found, cannot clear input');\n            await page.clearInput(element);\n        })\n    ];\nexport { AbstractWebPage, commonWebActionsForWebPage, getKeyCommands };\n\n//# sourceMappingURL=web-page.mjs.map","import { IndexedDBManager, withErrorHandling } from '@sqaitech/shared/baseDB';\r\n\r\n// Database configuration\r\nconst DB_NAME = 'midscene_bridge';\r\nconst DB_VERSION = 1;\r\nconst BRIDGE_MESSAGES_STORE = 'bridge_messages';\r\n\r\n// Bridge message interface\r\nexport interface IndexedDBBridgeMessage {\r\n  id: string;\r\n  type: string;\r\n  content: string;\r\n  timestamp: number;\r\n  time?: string;\r\n}\r\n\r\n// Bridge message result interface for external use\r\nexport interface BridgeMessage {\r\n  id: string;\r\n  type: string;\r\n  content: string;\r\n  timestamp: Date;\r\n  time?: string;\r\n}\r\n\r\n// Database manager instance\r\nconst bridgeDbManager = new IndexedDBManager(DB_NAME, DB_VERSION, [\r\n  { name: BRIDGE_MESSAGES_STORE, keyPath: 'id' },\r\n]);\r\n\r\n// get bridge messages from IndexedDB\r\nexport const getBridgeMsgsFromStorage = async (): Promise<BridgeMessage[]> => {\r\n  return (\r\n    (await withErrorHandling(\r\n      async () => {\r\n        const messages = await bridgeDbManager.getAll<IndexedDBBridgeMessage>(\r\n          BRIDGE_MESSAGES_STORE,\r\n          true,\r\n        );\r\n\r\n        return messages.map((msg) => ({\r\n          id: msg.id,\r\n          type: msg.type,\r\n          content: msg.content,\r\n          timestamp: new Date(msg.timestamp),\r\n          time: msg.time,\r\n        }));\r\n      },\r\n      'Failed to get bridge messages from IndexedDB',\r\n      [],\r\n    )) ?? []\r\n  );\r\n};\r\n\r\n// store bridge messages to IndexedDB\r\nexport const storeBridgeMsgsToStorage = async (\r\n  messageList: any[],\r\n): Promise<void> => {\r\n  await withErrorHandling(async () => {\r\n    // Clear existing bridge messages first\r\n    await bridgeDbManager.clear(BRIDGE_MESSAGES_STORE);\r\n\r\n    const msgs = messageList\r\n      .filter((item) => item.type === 'system' || item.type === 'status')\r\n      .map((item) => ({\r\n        id: item.id,\r\n        type: item.type,\r\n        content: item.content,\r\n        timestamp: item.timestamp,\r\n        time: item.time,\r\n      }));\r\n\r\n    // Store each bridge message\r\n    await Promise.all(\r\n      msgs.map((msg, index) => {\r\n        const data: IndexedDBBridgeMessage = {\r\n          id: msg.id || `bridge-msg-${index}`,\r\n          type: msg.type,\r\n          content: msg.content,\r\n          timestamp: msg.timestamp\r\n            ? msg.timestamp.getTime()\r\n            : Date.now() + index,\r\n          time: msg.time,\r\n        };\r\n\r\n        return bridgeDbManager.put(BRIDGE_MESSAGES_STORE, data);\r\n      }),\r\n    );\r\n  }, 'Failed to store bridge messages');\r\n};\r\n\r\n// clear stored bridge messages\r\nexport const clearStoredBridgeMessages = async (): Promise<void> => {\r\n  await withErrorHandling(\r\n    () => bridgeDbManager.clear(BRIDGE_MESSAGES_STORE),\r\n    'Failed to clear bridge messages from IndexedDB',\r\n  );\r\n};\r\n\r\n// get bridge message count\r\nexport const getBridgeMessageCount = async (): Promise<number> => {\r\n  return (\r\n    (await withErrorHandling(\r\n      () => bridgeDbManager.count(BRIDGE_MESSAGES_STORE),\r\n      'Failed to get bridge message count',\r\n      0,\r\n    )) ?? 0\r\n  );\r\n};\r\n","import type { RecordingSession } from '../store';\r\n\r\nconst DB_NAME = 'midscene-recorder';\r\nconst DB_VERSION = 2;\r\nconst SESSIONS_STORE = 'recording-sessions';\r\nconst CONFIG_STORE = 'config';\r\n\r\n// Session limit configuration\r\nconst MAX_SESSIONS = 5;\r\n\r\ninterface DBConfig {\r\n  currentSessionId: string | null;\r\n  isRecording: boolean;\r\n  // Navigation recovery fields\r\n  wasRecordingBeforeNavigation?: boolean;\r\n  lastRecordingTabId?: number;\r\n  lastRecordingUrl?: string;\r\n  lastRecordingSessionId?: string;\r\n  lastNavigationTime?: number;\r\n}\r\n\r\nclass IndexedDBManager {\r\n  private db: IDBDatabase | null = null;\r\n  private initPromise: Promise<void> | null = null;\r\n  private isInitialized = false;\r\n  private isHealthy = true;\r\n\r\n  async init(): Promise<void> {\r\n    // Prevent duplicate initialization\r\n    if (this.isInitialized && this.isHealthy) {\r\n      return;\r\n    }\r\n\r\n    // If already initializing, return existing Promise\r\n    if (this.initPromise) {\r\n      return this.initPromise;\r\n    }\r\n\r\n    this.initPromise = this._doInit();\r\n    try {\r\n      await this.initPromise;\r\n      this.isInitialized = true;\r\n      this.isHealthy = true;\r\n    } catch (error) {\r\n      // Reset Promise on failure for retry\r\n      this.initPromise = null;\r\n      this.isHealthy = false;\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Health check method\r\n  private async healthCheck(): Promise<boolean> {\r\n    if (!this.db || !this.isInitialized) {\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      // Simple read test\r\n      await this.getConfig();\r\n      this.isHealthy = true;\r\n      return true;\r\n    } catch (error) {\r\n      console.warn('IndexedDB health check failed:', error);\r\n      this.isHealthy = false;\r\n      return false;\r\n    }\r\n  }\r\n\r\n  private async _doInit(): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      const request = indexedDB.open(DB_NAME, DB_VERSION);\r\n\r\n      request.onerror = () => {\r\n        console.error('IndexedDB open error:', request.error);\r\n        reject(request.error);\r\n      };\r\n\r\n      request.onsuccess = () => {\r\n        this.db = request.result;\r\n\r\n        // Add database error handling\r\n        this.db.onerror = (event) => {\r\n          console.error('IndexedDB error:', event);\r\n        };\r\n\r\n        resolve();\r\n      };\r\n\r\n      request.onupgradeneeded = (event) => {\r\n        const db = (event.target as IDBOpenDBRequest).result;\r\n\r\n        // Create sessions store\r\n        if (!db.objectStoreNames.contains(SESSIONS_STORE)) {\r\n          const sessionsStore = db.createObjectStore(SESSIONS_STORE, {\r\n            keyPath: 'id',\r\n          });\r\n          sessionsStore.createIndex('createdAt', 'createdAt', {\r\n            unique: false,\r\n          });\r\n          sessionsStore.createIndex('updatedAt', 'updatedAt', {\r\n            unique: false,\r\n          });\r\n        }\r\n\r\n        // Create config store\r\n        if (!db.objectStoreNames.contains(CONFIG_STORE)) {\r\n          db.createObjectStore(CONFIG_STORE, { keyPath: 'key' });\r\n        }\r\n      };\r\n    });\r\n  }\r\n\r\n  private async ensureDB(): Promise<IDBDatabase> {\r\n    await this.init();\r\n    if (!this.db || !this.isInitialized || !this.isHealthy) {\r\n      throw new Error(\r\n        'Database not initialized or unhealthy. Call init() first.',\r\n      );\r\n    }\r\n    return this.db;\r\n  }\r\n\r\n  // Safe database operation wrapper\r\n  private async safeDBOperation<T>(\r\n    operation: () => Promise<T>,\r\n    fallback: T,\r\n  ): Promise<T> {\r\n    try {\r\n      // Health check\r\n      if (!this.isHealthy) {\r\n        const isHealthy = await this.healthCheck();\r\n        if (!isHealthy) {\r\n          throw new Error('Database is unhealthy');\r\n        }\r\n      }\r\n\r\n      return await operation();\r\n    } catch (error) {\r\n      console.error('Database operation failed:', error);\r\n      this.isHealthy = false;\r\n      return fallback;\r\n    }\r\n  }\r\n\r\n  // Create Promise wrapper with timeout\r\n  private createTimeoutPromise<T>(\r\n    promiseExecutor: (\r\n      resolve: (value: T) => void,\r\n      reject: (reason?: any) => void,\r\n    ) => void,\r\n    timeoutMs = 10000,\r\n  ): Promise<T> {\r\n    return new Promise<T>((resolve, reject) => {\r\n      // Set timeout\r\n      const timeoutId = setTimeout(() => {\r\n        reject(new Error(`IndexedDB operation timeout after ${timeoutMs}ms`));\r\n      }, timeoutMs);\r\n\r\n      // Wrap original resolve and reject\r\n      const wrappedResolve = (value: T) => {\r\n        clearTimeout(timeoutId);\r\n        resolve(value);\r\n      };\r\n\r\n      const wrappedReject = (reason?: any) => {\r\n        clearTimeout(timeoutId);\r\n        reject(reason);\r\n      };\r\n\r\n      try {\r\n        promiseExecutor(wrappedResolve, wrappedReject);\r\n      } catch (error) {\r\n        clearTimeout(timeoutId);\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  // Session management\r\n  async getAllSessions(): Promise<RecordingSession[]> {\r\n    return this.safeDBOperation(async () => {\r\n      const db = await this.ensureDB();\r\n\r\n      return this.createTimeoutPromise<RecordingSession[]>(\r\n        (resolve, reject) => {\r\n          const transaction = db.transaction([SESSIONS_STORE], 'readonly');\r\n\r\n          // Add transaction error handling\r\n          transaction.onerror = () => {\r\n            console.error(\r\n              'Transaction error in getAllSessions:',\r\n              transaction.error,\r\n            );\r\n            reject(transaction.error);\r\n          };\r\n\r\n          transaction.onabort = () => {\r\n            console.error('Transaction aborted in getAllSessions');\r\n            reject(new Error('Transaction aborted'));\r\n          };\r\n\r\n          const store = transaction.objectStore(SESSIONS_STORE);\r\n          const index = store.index('updatedAt');\r\n          const request = index.getAll();\r\n\r\n          request.onsuccess = () => {\r\n            try {\r\n              // Sort by updatedAt descending (newest first)\r\n              const sessions = request.result.sort(\r\n                (a, b) => b.updatedAt - a.updatedAt,\r\n              );\r\n              resolve(sessions);\r\n            } catch (error) {\r\n              reject(error);\r\n            }\r\n          };\r\n\r\n          request.onerror = () => {\r\n            console.error('Request error in getAllSessions:', request.error);\r\n            reject(request.error);\r\n          };\r\n        },\r\n      );\r\n    }, []);\r\n  }\r\n\r\n  async getSession(id: string): Promise<RecordingSession | null> {\r\n    return this.safeDBOperation(async () => {\r\n      const db = await this.ensureDB();\r\n\r\n      return this.createTimeoutPromise<RecordingSession | null>(\r\n        (resolve, reject) => {\r\n          const transaction = db.transaction([SESSIONS_STORE], 'readonly');\r\n\r\n          transaction.onerror = () => {\r\n            console.error(\r\n              'Transaction error in getSession:',\r\n              transaction.error,\r\n            );\r\n            reject(transaction.error);\r\n          };\r\n\r\n          transaction.onabort = () => {\r\n            console.error('Transaction aborted in getSession');\r\n            reject(new Error('Transaction aborted'));\r\n          };\r\n\r\n          const store = transaction.objectStore(SESSIONS_STORE);\r\n          const request = store.get(id);\r\n\r\n          request.onsuccess = () => resolve(request.result || null);\r\n          request.onerror = () => {\r\n            console.error('Request error in getSession:', request.error);\r\n            reject(request.error);\r\n          };\r\n        },\r\n      );\r\n    }, null);\r\n  }\r\n\r\n  async addSession(session: RecordingSession): Promise<void> {\r\n    const db = await this.ensureDB();\r\n\r\n    // First, check if we need to remove old sessions\r\n    const sessions = await this.getAllSessions();\r\n    if (sessions.length >= MAX_SESSIONS) {\r\n      // Remove oldest sessions to make room\r\n      const sessionsToRemove = sessions\r\n        .slice(MAX_SESSIONS - 1)\r\n        .map((s) => s.id);\r\n\r\n      for (const sessionId of sessionsToRemove) {\r\n        await this.deleteSession(sessionId);\r\n      }\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = db.transaction([SESSIONS_STORE], 'readwrite');\r\n      const store = transaction.objectStore(SESSIONS_STORE);\r\n      const request = store.add(session);\r\n\r\n      request.onsuccess = () => resolve();\r\n      request.onerror = () => reject(request.error);\r\n    });\r\n  }\r\n\r\n  async updateSession(\r\n    sessionId: string,\r\n    updates: Partial<RecordingSession>,\r\n  ): Promise<void> {\r\n    const db = await this.ensureDB();\r\n    let existingSession = await this.getSession(sessionId);\r\n\r\n    // If session doesn't exist, create a basic session structure\r\n    if (!existingSession) {\r\n      console.warn(\r\n        `Session ${sessionId} not found, creating new session with updates`,\r\n      );\r\n      existingSession = {\r\n        id: sessionId,\r\n        name: `Session ${new Date().toLocaleString()}`,\r\n        createdAt: Date.now(),\r\n        updatedAt: Date.now(),\r\n        events: [],\r\n        status: 'idle' as const,\r\n        ...updates, // Apply the updates to the new session\r\n      };\r\n    } else {\r\n      // Merge updates with existing session\r\n      existingSession = {\r\n        ...existingSession,\r\n        ...updates,\r\n        updatedAt: Date.now(),\r\n      };\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = db.transaction([SESSIONS_STORE], 'readwrite');\r\n      const store = transaction.objectStore(SESSIONS_STORE);\r\n      const request = store.put(existingSession);\r\n\r\n      request.onsuccess = () => resolve();\r\n      request.onerror = () => reject(request.error);\r\n    });\r\n  }\r\n\r\n  async deleteSession(sessionId: string): Promise<void> {\r\n    try {\r\n      const db = await this.ensureDB();\r\n      return new Promise((resolve, reject) => {\r\n        setTimeout(() => {\r\n          const transaction = db.transaction([SESSIONS_STORE], 'readwrite');\r\n          const store = transaction.objectStore(SESSIONS_STORE);\r\n          const request = store.delete(sessionId);\r\n          request.onsuccess = () => {\r\n            resolve();\r\n          };\r\n          request.onerror = () => {\r\n            reject(request.error);\r\n          };\r\n        }, 300);\r\n      });\r\n    } catch (error) {\r\n      console.error('Failed to delete session:', error);\r\n    }\r\n  }\r\n\r\n  // Config management\r\n  async getConfig(): Promise<DBConfig> {\r\n    try {\r\n      const db = await this.ensureDB();\r\n      return new Promise((resolve, reject) => {\r\n        const transaction = db.transaction([CONFIG_STORE], 'readonly');\r\n        const store = transaction.objectStore(CONFIG_STORE);\r\n        const request = store.get('config');\r\n\r\n        request.onsuccess = () => {\r\n          const result = request.result;\r\n          resolve(\r\n            result?.value || {\r\n              currentSessionId: null,\r\n              isRecording: false,\r\n              wasRecordingBeforeNavigation: false,\r\n              lastRecordingTabId: undefined,\r\n              lastRecordingUrl: undefined,\r\n              lastRecordingSessionId: undefined,\r\n              lastNavigationTime: undefined,\r\n            },\r\n          );\r\n        };\r\n        request.onerror = () => reject(request.error);\r\n      });\r\n    } catch (error) {\r\n      console.error('Failed to get config:', error);\r\n      return {\r\n        currentSessionId: null,\r\n        isRecording: false,\r\n        wasRecordingBeforeNavigation: false,\r\n        lastRecordingTabId: undefined,\r\n        lastRecordingUrl: undefined,\r\n        lastRecordingSessionId: undefined,\r\n        lastNavigationTime: undefined,\r\n      };\r\n    }\r\n  }\r\n\r\n  async setConfig(config: Partial<DBConfig>): Promise<void> {\r\n    try {\r\n      const db = await this.ensureDB();\r\n      const currentConfig = await this.getConfig();\r\n      const newConfig = { ...currentConfig, ...config };\r\n\r\n      return new Promise((resolve, reject) => {\r\n        const transaction = db.transaction([CONFIG_STORE], 'readwrite');\r\n        const store = transaction.objectStore(CONFIG_STORE);\r\n        const request = store.put({ key: 'config', value: newConfig });\r\n\r\n        request.onsuccess = () => resolve();\r\n        request.onerror = () => reject(request.error);\r\n      });\r\n    } catch (error) {\r\n      console.error('Failed to set config:', error);\r\n    }\r\n  }\r\n\r\n  async getCurrentSessionId(): Promise<string | null> {\r\n    const config = await this.getConfig();\r\n    return config.currentSessionId;\r\n  }\r\n\r\n  async setCurrentSessionId(sessionId: string | null): Promise<void> {\r\n    await this.setConfig({ currentSessionId: sessionId });\r\n  }\r\n\r\n  async getRecordingState(): Promise<boolean> {\r\n    const config = await this.getConfig();\r\n    return config.isRecording;\r\n  }\r\n\r\n  async setRecordingState(isRecording: boolean): Promise<void> {\r\n    await this.setConfig({ isRecording });\r\n  }\r\n\r\n  // Clear navigation recovery state\r\n  async clearNavigationRecoveryState(): Promise<void> {\r\n    await this.setConfig({\r\n      wasRecordingBeforeNavigation: false,\r\n      lastRecordingTabId: undefined,\r\n      lastRecordingUrl: undefined,\r\n      lastRecordingSessionId: undefined,\r\n      lastNavigationTime: undefined,\r\n    });\r\n  }\r\n\r\n  // Recording events management (temporary storage during recording)\r\n  async getRecordingEvents(): Promise<any[]> {\r\n    return this.safeDBOperation(async () => {\r\n      const db = await this.ensureDB();\r\n\r\n      return this.createTimeoutPromise<any[]>((resolve, reject) => {\r\n        const transaction = db.transaction([CONFIG_STORE], 'readonly');\r\n\r\n        transaction.onerror = () => {\r\n          console.error(\r\n            'Transaction error in getRecordingEvents:',\r\n            transaction.error,\r\n          );\r\n          reject(transaction.error);\r\n        };\r\n\r\n        const store = transaction.objectStore(CONFIG_STORE);\r\n        const request = store.get('recording-events');\r\n\r\n        request.onsuccess = () => {\r\n          const result = request.result;\r\n          resolve(result?.value || []);\r\n        };\r\n        request.onerror = () => {\r\n          console.error('Request error in getRecordingEvents:', request.error);\r\n          reject(request.error);\r\n        };\r\n      });\r\n    }, []);\r\n  }\r\n\r\n  async setRecordingEvents(events: any[]): Promise<void> {\r\n    try {\r\n      const db = await this.ensureDB();\r\n\r\n      return this.createTimeoutPromise<void>((resolve, reject) => {\r\n        const transaction = db.transaction([CONFIG_STORE], 'readwrite');\r\n\r\n        // Add transaction error handling\r\n        transaction.onerror = () => {\r\n          console.error(\r\n            'Transaction error in setRecordingEvents:',\r\n            transaction.error,\r\n          );\r\n          reject(transaction.error);\r\n        };\r\n\r\n        transaction.onabort = () => {\r\n          console.error('Transaction aborted in setRecordingEvents');\r\n          reject(new Error('Transaction aborted'));\r\n        };\r\n\r\n        const store = transaction.objectStore(CONFIG_STORE);\r\n        const request = store.put({ key: 'recording-events', value: events });\r\n\r\n        request.onsuccess = () => resolve();\r\n        request.onerror = () => {\r\n          console.error('Request error in setRecordingEvents:', request.error);\r\n          reject(request.error);\r\n        };\r\n      }, 5000); // Shorter timeout for events during navigation\r\n    } catch (error) {\r\n      console.error('Failed to set recording events:', error);\r\n      // Don't throw error during navigation to prevent hanging\r\n    }\r\n  }\r\n\r\n  // Emergency method for saving events during navigation with minimal timeout\r\n  async emergencySetRecordingEvents(events: any[]): Promise<void> {\r\n    try {\r\n      const db = await this.ensureDB();\r\n\r\n      return this.createTimeoutPromise<void>((resolve, reject) => {\r\n        const transaction = db.transaction([CONFIG_STORE], 'readwrite');\r\n\r\n        // Immediate resolution on transaction complete for faster response\r\n        transaction.oncomplete = () => resolve();\r\n        transaction.onerror = () => reject(transaction.error);\r\n        transaction.onabort = () => reject(new Error('Transaction aborted'));\r\n\r\n        const store = transaction.objectStore(CONFIG_STORE);\r\n        const request = store.put({ key: 'recording-events', value: events });\r\n\r\n        request.onerror = () => reject(request.error);\r\n      }, 2000); // Very short timeout for emergency saves\r\n    } catch (error) {\r\n      console.error('Failed to emergency save recording events:', error);\r\n      // Fail silently during navigation\r\n    }\r\n  }\r\n\r\n  async clearRecordingEvents(): Promise<void> {\r\n    try {\r\n      const db = await this.ensureDB();\r\n\r\n      return new Promise((resolve, reject) => {\r\n        const transaction = db.transaction([CONFIG_STORE], 'readwrite');\r\n        const store = transaction.objectStore(CONFIG_STORE);\r\n        const request = store.delete('recording-events');\r\n\r\n        request.onsuccess = () => resolve();\r\n        request.onerror = () => reject(request.error);\r\n      });\r\n    } catch (error) {\r\n      console.error('Failed to clear recording events:', error);\r\n    }\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nexport const dbManager = new IndexedDBManager();\r\n\r\n// Global initialization state tracking\r\nlet isGloballyInitialized = false;\r\nlet globalInitPromise: Promise<void> | null = null;\r\n\r\n// Initialize the database\r\nexport const initializeDB = async (): Promise<void> => {\r\n  // Prevent duplicate initialization\r\n  if (isGloballyInitialized) {\r\n    return;\r\n  }\r\n\r\n  // If already initializing, return existing Promise\r\n  if (globalInitPromise) {\r\n    return globalInitPromise;\r\n  }\r\n\r\n  globalInitPromise = (async () => {\r\n    try {\r\n      await dbManager.init();\r\n      // Only execute migration on first initialization\r\n      if (!isGloballyInitialized) {\r\n        isGloballyInitialized = true;\r\n      }\r\n    } catch (error) {\r\n      // Reset state on initialization failure for retry\r\n      globalInitPromise = null;\r\n      console.error('Failed to initialize IndexedDB:', error);\r\n      throw error;\r\n    }\r\n  })();\r\n\r\n  return globalInitPromise;\r\n};\r\n","import type { ChromeRecordedEvent } from '@sqaitech/recorder';\r\n// import { createStore } from 'zustand/vanilla';\r\nimport * as Z from 'zustand';\r\nimport { recordLogger } from './extension/recorder/logger';\r\nimport { dbManager, initializeDB } from './utils/indexedDB';\r\n\r\nconst { create } = Z;\r\nexport const useBlackboardPreference = create<{\r\n  markerVisible: boolean;\r\n  elementsVisible: boolean;\r\n  setMarkerVisible: (visible: boolean) => void;\r\n  setTextsVisible: (visible: boolean) => void;\r\n}>((set) => ({\r\n  markerVisible: true,\r\n  elementsVisible: true,\r\n  setMarkerVisible: (visible: boolean) => {\r\n    set({ markerVisible: visible });\r\n  },\r\n  setTextsVisible: (visible: boolean) => {\r\n    set({ elementsVisible: visible });\r\n  },\r\n}));\r\n\r\n// Recording session interface\r\nexport interface RecordingSession {\r\n  id: string;\r\n  name: string;\r\n  description?: string;\r\n  createdAt: number;\r\n  updatedAt: number;\r\n  events: ChromeRecordedEvent[];\r\n  status: 'idle' | 'recording' | 'completed';\r\n  duration?: number; // in milliseconds\r\n  url?: string; // The URL where recording started\r\n  generatedCode?: {\r\n    playwright?: string;\r\n    yaml?: string;\r\n    lastGenerated?: number; // timestamp of last generation\r\n  };\r\n}\r\n\r\n// Storage keys\r\nconst RECORDING_SESSIONS_KEY = 'midscene-recording-sessions';\r\nconst CURRENT_SESSION_ID_KEY = 'midscene-current-session-id';\r\nconst RECORDING_STATE_KEY = 'midscene-recording-state';\r\n\r\n// Helper functions for persistence with IndexedDB\r\nconst loadSessionsFromStorage = async (): Promise<RecordingSession[]> => {\r\n  try {\r\n    // initializeDB is now idempotent, safe to call\r\n    return await dbManager.getAllSessions();\r\n  } catch (error) {\r\n    console.error('Failed to load sessions from IndexedDB:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\nconst saveSessionsToStorage = async (sessions: RecordingSession[]) => {\r\n  // This function is now handled by individual session operations in IndexedDB\r\n  // Keeping for compatibility but no longer used\r\n};\r\n\r\nconst loadCurrentSessionIdFromStorage = async (): Promise<string | null> => {\r\n  try {\r\n    return await dbManager.getCurrentSessionId();\r\n  } catch (error) {\r\n    console.error('Failed to load current session ID from IndexedDB:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\nconst saveCurrentSessionIdToStorage = async (sessionId: string | null) => {\r\n  try {\r\n    await dbManager.setCurrentSessionId(sessionId);\r\n  } catch (error) {\r\n    console.error('Failed to save current session ID to IndexedDB:', error);\r\n  }\r\n};\r\n\r\n// Helper functions for recording state persistence with IndexedDB\r\nconst loadRecordingStateFromStorage = async (): Promise<boolean> => {\r\n  try {\r\n    return await dbManager.getRecordingState();\r\n  } catch (error) {\r\n    console.error('Failed to load recording state from IndexedDB:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\nconst saveRecordingStateToStorage = async (isRecording: boolean) => {\r\n  try {\r\n    await dbManager.setRecordingState(isRecording);\r\n  } catch (error) {\r\n    console.error('Failed to save recording state to IndexedDB:', error);\r\n  }\r\n};\r\n\r\nexport const useRecordingSessionStore = create<{\r\n  sessions: RecordingSession[];\r\n  currentSessionId: string | null;\r\n  isInitialized: boolean;\r\n  initializeStore: () => Promise<void>;\r\n  addSession: (session: RecordingSession) => Promise<void>;\r\n  updateSession: (\r\n    sessionId: string,\r\n    updates: Partial<RecordingSession>,\r\n  ) => Promise<void>;\r\n  deleteSession: (sessionId: string) => Promise<void>;\r\n  setCurrentSession: (sessionId: string | null) => Promise<void>;\r\n  getCurrentSession: () => RecordingSession | null;\r\n}>((set, get) => ({\r\n  sessions: [],\r\n  currentSessionId: null,\r\n  isInitialized: false,\r\n  initializeStore: async () => {\r\n    // Prevent duplicate initialization\r\n    const currentState = get();\r\n    if (currentState.isInitialized) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      // Ensure database initialization\r\n      await initializeDB();\r\n      const [sessions, currentSessionId] = await Promise.all([\r\n        loadSessionsFromStorage(),\r\n        loadCurrentSessionIdFromStorage(),\r\n      ]);\r\n      set({ sessions, currentSessionId, isInitialized: true });\r\n    } catch (error) {\r\n      console.error('Failed to initialize recording session store:', error);\r\n      set({ isInitialized: true });\r\n    }\r\n  },\r\n  addSession: async (session) => {\r\n    try {\r\n      await dbManager.addSession(session);\r\n      const sessions = await dbManager.getAllSessions();\r\n      set({ sessions });\r\n    } catch (error) {\r\n      console.error('Failed to add session:', error);\r\n    }\r\n  },\r\n  updateSession: async (sessionId, updates) => {\r\n    try {\r\n      recordLogger.info('Updating session', { sessionId, updates });\r\n      await dbManager.updateSession(sessionId, updates);\r\n      const sessions = await dbManager.getAllSessions();\r\n      set({ sessions });\r\n    } catch (error) {\r\n      console.error('Failed to update session:', error);\r\n      // Try to recover by ensuring the session exists in memory\r\n      const { sessions } = get();\r\n      const sessionInMemory = sessions.find((s) => s.id === sessionId);\r\n      if (sessionInMemory) {\r\n        const updatedSession = {\r\n          ...sessionInMemory,\r\n          ...updates,\r\n          updatedAt: Date.now(),\r\n        };\r\n        const newSessions = sessions.map((s) =>\r\n          s.id === sessionId ? updatedSession : s,\r\n        );\r\n        set({ sessions: newSessions });\r\n      }\r\n    }\r\n  },\r\n  deleteSession: async (sessionId) => {\r\n    try {\r\n      await dbManager.deleteSession(sessionId);\r\n      const sessions = await dbManager.getAllSessions();\r\n      set({ sessions });\r\n    } catch (error) {\r\n      console.error('Failed to delete session:', error);\r\n    }\r\n  },\r\n  setCurrentSession: async (sessionId) => {\r\n    try {\r\n      await saveCurrentSessionIdToStorage(sessionId);\r\n      set({ currentSessionId: sessionId });\r\n    } catch (error) {\r\n      console.error('Failed to set current session:', error);\r\n    }\r\n  },\r\n  getCurrentSession: () => {\r\n    const state = get();\r\n    return state.sessions.find((s) => s.id === state.currentSessionId) || null;\r\n  },\r\n}));\r\n\r\n// Helper functions for events persistence with IndexedDB\r\nconst loadEventsFromStorage = async (): Promise<ChromeRecordedEvent[]> => {\r\n  try {\r\n    return await dbManager.getRecordingEvents();\r\n  } catch (error) {\r\n    console.error('Failed to load events from IndexedDB:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\nfunction mergeEvents(\r\n  oldEvents: ChromeRecordedEvent[],\r\n  newEvents: ChromeRecordedEvent[],\r\n): ChromeRecordedEvent[] {\r\n  const mergedEventsMap = new Map<string, ChromeRecordedEvent>();\r\n\r\n  // Add old events to map, prioritizing them initially\r\n  for (const event of oldEvents) {\r\n    if (event.hashId) {\r\n      mergedEventsMap.set(event.hashId, event);\r\n    }\r\n  }\r\n\r\n  // Add new events to map, replacing old ones if hashId matches\r\n  for (const event of newEvents) {\r\n    if (event.hashId) {\r\n      mergedEventsMap.set(event.hashId, event);\r\n    }\r\n  }\r\n\r\n  const mergedArray = Array.from(mergedEventsMap.values());\r\n  // Sort events by timestamp in ascending order\r\n  mergedArray.sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));\r\n  return mergedArray;\r\n}\r\n\r\nconst saveEventsToStorage = async (events: ChromeRecordedEvent[]) => {\r\n  try {\r\n    const existingEvents = await dbManager.getRecordingEvents();\r\n    const combinedEvents = mergeEvents(existingEvents, events);\r\n    await dbManager.setRecordingEvents(combinedEvents);\r\n  } catch (error) {\r\n    console.error('Failed to save events to IndexedDB:', error);\r\n  }\r\n};\r\n\r\nconst clearEventsFromStorage = async () => {\r\n  try {\r\n    await dbManager.clearRecordingEvents();\r\n  } catch (error) {\r\n    console.error('Failed to clear events from IndexedDB:', error);\r\n  }\r\n};\r\n\r\nexport const useRecordStore = create<{\r\n  isRecording: boolean;\r\n  events: ChromeRecordedEvent[];\r\n  isInitialized: boolean;\r\n  initialize: () => Promise<void>;\r\n  setIsRecording: (recording: boolean) => Promise<void>;\r\n  updateEvent: (event: ChromeRecordedEvent) => Promise<void>;\r\n  addEvent: (event: ChromeRecordedEvent) => Promise<void>;\r\n  setEvents: (events: ChromeRecordedEvent[]) => Promise<void>;\r\n  clearEvents: () => Promise<void>;\r\n  emergencySaveEvents: (events?: ChromeRecordedEvent[]) => Promise<void>;\r\n}>((set, get) => ({\r\n  isRecording: false,\r\n  events: [],\r\n  isInitialized: false,\r\n  initialize: async () => {\r\n    // Prevent duplicate initialization\r\n    const currentState = get();\r\n    if (currentState.isInitialized) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      // Ensure database initialization\r\n      await initializeDB();\r\n      const isRecording = await loadRecordingStateFromStorage();\r\n      const events = isRecording ? await loadEventsFromStorage() : [];\r\n      set({ isRecording, events, isInitialized: true });\r\n    } catch (error) {\r\n      console.error('Failed to initialize record store:', error);\r\n      set({ isInitialized: true });\r\n    }\r\n  },\r\n  setIsRecording: async (recording: boolean) => {\r\n    try {\r\n      await saveRecordingStateToStorage(recording);\r\n      set({ isRecording: recording });\r\n      // Clear events from storage when stopping recording\r\n      if (!recording) {\r\n        await clearEventsFromStorage();\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to set recording state:', error);\r\n    }\r\n  },\r\n  addEvent: async (event: ChromeRecordedEvent) => {\r\n    const state = get();\r\n    const newEvents = [...state.events, event];\r\n    set({ events: newEvents });\r\n    if (state.isRecording) {\r\n      const sessionId = useRecordingSessionStore.getState().currentSessionId;\r\n      if (sessionId) {\r\n        await dbManager.updateSession(sessionId, {\r\n          events: newEvents,\r\n          updatedAt: Date.now(),\r\n        });\r\n      }\r\n      await saveEventsToStorage(newEvents);\r\n    }\r\n  },\r\n  updateEvent: async (event: ChromeRecordedEvent) => {\r\n    const state = get();\r\n    const newEvents = mergeEvents(state.events, [event]);\r\n    set({ events: newEvents });\r\n    if (state.isRecording) {\r\n      const sessionId = useRecordingSessionStore.getState().currentSessionId;\r\n      if (sessionId) {\r\n        await dbManager.updateSession(sessionId, {\r\n          events: newEvents,\r\n          updatedAt: Date.now(),\r\n        });\r\n      }\r\n    }\r\n  },\r\n  setEvents: async (events: ChromeRecordedEvent[]) => {\r\n    const state = get();\r\n    const newEvents = mergeEvents(state.events, events);\r\n    set({ events: newEvents });\r\n    recordLogger.info('Setting events', {\r\n      events: newEvents,\r\n      newEvents,\r\n      eventsCount: newEvents.length,\r\n    });\r\n    if (state.isRecording) {\r\n      const sessionId = useRecordingSessionStore.getState().currentSessionId;\r\n      if (sessionId) {\r\n        await dbManager.updateSession(sessionId, {\r\n          events: newEvents,\r\n          updatedAt: Date.now(),\r\n        });\r\n      }\r\n    }\r\n  },\r\n  clearEvents: async () => {\r\n    await clearEventsFromStorage();\r\n    const sessionId = useRecordingSessionStore.getState().currentSessionId;\r\n    if (sessionId) {\r\n      // Get current session\r\n      const currentSession = useRecordingSessionStore\r\n        .getState()\r\n        .sessions.find((s) => s.id === sessionId);\r\n      await dbManager.updateSession(sessionId, {\r\n        events: [],\r\n        updatedAt: Date.now(),\r\n        // Clear generatedCode as well\r\n        generatedCode: undefined,\r\n      });\r\n    }\r\n    set({ events: [] });\r\n  },\r\n  emergencySaveEvents: async (events?: ChromeRecordedEvent[]) => {\r\n    const state = get();\r\n    const eventsToSave = events || state.events;\r\n    if (eventsToSave.length > 0) {\r\n      try {\r\n        await dbManager.emergencySetRecordingEvents(eventsToSave);\r\n      } catch (error) {\r\n        console.error('Emergency save failed:', error);\r\n      }\r\n    }\r\n  },\r\n}));\r\n\r\nconst CONFIG_KEY = 'midscene-env-config';\r\n\r\n/**\r\n * Service Mode\r\n *\r\n * - Server: use a node server to run the code\r\n * - In-Browser: use browser's fetch API to run the code\r\n * - In-Browser-Extension: use browser's fetch API to run the code, but the page is running in the extension context\r\n */\r\nexport type ServiceModeType = 'Server' | 'In-Browser' | 'In-Browser-Extension'; // | 'Extension';\r\n","import { jsx, jsxs } from \"react/jsx-runtime\";\nimport { AimOutlined, CompassOutlined, CopyOutlined, EditOutlined, KeyOutlined, VerticalAlignTopOutlined } from \"@ant-design/icons\";\nimport { Button, Card, Image, Space, Timeline, Typography, message } from \"antd\";\nimport { useEffect, useState } from \"react\";\nimport { ShinyText } from \"./components/shiny-text.js\";\nimport \"./RecordTimeline.css\";\nconst { Text } = Typography;\nconst RecordTimeline = ({ events, onEventClick })=>{\n    const [expandedEvents, setExpandedEvents] = useState(new Set());\n    console.log('events', events);\n    useEffect(()=>{\n        if (events.length > 0) {\n            const timeline = document.querySelector('.ant-timeline');\n            if (timeline) timeline.scrollIntoView({\n                behavior: 'smooth',\n                block: 'end'\n            });\n        }\n    }, [\n        events.length\n    ]);\n    const toggleEventExpansion = (index)=>{\n        const newExpanded = new Set(expandedEvents);\n        if (newExpanded.has(index)) newExpanded.delete(index);\n        else newExpanded.add(index);\n        setExpandedEvents(newExpanded);\n    };\n    const truncateJsonStrings = (obj, maxLength = 30)=>{\n        if ('string' == typeof obj) return obj.length > maxLength ? `${obj.substring(0, maxLength)}...` : obj;\n        if (Array.isArray(obj)) return obj.map((item)=>truncateJsonStrings(item, maxLength));\n        if (obj && 'object' == typeof obj) {\n            const truncated = {};\n            for(const key in obj)if (Object.prototype.hasOwnProperty.call(obj, key)) truncated[key] = truncateJsonStrings(obj[key], maxLength);\n            return truncated;\n        }\n        return obj;\n    };\n    const copyToClipboard = (text)=>{\n        navigator.clipboard.writeText(text).then(()=>{\n            message.success('JSON copied to clipboard');\n        }).catch(()=>{\n            message.error('Copy failed');\n        });\n    };\n    const getEventIcon = (type)=>{\n        switch(type){\n            case 'click':\n                return /*#__PURE__*/ jsx(AimOutlined, {\n                    style: {\n                        color: '#1890ff'\n                    }\n                });\n            case 'input':\n                return /*#__PURE__*/ jsx(EditOutlined, {\n                    style: {\n                        color: '#52c41a'\n                    }\n                });\n            case 'scroll':\n                return /*#__PURE__*/ jsx(VerticalAlignTopOutlined, {\n                    style: {\n                        color: '#faad14'\n                    }\n                });\n            case 'navigation':\n                return /*#__PURE__*/ jsx(CompassOutlined, {\n                    style: {\n                        color: '#722ed1'\n                    }\n                });\n            case 'setViewport':\n                return /*#__PURE__*/ jsx(CompassOutlined, {\n                    style: {\n                        color: '#eb2f96'\n                    }\n                });\n            case 'keydown':\n                return /*#__PURE__*/ jsx(KeyOutlined, {\n                    style: {\n                        color: '#fa8c16'\n                    }\n                });\n            default:\n                return /*#__PURE__*/ jsx(AimOutlined, {\n                    style: {\n                        color: '#d9d9d9'\n                    }\n                });\n        }\n    };\n    const getEventColor = (type)=>{\n        switch(type){\n            case 'click':\n                return '#1890ff';\n            case 'input':\n                return '#52c41a';\n            case 'scroll':\n                return '#faad14';\n            case 'navigation':\n                return '#722ed1';\n            case 'setViewport':\n                return '#eb2f96';\n            case 'keydown':\n                return '#fa8c16';\n            default:\n                return '#d9d9d9';\n        }\n    };\n    const getEventTitle = (event)=>{\n        switch(event.type){\n            case 'click':\n                if ('BUTTON' === event.targetTagName) return 'Click Button';\n                if (event.value) return `Click Element \"${event.value}\"`;\n                return 'Click';\n            case 'input':\n                return 'Input';\n            case 'scroll':\n                return 'Scroll';\n            case 'navigation':\n                return 'Navigate';\n            case 'setViewport':\n                return 'Set viewport';\n            case 'keydown':\n                return 'Key down';\n            default:\n                return event.type;\n        }\n    };\n    const getEventDescription = (event)=>{\n        const eventTitle = getEventTitle(event);\n        switch(event.type){\n            case 'click':\n                if (true === event.descriptionLoading && event.elementRect?.x !== void 0 && event.elementRect?.y !== void 0) return /*#__PURE__*/ jsxs(\"span\", {\n                    style: {\n                        display: 'flex',\n                        alignItems: 'center',\n                        gap: '4px'\n                    },\n                    children: [\n                        /*#__PURE__*/ jsxs(Text, {\n                            children: [\n                                eventTitle,\n                                \" - \"\n                            ]\n                        }),\n                        /*#__PURE__*/ jsx(ShinyText, {\n                            text: `(${event.elementRect.x}, ${event.elementRect.y})`,\n                            disabled: false,\n                            speed: 3,\n                            className: \"step-title-shiny\"\n                        })\n                    ]\n                });\n                if (false === event.descriptionLoading && event.elementDescription) return /*#__PURE__*/ jsxs(Text, {\n                    className: \"\",\n                    children: [\n                        eventTitle,\n                        \" - \",\n                        event.elementDescription\n                    ]\n                });\n                return /*#__PURE__*/ jsx(Text, {\n                    children: eventTitle\n                });\n            case 'input':\n                if (false === event.descriptionLoading && event.elementDescription) return /*#__PURE__*/ jsxs(Text, {\n                    children: [\n                        eventTitle,\n                        \" - \",\n                        event.elementDescription\n                    ]\n                });\n                return /*#__PURE__*/ jsxs(\"span\", {\n                    style: {\n                        display: 'flex',\n                        alignItems: 'center',\n                        gap: '4px'\n                    },\n                    children: [\n                        /*#__PURE__*/ jsxs(Text, {\n                            children: [\n                                eventTitle,\n                                \" - \"\n                            ]\n                        }),\n                        /*#__PURE__*/ jsx(ShinyText, {\n                            text: event.value ? `\"${event.value}\"` : '',\n                            disabled: false,\n                            speed: 3,\n                            className: \"step-title-shiny\"\n                        })\n                    ]\n                });\n            case 'scroll':\n                if (event.elementDescription) return /*#__PURE__*/ jsxs(Text, {\n                    children: [\n                        eventTitle,\n                        \" - \",\n                        event.value?.split(' ')[0] || ''\n                    ]\n                });\n                return /*#__PURE__*/ jsxs(Text, {\n                    children: [\n                        eventTitle,\n                        \" - Position: (\",\n                        event.elementRect?.x || 0,\n                        \",\",\n                        ' ',\n                        event.elementRect?.y || 0,\n                        \")\"\n                    ]\n                });\n            case 'navigation':\n                {\n                    const truncatedUrl = event.url && event.url.length > 50 ? `${event.url.substring(0, 50)}...` : event.url;\n                    return /*#__PURE__*/ jsxs(Text, {\n                        children: [\n                            eventTitle,\n                            \" - \",\n                            truncatedUrl\n                        ]\n                    });\n                }\n            case 'setViewport':\n                return /*#__PURE__*/ jsxs(Text, {\n                    children: [\n                        eventTitle,\n                        \" - Desktop 964x992 px\"\n                    ]\n                });\n            case 'keydown':\n                return /*#__PURE__*/ jsxs(Text, {\n                    children: [\n                        eventTitle,\n                        \" - Key: \",\n                        event.value || 'Unknown'\n                    ]\n                });\n            default:\n                return /*#__PURE__*/ jsx(Text, {\n                    children: eventTitle\n                });\n        }\n    };\n    const timelineItems = events.map((event, index)=>{\n        const boxedImage = event.screenshotWithBox;\n        const afterImage = event.screenshotAfter;\n        const isExpanded = expandedEvents.has(index);\n        return {\n            dot: getEventIcon(event.type),\n            color: getEventColor(event.type),\n            children: /*#__PURE__*/ jsx(\"div\", {\n                children: /*#__PURE__*/ jsxs(Card, {\n                    size: \"small\",\n                    bordered: false,\n                    style: {\n                        marginBottom: isExpanded ? 8 : 8,\n                        cursor: 'pointer'\n                    },\n                    onClick: ()=>{\n                        toggleEventExpansion(index);\n                        onEventClick?.(event, index);\n                    },\n                    styles: {\n                        body: {\n                            padding: '8px 12px',\n                            backgroundColor: '#F2F4F7',\n                            borderRadius: '8px'\n                        }\n                    },\n                    children: [\n                        /*#__PURE__*/ jsxs(Space, {\n                            style: {\n                                width: '100%',\n                                justifyContent: 'space-between',\n                                alignItems: 'center',\n                                color: 'rgba(0, 0, 0, 0.85)'\n                            },\n                            children: [\n                                /*#__PURE__*/ jsx(Space, {\n                                    style: {\n                                        flex: 1,\n                                        minWidth: 0\n                                    },\n                                    children: getEventDescription(event)\n                                }),\n                                /*#__PURE__*/ jsx(Space, {\n                                    children: (boxedImage || afterImage) && /*#__PURE__*/ jsxs(\"div\", {\n                                        style: {\n                                            display: 'flex',\n                                            alignItems: 'center'\n                                        },\n                                        children: [\n                                            boxedImage && /*#__PURE__*/ jsx(\"div\", {\n                                                style: {\n                                                    width: '24px',\n                                                    height: '24px',\n                                                    borderRadius: '4px',\n                                                    overflow: 'hidden',\n                                                    boxShadow: '1px 1px 1px 1px #00000014',\n                                                    cursor: 'pointer',\n                                                    transition: 'all 0.2s ease-in-out',\n                                                    zIndex: 2\n                                                },\n                                                onMouseEnter: (e)=>{\n                                                    const target = e.currentTarget;\n                                                    target.style.transform = 'scale(1.2)';\n                                                    target.style.boxShadow = `0 2px 8px ${getEventColor(event.type)}60`;\n                                                },\n                                                onMouseLeave: (e)=>{\n                                                    const target = e.currentTarget;\n                                                    target.style.transform = 'scale(1)';\n                                                    target.style.boxShadow = '1px 1px 1px 1px #00000014';\n                                                },\n                                                onClick: (e)=>{\n                                                    e.stopPropagation();\n                                                },\n                                                children: /*#__PURE__*/ jsx(Image, {\n                                                    src: boxedImage,\n                                                    width: \"100%\",\n                                                    height: \"100%\",\n                                                    style: {\n                                                        objectFit: 'cover',\n                                                        display: 'block'\n                                                    },\n                                                    preview: {\n                                                        mask: false\n                                                    }\n                                                })\n                                            }),\n                                            afterImage && /*#__PURE__*/ jsx(\"div\", {\n                                                style: {\n                                                    width: '24px',\n                                                    height: '24px',\n                                                    borderRadius: '4px',\n                                                    overflow: 'hidden',\n                                                    boxShadow: '1px 1px 1px 1px #00000014',\n                                                    cursor: 'pointer',\n                                                    transition: 'all 0.2s ease-in-out',\n                                                    marginLeft: boxedImage ? '-8px' : '0',\n                                                    zIndex: 1\n                                                },\n                                                onMouseEnter: (e)=>{\n                                                    const target = e.currentTarget;\n                                                    target.style.transform = 'scale(1.2)';\n                                                    target.style.boxShadow = '0 2px 8px #52c41a60';\n                                                },\n                                                onMouseLeave: (e)=>{\n                                                    const target = e.currentTarget;\n                                                    target.style.transform = 'scale(1)';\n                                                    target.style.boxShadow = '1px 1px 1px 1px #00000014';\n                                                },\n                                                onClick: (e)=>{\n                                                    e.stopPropagation();\n                                                },\n                                                children: /*#__PURE__*/ jsx(Image, {\n                                                    src: afterImage,\n                                                    width: \"100%\",\n                                                    height: \"100%\",\n                                                    style: {\n                                                        objectFit: 'cover',\n                                                        display: 'block'\n                                                    },\n                                                    preview: {\n                                                        mask: false\n                                                    }\n                                                })\n                                            })\n                                        ]\n                                    })\n                                })\n                            ]\n                        }),\n                        isExpanded && /*#__PURE__*/ jsx(\"div\", {\n                            style: {\n                                marginTop: 8,\n                                marginBottom: 8\n                            },\n                            children: /*#__PURE__*/ jsx(Card, {\n                                size: \"small\",\n                                style: {\n                                    backgroundColor: '#f5f5f5'\n                                },\n                                bodyStyle: {\n                                    padding: '0px'\n                                },\n                                children: /*#__PURE__*/ jsxs(\"div\", {\n                                    style: {\n                                        position: 'relative'\n                                    },\n                                    children: [\n                                        /*#__PURE__*/ jsx(\"pre\", {\n                                            style: {\n                                                fontSize: '12px',\n                                                margin: 0,\n                                                whiteSpace: 'pre-wrap',\n                                                backgroundColor: '#ffffff',\n                                                padding: '12px',\n                                                borderRadius: '8px',\n                                                maxHeight: '250px',\n                                                overflow: 'auto'\n                                            },\n                                            children: JSON.stringify(truncateJsonStrings(event), null, 2)\n                                        }),\n                                        /*#__PURE__*/ jsx(Button, {\n                                            type: \"text\",\n                                            size: \"small\",\n                                            icon: /*#__PURE__*/ jsx(CopyOutlined, {}),\n                                            onClick: (e)=>{\n                                                e.stopPropagation();\n                                                copyToClipboard(JSON.stringify(event, null, 2));\n                                            },\n                                            style: {\n                                                position: 'absolute',\n                                                top: '8px',\n                                                right: '8px',\n                                                background: 'rgba(255, 255, 255, 0.9)',\n                                                border: '1px solid #d9d9d9'\n                                            },\n                                            title: \"Copy JSON\"\n                                        })\n                                    ]\n                                })\n                            })\n                        })\n                    ]\n                })\n            })\n        };\n    });\n    return /*#__PURE__*/ jsx(\"div\", {\n        style: {\n            padding: '3px'\n        },\n        children: /*#__PURE__*/ jsx(Space, {\n            direction: \"vertical\",\n            size: \"large\",\n            style: {\n                width: '100%'\n            },\n            children: /*#__PURE__*/ jsx(Timeline, {\n                mode: \"left\",\n                className: \"timeline-scrollable\",\n                items: timelineItems,\n                style: {\n                    paddingTop: 16\n                }\n            })\n        })\n    });\n};\nexport { RecordTimeline };\n","import { DownOutlined } from '@ant-design/icons';\r\nimport { Typography } from 'antd';\r\nimport type React from 'react';\r\nimport { useEffect, useRef, useState } from 'react';\r\n\r\nconst { Text } = Typography;\r\n\r\ninterface ThinkingProcessSectionProps {\r\n  accumulatedThinking: string;\r\n  isStreaming: boolean;\r\n  actualCode: string;\r\n  themeColor?: 'blue' | 'green';\r\n}\r\n\r\nexport const ThinkingProcessSection: React.FC<ThinkingProcessSectionProps> = ({\r\n  accumulatedThinking,\r\n  isStreaming,\r\n  actualCode,\r\n  themeColor = 'blue',\r\n}) => {\r\n  const [showThinking, setShowThinking] = useState(true);\r\n  const hasThinking = accumulatedThinking.length > 0;\r\n  const contentRef = useRef<HTMLDivElement>(null);\r\n\r\n  // Detect if thinking process has ended - when actual code content appears, thinking is finished\r\n  useEffect(() => {\r\n    if (actualCode) {\r\n      // Actual code content appeared, thinking process has ended, collapse immediately\r\n      setShowThinking(false);\r\n    } else {\r\n      setShowThinking(true);\r\n    }\r\n  }, [actualCode]);\r\n\r\n  // scroll to latest thinking content\r\n  useEffect(() => {\r\n    if (showThinking && contentRef.current) {\r\n      contentRef.current.scrollTop = contentRef.current.scrollHeight;\r\n    }\r\n  }, [accumulatedThinking, showThinking]);\r\n\r\n  if (!hasThinking) return null;\r\n\r\n  return accumulatedThinking ? (\r\n    <div\r\n      className=\"rounded-[8px] min-h-[40px] mb-4\"\r\n      style={{\r\n        background: showThinking\r\n          ? 'linear-gradient(180deg, rgba(43, 131, 255, 0.1) 0%, rgba(43, 131, 255, 0.024) 23.04%, rgba(43, 131, 255, 0) 100%)'\r\n          : 'linear-gradient(0deg, #FFFFFF, #FFFFFF)',\r\n        border: showThinking\r\n          ? '1px solid rgba(43, 131, 255, 0.16)'\r\n          : '1px solid rgba(0, 0, 0, 0.06)',\r\n      }}\r\n    >\r\n      <div\r\n        className={'flex items-center gap-2 cursor-pointer p-2 bg-transparent'}\r\n        onClick={() => setShowThinking(!showThinking)}\r\n        // style={{ borderBottom: showThinking ? '1px solid rgba(43, 131, 255, 0.16)' : 'none' }}\r\n      >\r\n        <div\r\n          className={' text-sm font-medium '}\r\n          style={{ color: 'rgba(0, 0, 0, 0.85)' }}\r\n        >\r\n           AI Thingking Process\r\n        </div>\r\n        <div\r\n          className={`transform transition-transform ml-auto mr-1 ${showThinking ? 'rotate-180' : ''}`}\r\n        >\r\n          <DownOutlined\r\n            className={'text-blue-400 text-xs'}\r\n            style={{ color: 'rgba(128, 128, 128, 1)' }}\r\n          />\r\n        </div>\r\n      </div>\r\n      {showThinking && (\r\n        <div\r\n          ref={contentRef}\r\n          className={\r\n            'p-3 bg-blue-25 max-h-[139px]  rounded-b text-sm text-gray-400 whitespace-pre-wrap'\r\n          }\r\n          style={{ overflowY: 'auto' }}\r\n        >\r\n          {accumulatedThinking ||\r\n            'AI is analyzing the recorded events and planning the test structure...'}\r\n        </div>\r\n      )}\r\n    </div>\r\n  ) : null;\r\n};\r\n","import {\r\n  CopyOutlined,\r\n  DownloadOutlined,\r\n  FileTextOutlined,\r\n  ReloadOutlined,\r\n} from '@ant-design/icons';\r\nimport { Button, Typography } from 'antd';\r\nimport type React from 'react';\r\nimport { useEffect, useRef } from 'react';\r\nimport { ThinkingProcessSection } from './ThinkingProcessSection';\r\nimport { triggerConfetti } from './confetti';\r\nimport './CodeBlock.css';\r\n//@ts-ignore\r\nimport Highlight from 'react-highlight';\r\n\r\nimport 'highlight.js/styles/github.css';\r\n\r\nconst { Text } = Typography;\r\n\r\ninterface CodeBlockProps {\r\n  type: 'yaml' | 'playwright';\r\n  code: string;\r\n\r\n  loading: boolean;\r\n  onCopy?: () => void;\r\n  onDownload?: () => void;\r\n  onRegenerate?: () => void;\r\n  stepDisplay: boolean;\r\n  isStreaming?: boolean;\r\n  streamingContent?: string;\r\n  thinkingProcess?: string;\r\n  actualCode?: string;\r\n  accumulatedThinking?: string;\r\n}\r\n\r\nfunction CodeBlockContainer({\r\n  language,\r\n  code,\r\n  accumulatedThinking,\r\n}: {\r\n  language: 'yaml' | 'javascript';\r\n  code: string;\r\n  accumulatedThinking?: string;\r\n  isStreaming: boolean;\r\n}) {\r\n  return (\r\n    <pre\r\n      className={`bg-gray-50 rounded-[8px] border text-sm overflow-auto font-mono border-radius-[8px] border-[#F2F4F7] ${accumulatedThinking ? 'max-h-[calc(100vh-380px)]' : 'max-h-[calc(100vh-340px)]'} !mt-0 !p-0`}\r\n    >\r\n      <Highlight className={`language-${language} !mt-0`}>{code}</Highlight>\r\n    </pre>\r\n  );\r\n}\r\n\r\nexport const CodeBlock: React.FC<CodeBlockProps> = ({\r\n  type,\r\n  code,\r\n  isStreaming = false,\r\n  streamingContent = '',\r\n  actualCode = '',\r\n  accumulatedThinking = '',\r\n  stepDisplay,\r\n}) => {\r\n  let displayContent = isStreaming ? actualCode || streamingContent : code;\r\n  displayContent = displayContent\r\n    .replace(/```typescript/g, '')\r\n    .replace(/```/g, '')\r\n    .trim();\r\n  const hasContent = displayContent.length > 0;\r\n  const wasStreamingRef = useRef(false);\r\n\r\n  // Monitor code generation completion, trigger confetti effect\r\n  useEffect(() => {\r\n    // If it was streaming before, now stopped, and has code content, trigger confetti effect\r\n    if (wasStreamingRef.current && !isStreaming && hasContent) {\r\n      triggerConfetti();\r\n    }\r\n    wasStreamingRef.current = isStreaming;\r\n  }, [isStreaming, hasContent]);\r\n\r\n  return (\r\n    <div className=\"flex flex-col mt-5\">\r\n      {/* Thinking Process Section */}\r\n      <ThinkingProcessSection\r\n        accumulatedThinking={accumulatedThinking}\r\n        isStreaming={isStreaming}\r\n        actualCode={actualCode}\r\n        themeColor=\"green\"\r\n      />\r\n      {stepDisplay && (\r\n        <div className=\"relative flex-1\">\r\n          {!displayContent && isStreaming && (\r\n            <pre\r\n              // {(<pre\r\n              className={\r\n                'relative bg-gray-50 rounded-[8px] border text-sm overflow-auto max-h-128 font-mono border-radius-[8px] p-4 border-[#F2F4F7]'\r\n              }\r\n            >\r\n              <code>Generating code...</code>\r\n\r\n              <div className=\"absolute bottom-3 right-2 bg-[#2B83FF1F] text-[#2B83FF] px-2 py-1 rounded-full text-xs\">\r\n                Analyzing...\r\n              </div>\r\n            </pre>\r\n          )}\r\n\r\n          {displayContent && (\r\n            <CodeBlockContainer\r\n              accumulatedThinking={accumulatedThinking}\r\n              language={type === 'playwright' ? 'javascript' : 'yaml'}\r\n              code={displayContent}\r\n              isStreaming={isStreaming}\r\n            />\r\n          )}\r\n        </div>\r\n      )}\r\n\r\n      {code && (\r\n        <div className=\"mt-3 text-center\">\r\n          <Text type=\"secondary\" className=\"text-xs\">\r\n            {type === 'playwright' ? (\r\n              <>\r\n                 Learn how to integrate Playwright with SQAI.js\r\n                <a\r\n                  target=\"_blank\"\r\n                  href=\"https://sqai.tech/integrate-with-playwright.html\"\r\n                  rel=\"noreferrer\"\r\n                >\r\n                  {' '}\r\n                  here\r\n                </a>\r\n                .\r\n              </>\r\n            ) : (\r\n              <>\r\n                 Learn how to integrate YAML scripts with SQAI.js\r\n                <a\r\n                  target=\"_blank\"\r\n                  href=\"https://sqai.tech/automate-with-scripts-in-yaml.html\"\r\n                  rel=\"noreferrer\"\r\n                >\r\n                  {' '}\r\n                  here\r\n                </a>\r\n                .\r\n              </>\r\n            )}\r\n          </Text>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n","import { CheckCircleOutlined, LoadingOutlined } from '@ant-design/icons';\r\nimport { ShinyText } from '@sqaitech/visualizer';\r\nimport { Progress, Typography } from 'antd';\r\nimport type React from 'react';\r\nimport type { ProgressStep } from '../ProgressModal';\r\n\r\nconst { Text } = Typography;\r\n\r\ninterface StepListProps {\r\n  steps: ProgressStep[];\r\n  completedSteps: Set<string>;\r\n  slidingOutSteps: Set<string>;\r\n  getStepIcon: (step: ProgressStep) => React.ReactNode;\r\n  getStepColor: (step: ProgressStep) => string;\r\n}\r\n\r\nexport const StepList: React.FC<StepListProps> = ({\r\n  steps,\r\n  completedSteps,\r\n  slidingOutSteps,\r\n  getStepIcon,\r\n  getStepColor,\r\n}) => {\r\n  return (\r\n    <div className=\"py-5\">\r\n      {steps.map((step, index, filteredSteps) => {\r\n        const isSliding = slidingOutSteps.has(step.id);\r\n        return (\r\n          <div key={step.id}>\r\n            <div className=\"flex items-center mb-2\">\r\n              <div className=\"mr-3 min-w-[20px]\">{getStepIcon(step)}</div>\r\n              <div className=\"flex-1 border border-[rgba(0,0,0,0.06)] p-[12px] rounded-[12px]\">\r\n                {step.status === 'loading' ? (\r\n                  <div className=\"font-semibold text-[14px] leading-[22px] min-h-[22px] flex items-center\">\r\n                    <ShinyText\r\n                      text={step.title}\r\n                      disabled={false}\r\n                      speed={3}\r\n                      // className=\"step-title-shiny\"\r\n                    />\r\n                  </div>\r\n                ) : (\r\n                  <div>\r\n                    <Text\r\n                      strong\r\n                      className=\"!text-[rgba(0,0,0,1)] text-[14px]\"\r\n                      style={{\r\n                        color:\r\n                          step.status === 'completed' ? '#52c41a' : undefined,\r\n                        lineHeight: '22px',\r\n                        minHeight: '22px',\r\n                        display: 'inline-flex',\r\n                        alignItems: 'center',\r\n                      }}\r\n                    >\r\n                      {step.title}\r\n                    </Text>\r\n                  </div>\r\n                )}\r\n                <Text type=\"secondary\" className=\"text-xs text-[12px]\">\r\n                  {step.description}\r\n                </Text>\r\n                {step.details && (\r\n                  <>\r\n                    <br />\r\n                    <Text className=\"text-[11px] !text-[rgba(0, 0, 0, 0.9)]\">\r\n                      {step.details}\r\n                    </Text>\r\n                  </>\r\n                )}\r\n              </div>\r\n            </div>\r\n            {/* {step.status === 'loading' && step.progress !== undefined && (\r\n              <div className=\"ml-8\">\r\n                <Progress\r\n                  percent={step.progress}\r\n                  size=\"small\"\r\n                  strokeColor={getStepColor(step)}\r\n                  showInfo={false}\r\n                />\r\n              </div>\r\n            )} */}\r\n            {index < filteredSteps.length - 1 && (\r\n              <div\r\n                className={`${step.status === 'completed' ? 'bg-green-500' : 'bg-gray-200'} ml-2 w-0.5 h-5 mt-2`}\r\n              />\r\n            )}\r\n          </div>\r\n        );\r\n      })}\r\n    </div>\r\n  );\r\n};\r\n","import { Agent } from \"@sqaitech/core/agent\";\nclass ChromeExtensionProxyPageAgent extends Agent {\n    constructor(page, opts){\n        super(page, opts);\n    }\n}\nexport { ChromeExtensionProxyPageAgent };\n\n//# sourceMappingURL=agent.mjs.map","import { AIResponseFormat } from \"../../types.mjs\";\nimport { Anthropic } from \"@anthropic-ai/sdk\";\nimport { DefaultAzureCredential, getBearerTokenProvider } from \"@azure/identity\";\nimport { OPENAI_MAX_TOKENS, SQAI_API_TYPE, SQAI_LANGSMITH_DEBUG, globalConfigManager } from \"@sqaitech/shared/env\";\nimport { parseBase64 } from \"@sqaitech/shared/img\";\nimport { getDebug } from \"@sqaitech/shared/logger\";\nimport { assert, ifInBrowser } from \"@sqaitech/shared/utils\";\nimport { HttpsProxyAgent } from \"https-proxy-agent\";\nimport { jsonrepair } from \"jsonrepair\";\nimport openai_0, { AzureOpenAI } from \"openai\";\nimport { SocksProxyAgent } from \"socks-proxy-agent\";\nimport { AIActionType } from \"../common.mjs\";\nimport { assertSchema } from \"../prompt/assertion.mjs\";\nimport { locatorSchema } from \"../prompt/llm-locator.mjs\";\nimport { planSchema } from \"../prompt/llm-planning.mjs\";\nasync function createChatClient({ AIActionTypeValue, modelConfig }) {\n    const { socksProxy, httpProxy, modelName, openaiBaseURL, openaiApiKey, openaiExtraConfig, openaiUseAzureDeprecated, useAzureOpenai, azureOpenaiScope, azureOpenaiKey, azureOpenaiEndpoint, azureOpenaiApiVersion, azureOpenaiDeployment, azureExtraConfig, useAnthropicSdk, anthropicApiKey, modelDescription, uiTarsModelVersion: uiTarsVersion, vlMode } = modelConfig;\n    let openai;\n    let proxyAgent;\n    const debugProxy = getDebug('ai:call:proxy');\n    if (httpProxy) {\n        debugProxy('using http proxy', httpProxy);\n        proxyAgent = new HttpsProxyAgent(httpProxy);\n    } else if (socksProxy) {\n        debugProxy('using socks proxy', socksProxy);\n        proxyAgent = new SocksProxyAgent(socksProxy);\n    }\n    if (openaiUseAzureDeprecated) openai = new AzureOpenAI({\n        baseURL: openaiBaseURL,\n        apiKey: openaiApiKey,\n        httpAgent: proxyAgent,\n        ...openaiExtraConfig,\n        dangerouslyAllowBrowser: true\n    });\n    else if (useAzureOpenai) {\n        let tokenProvider;\n        if (azureOpenaiScope) {\n            assert(!ifInBrowser, 'Azure OpenAI is not supported in browser with Midscene.');\n            const credential = new DefaultAzureCredential();\n            tokenProvider = getBearerTokenProvider(credential, azureOpenaiScope);\n            openai = new AzureOpenAI({\n                azureADTokenProvider: tokenProvider,\n                endpoint: azureOpenaiEndpoint,\n                apiVersion: azureOpenaiApiVersion,\n                deployment: azureOpenaiDeployment,\n                ...openaiExtraConfig,\n                ...azureExtraConfig\n            });\n        } else openai = new AzureOpenAI({\n            apiKey: azureOpenaiKey,\n            endpoint: azureOpenaiEndpoint,\n            apiVersion: azureOpenaiApiVersion,\n            deployment: azureOpenaiDeployment,\n            dangerouslyAllowBrowser: true,\n            ...openaiExtraConfig,\n            ...azureExtraConfig\n        });\n    } else if (!useAnthropicSdk) openai = new openai_0({\n        baseURL: openaiBaseURL,\n        apiKey: openaiApiKey,\n        httpAgent: proxyAgent,\n        ...openaiExtraConfig,\n        defaultHeaders: {\n            ...(null == openaiExtraConfig ? void 0 : openaiExtraConfig.defaultHeaders) || {},\n            [SQAI_API_TYPE]: AIActionTypeValue.toString()\n        },\n        dangerouslyAllowBrowser: true\n    });\n    if (openai && globalConfigManager.getEnvConfigInBoolean(SQAI_LANGSMITH_DEBUG)) {\n        if (ifInBrowser) throw new Error('langsmith is not supported in browser');\n        console.log('DEBUGGING MODE: langsmith wrapper enabled');\n        const { wrapOpenAI } = await import(\"langsmith/wrappers\");\n        openai = wrapOpenAI(openai);\n    }\n    if (void 0 !== openai) return {\n        completion: openai.chat.completions,\n        style: 'openai',\n        modelName,\n        modelDescription,\n        uiTarsVersion,\n        vlMode\n    };\n    if (useAnthropicSdk) openai = new Anthropic({\n        apiKey: anthropicApiKey,\n        httpAgent: proxyAgent,\n        dangerouslyAllowBrowser: true\n    });\n    if (void 0 !== openai && openai.messages) return {\n        completion: openai.messages,\n        style: 'anthropic',\n        modelName,\n        modelDescription,\n        uiTarsVersion,\n        vlMode\n    };\n    throw new Error('Openai SDK or Anthropic SDK is not initialized');\n}\nasync function callAI(messages, AIActionTypeValue, modelConfig, options) {\n    const { completion, style, modelName, modelDescription, uiTarsVersion, vlMode } = await createChatClient({\n        AIActionTypeValue,\n        modelConfig\n    });\n    const responseFormat = getResponseFormat(modelName, AIActionTypeValue);\n    const maxTokens = globalConfigManager.getEnvConfigValue(OPENAI_MAX_TOKENS);\n    const debugCall = getDebug('ai:call');\n    const debugProfileStats = getDebug('ai:profile:stats');\n    const debugProfileDetail = getDebug('ai:profile:detail');\n    const startTime = Date.now();\n    const isStreaming = (null == options ? void 0 : options.stream) && (null == options ? void 0 : options.onChunk);\n    let content;\n    let accumulated = '';\n    let usage;\n    let timeCost;\n    const commonConfig = {\n        temperature: 'vlm-ui-tars' === vlMode ? 0.0 : 0.1,\n        stream: !!isStreaming,\n        max_tokens: 'number' == typeof maxTokens ? maxTokens : Number.parseInt(maxTokens || '2048', 10),\n        ...'qwen-vl' === vlMode || 'qwen3-vl' === vlMode ? {\n            vl_high_resolution_images: true\n        } : {}\n    };\n    try {\n        if ('openai' === style) {\n            debugCall(`sending ${isStreaming ? 'streaming ' : ''}request to ${modelName}`);\n            if (isStreaming) {\n                const stream = await completion.create({\n                    model: modelName,\n                    messages,\n                    response_format: responseFormat,\n                    ...commonConfig\n                }, {\n                    stream: true\n                });\n                for await (const chunk of stream){\n                    var _chunk_choices__delta, _chunk_choices_, _chunk_choices, _chunk_choices__delta1, _chunk_choices_1, _chunk_choices1, _chunk_choices_2, _chunk_choices2;\n                    const content = (null == (_chunk_choices = chunk.choices) ? void 0 : null == (_chunk_choices_ = _chunk_choices[0]) ? void 0 : null == (_chunk_choices__delta = _chunk_choices_.delta) ? void 0 : _chunk_choices__delta.content) || '';\n                    const reasoning_content = (null == (_chunk_choices1 = chunk.choices) ? void 0 : null == (_chunk_choices_1 = _chunk_choices1[0]) ? void 0 : null == (_chunk_choices__delta1 = _chunk_choices_1.delta) ? void 0 : _chunk_choices__delta1.reasoning_content) || '';\n                    if (chunk.usage) usage = chunk.usage;\n                    if (content || reasoning_content) {\n                        accumulated += content;\n                        const chunkData = {\n                            content,\n                            reasoning_content,\n                            accumulated,\n                            isComplete: false,\n                            usage: void 0\n                        };\n                        options.onChunk(chunkData);\n                    }\n                    if (null == (_chunk_choices2 = chunk.choices) ? void 0 : null == (_chunk_choices_2 = _chunk_choices2[0]) ? void 0 : _chunk_choices_2.finish_reason) {\n                        timeCost = Date.now() - startTime;\n                        if (!usage) {\n                            const estimatedTokens = Math.max(1, Math.floor(accumulated.length / 4));\n                            usage = {\n                                prompt_tokens: estimatedTokens,\n                                completion_tokens: estimatedTokens,\n                                total_tokens: 2 * estimatedTokens\n                            };\n                        }\n                        const finalChunk = {\n                            content: '',\n                            accumulated,\n                            reasoning_content: '',\n                            isComplete: true,\n                            usage: {\n                                prompt_tokens: usage.prompt_tokens ?? 0,\n                                completion_tokens: usage.completion_tokens ?? 0,\n                                total_tokens: usage.total_tokens ?? 0,\n                                time_cost: timeCost ?? 0,\n                                model_name: modelName,\n                                model_description: modelDescription,\n                                intent: modelConfig.intent\n                            }\n                        };\n                        options.onChunk(finalChunk);\n                        break;\n                    }\n                }\n                content = accumulated;\n                debugProfileStats(`streaming model, ${modelName}, mode, ${vlMode || 'default'}, cost-ms, ${timeCost}`);\n            } else {\n                var _result_usage, _result_usage1, _result_usage2;\n                const result = await completion.create({\n                    model: modelName,\n                    messages,\n                    response_format: responseFormat,\n                    ...commonConfig\n                });\n                timeCost = Date.now() - startTime;\n                debugProfileStats(`model, ${modelName}, mode, ${vlMode || 'default'}, ui-tars-version, ${uiTarsVersion}, prompt-tokens, ${(null == (_result_usage = result.usage) ? void 0 : _result_usage.prompt_tokens) || ''}, completion-tokens, ${(null == (_result_usage1 = result.usage) ? void 0 : _result_usage1.completion_tokens) || ''}, total-tokens, ${(null == (_result_usage2 = result.usage) ? void 0 : _result_usage2.total_tokens) || ''}, cost-ms, ${timeCost}, requestId, ${result._request_id || ''}`);\n                debugProfileDetail(`model usage detail: ${JSON.stringify(result.usage)}`);\n                assert(result.choices, `invalid response from LLM service: ${JSON.stringify(result)}`);\n                content = result.choices[0].message.content;\n                usage = result.usage;\n            }\n            debugCall(`response: ${content}`);\n            assert(content, 'empty content');\n        } else if ('anthropic' === style) {\n            const convertImageContent = (content)=>{\n                if ('image_url' === content.type) {\n                    const imgBase64 = content.image_url.url;\n                    assert(imgBase64, 'image_url is required');\n                    const { mimeType, body } = parseBase64(content.image_url.url);\n                    return {\n                        source: {\n                            type: 'base64',\n                            media_type: mimeType,\n                            data: body\n                        },\n                        type: 'image'\n                    };\n                }\n                return content;\n            };\n            if (isStreaming) {\n                const stream = await completion.create({\n                    model: modelName,\n                    system: 'You are a versatile professional in software UI automation',\n                    messages: messages.map((m)=>({\n                            role: 'user',\n                            content: Array.isArray(m.content) ? m.content.map(convertImageContent) : m.content\n                        })),\n                    response_format: responseFormat,\n                    ...commonConfig\n                });\n                for await (const chunk of stream){\n                    var _chunk_delta;\n                    const content = (null == (_chunk_delta = chunk.delta) ? void 0 : _chunk_delta.text) || '';\n                    if (content) {\n                        accumulated += content;\n                        const chunkData = {\n                            content,\n                            accumulated,\n                            reasoning_content: '',\n                            isComplete: false,\n                            usage: void 0\n                        };\n                        options.onChunk(chunkData);\n                    }\n                    if ('message_stop' === chunk.type) {\n                        timeCost = Date.now() - startTime;\n                        const anthropicUsage = chunk.usage;\n                        const finalChunk = {\n                            content: '',\n                            accumulated,\n                            reasoning_content: '',\n                            isComplete: true,\n                            usage: anthropicUsage ? {\n                                prompt_tokens: anthropicUsage.input_tokens ?? 0,\n                                completion_tokens: anthropicUsage.output_tokens ?? 0,\n                                total_tokens: (anthropicUsage.input_tokens ?? 0) + (anthropicUsage.output_tokens ?? 0),\n                                time_cost: timeCost ?? 0,\n                                model_name: modelName,\n                                model_description: modelDescription,\n                                intent: modelConfig.intent\n                            } : void 0\n                        };\n                        options.onChunk(finalChunk);\n                        break;\n                    }\n                }\n                content = accumulated;\n            } else {\n                const result = await completion.create({\n                    model: modelName,\n                    system: 'You are a versatile professional in software UI automation',\n                    messages: messages.map((m)=>({\n                            role: 'user',\n                            content: Array.isArray(m.content) ? m.content.map(convertImageContent) : m.content\n                        })),\n                    response_format: responseFormat,\n                    ...commonConfig\n                });\n                timeCost = Date.now() - startTime;\n                content = result.content[0].text;\n                usage = result.usage;\n            }\n            assert(content, 'empty content');\n        }\n        if (isStreaming && !usage) {\n            const estimatedTokens = Math.max(1, Math.floor((content || '').length / 4));\n            usage = {\n                prompt_tokens: estimatedTokens,\n                completion_tokens: estimatedTokens,\n                total_tokens: 2 * estimatedTokens\n            };\n        }\n        return {\n            content: content || '',\n            usage: usage ? {\n                prompt_tokens: usage.prompt_tokens ?? 0,\n                completion_tokens: usage.completion_tokens ?? 0,\n                total_tokens: usage.total_tokens ?? 0,\n                time_cost: timeCost ?? 0,\n                model_name: modelName,\n                model_description: modelDescription,\n                intent: modelConfig.intent\n            } : void 0,\n            isStreamed: !!isStreaming\n        };\n    } catch (e) {\n        console.error(' call AI error', e);\n        const newError = new Error(`failed to call ${isStreaming ? 'streaming ' : ''}AI model service: ${e.message}. Trouble shooting: https://sqai.tech/model-provider.html`, {\n            cause: e\n        });\n        throw newError;\n    }\n}\nconst getResponseFormat = (modelName, AIActionTypeValue)=>{\n    let responseFormat;\n    if (modelName.includes('gpt-4')) switch(AIActionTypeValue){\n        case AIActionType.ASSERT:\n            responseFormat = assertSchema;\n            break;\n        case AIActionType.INSPECT_ELEMENT:\n            responseFormat = locatorSchema;\n            break;\n        case AIActionType.PLAN:\n            responseFormat = planSchema;\n            break;\n        case AIActionType.EXTRACT_DATA:\n        case AIActionType.DESCRIBE_ELEMENT:\n            responseFormat = {\n                type: AIResponseFormat.JSON\n            };\n            break;\n        case AIActionType.TEXT:\n            responseFormat = void 0;\n            break;\n    }\n    if ('gpt-4o-2024-05-13' === modelName && AIActionTypeValue !== AIActionType.TEXT) responseFormat = {\n        type: AIResponseFormat.JSON\n    };\n    return responseFormat;\n};\nasync function callAIWithObjectResponse(messages, AIActionTypeValue, modelConfig) {\n    const response = await callAI(messages, AIActionTypeValue, modelConfig);\n    assert(response, 'empty response');\n    const vlMode = modelConfig.vlMode;\n    const jsonContent = safeParseJson(response.content, vlMode);\n    return {\n        content: jsonContent,\n        usage: response.usage\n    };\n}\nasync function callAIWithStringResponse(msgs, AIActionTypeValue, modelConfig) {\n    const { content, usage } = await callAI(msgs, AIActionTypeValue, modelConfig);\n    return {\n        content,\n        usage\n    };\n}\nfunction extractJSONFromCodeBlock(response) {\n    try {\n        const jsonMatch = response.match(/^\\s*(\\{[\\s\\S]*\\})\\s*$/);\n        if (jsonMatch) return jsonMatch[1];\n        const codeBlockMatch = response.match(/```(?:json)?\\s*(\\{[\\s\\S]*?\\})\\s*```/);\n        if (codeBlockMatch) return codeBlockMatch[1];\n        const jsonLikeMatch = response.match(/\\{[\\s\\S]*\\}/);\n        if (jsonLikeMatch) return jsonLikeMatch[0];\n    } catch  {}\n    return response;\n}\nfunction preprocessDoubaoBboxJson(input) {\n    if (input.includes('bbox')) while(/\\d+\\s+\\d+/.test(input))input = input.replace(/(\\d+)\\s+(\\d+)/g, '$1,$2');\n    return input;\n}\nfunction safeParseJson(input, vlMode) {\n    const cleanJsonString = extractJSONFromCodeBlock(input);\n    if (null == cleanJsonString ? void 0 : cleanJsonString.match(/\\((\\d+),(\\d+)\\)/)) {\n        var _cleanJsonString_match;\n        return null == (_cleanJsonString_match = cleanJsonString.match(/\\((\\d+),(\\d+)\\)/)) ? void 0 : _cleanJsonString_match.slice(1).map(Number);\n    }\n    try {\n        return JSON.parse(cleanJsonString);\n    } catch  {}\n    try {\n        return JSON.parse(jsonrepair(cleanJsonString));\n    } catch (e) {}\n    if ('doubao-vision' === vlMode || 'vlm-ui-tars' === vlMode) {\n        const jsonString = preprocessDoubaoBboxJson(cleanJsonString);\n        return JSON.parse(jsonrepair(jsonString));\n    }\n    throw Error(`failed to parse json response: ${input}`);\n}\nexport { callAI, callAIWithObjectResponse, callAIWithStringResponse, extractJSONFromCodeBlock, getResponseFormat, preprocessDoubaoBboxJson, safeParseJson };\n\n//# sourceMappingURL=index.mjs.map","import { findAllMidsceneLocatorField } from \"@sqaitech/core/ai-model\";\nimport { buildDetailedLocateParam } from \"@sqaitech/core/yaml\";\nconst dataExtractionAPIs = [\n    'aiQuery',\n    'aiBoolean',\n    'aiNumber',\n    'aiString',\n    'aiAsk'\n];\nconst validationAPIs = [\n    'aiAssert',\n    'aiWaitFor'\n];\nconst noReplayAPIs = [\n    ...dataExtractionAPIs,\n    ...validationAPIs\n];\nconst formatErrorMessage = (e)=>{\n    const errorMessage = (null == e ? void 0 : e.message) || '';\n    if (errorMessage.includes('of different extension')) return 'Conflicting extension detected. Please disable the suspicious plugins and refresh the page. Guide: https://sqai.tech/quick-experience.html#faq';\n    if (errorMessage.includes('NOT_IMPLEMENTED_AS_DESIGNED')) return 'Further actions cannot be performed in the current environment';\n    return errorMessage || 'Unknown error';\n};\nasync function parseStructuredParams(action, params, options = {}) {\n    if (!(null == action ? void 0 : action.paramSchema) || !('shape' in action.paramSchema)) return [\n        params.prompt || '',\n        options\n    ];\n    const schema = action.paramSchema;\n    const keys = schema && 'shape' in schema ? Object.keys(schema.shape) : [];\n    const paramObj = {\n        ...options\n    };\n    keys.forEach((key)=>{\n        if (void 0 !== params[key] && null !== params[key] && '' !== params[key]) paramObj[key] = params[key];\n    });\n    if (schema) {\n        const locatorFieldKeys = findAllMidsceneLocatorField(schema);\n        locatorFieldKeys.forEach((locateKey)=>{\n            const locatePrompt = params[locateKey];\n            if (locatePrompt && 'string' == typeof locatePrompt) {\n                const detailedLocateParam = buildDetailedLocateParam(locatePrompt, {\n                    deepThink: options.deepThink,\n                    cacheable: true\n                });\n                if (detailedLocateParam) paramObj[locateKey] = detailedLocateParam;\n            }\n        });\n    }\n    return [\n        paramObj\n    ];\n}\nfunction validateStructuredParams(value, action) {\n    if (!value.params) return {\n        valid: false,\n        errorMessage: 'Parameters are required'\n    };\n    if (!(null == action ? void 0 : action.paramSchema)) return {\n        valid: true\n    };\n    try {\n        var _action_paramSchema;\n        const paramsForValidation = {\n            ...value.params\n        };\n        const schema = action.paramSchema;\n        if (schema) {\n            const locatorFieldKeys = findAllMidsceneLocatorField(schema);\n            locatorFieldKeys.forEach((key)=>{\n                if ('string' == typeof paramsForValidation[key]) paramsForValidation[key] = {\n                    midscene_location_field_flag: true,\n                    prompt: paramsForValidation[key],\n                    center: [\n                        0,\n                        0\n                    ],\n                    rect: {\n                        left: 0,\n                        top: 0,\n                        width: 0,\n                        height: 0\n                    }\n                };\n            });\n        }\n        null == (_action_paramSchema = action.paramSchema) || _action_paramSchema.parse(paramsForValidation);\n    } catch (error) {\n        const zodError = error;\n        if (zodError.errors && zodError.errors.length > 0) {\n            const errorMessages = zodError.errors.filter((err)=>{\n                const path = err.path.join('.');\n                return !path.includes('center') && !path.includes('rect') && !path.includes('midscene_location_field_flag');\n            }).map((err)=>{\n                const field = err.path.join('.');\n                return `${field}: ${err.message}`;\n            });\n            if (errorMessages.length > 0) return {\n                valid: false,\n                errorMessage: `Validation error: ${errorMessages.join(', ')}`\n            };\n        } else {\n            const errorMsg = error instanceof Error ? error.message : 'Unknown validation error';\n            return {\n                valid: false,\n                errorMessage: `Parameter validation failed: ${errorMsg}`\n            };\n        }\n    }\n    return {\n        valid: true\n    };\n}\nasync function executeAction(activeAgent, actionType, actionSpace, value, options) {\n    const action = null == actionSpace ? void 0 : actionSpace.find((a)=>a.interfaceAlias === actionType || a.name === actionType);\n    if (action && 'function' == typeof activeAgent.callActionInActionSpace) if (value.params) {\n        const parsedParams = await parseStructuredParams(action, value.params, options);\n        return await activeAgent.callActionInActionSpace(action.name, parsedParams[0]);\n    } else {\n        const detailedLocateParam = value.prompt ? buildDetailedLocateParam(value.prompt, {\n            deepThink: options.deepThink,\n            cacheable: true\n        }) : void 0;\n        return await activeAgent.callActionInActionSpace(action.name, {\n            locate: detailedLocateParam,\n            ...options\n        });\n    }\n    {\n        const prompt = value.prompt;\n        if ('aiAssert' === actionType) {\n            var _activeAgent_aiAssert;\n            const { pass, thought } = await (null == activeAgent ? void 0 : null == (_activeAgent_aiAssert = activeAgent.aiAssert) ? void 0 : _activeAgent_aiAssert.call(activeAgent, prompt || '', void 0, {\n                keepRawResponse: true,\n                ...options\n            })) || {};\n            return {\n                pass: pass || false,\n                thought: thought || ''\n            };\n        }\n        if (activeAgent && 'function' == typeof activeAgent[actionType]) return await activeAgent[actionType](prompt, options);\n        throw new Error(`Unknown action type: ${actionType}`);\n    }\n}\nexport { dataExtractionAPIs, executeAction, formatErrorMessage, noReplayAPIs, parseStructuredParams, validateStructuredParams, validationAPIs };\n\n//# sourceMappingURL=common.mjs.map","import { overrideAIConfig } from \"@sqaitech/shared/env\";\nimport { uuid } from \"@sqaitech/shared/utils\";\nimport { executeAction, parseStructuredParams } from \"../common.mjs\";\nimport { BasePlaygroundAdapter } from \"./base.mjs\";\nfunction _define_property(obj, key, value) {\n    if (key in obj) Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n    });\n    else obj[key] = value;\n    return obj;\n}\nclass LocalExecutionAdapter extends BasePlaygroundAdapter {\n    get id() {\n        return this._id;\n    }\n    setProgressCallback(callback) {\n        this.progressCallback = void 0;\n        this.progressCallback = callback;\n    }\n    cleanup(requestId) {\n        delete this.taskProgressTips[requestId];\n    }\n    async parseStructuredParams(action, params, options) {\n        return await parseStructuredParams(action, params, options);\n    }\n    formatErrorMessage(error) {\n        const errorMessage = (null == error ? void 0 : error.message) || '';\n        if (errorMessage.includes('of different extension')) return 'Conflicting extension detected. Please disable the suspicious plugins and refresh the page. Guide: https://sqai.tech/quick-experience.html#faq';\n        return this.formatBasicErrorMessage(error);\n    }\n    async getActionSpace(context) {\n        var _this_agent;\n        if (null == (_this_agent = this.agent) ? void 0 : _this_agent.getActionSpace) return await this.agent.getActionSpace();\n        if (this.agent && 'interface' in this.agent && 'object' == typeof this.agent.interface) {\n            const page = this.agent.interface;\n            if (null == page ? void 0 : page.actionSpace) return await page.actionSpace();\n        }\n        if (context && 'object' == typeof context && 'actionSpace' in context) {\n            const contextPage = context;\n            return await contextPage.actionSpace();\n        }\n        return [];\n    }\n    async checkStatus() {\n        return true;\n    }\n    async overrideConfig(aiConfig) {\n        overrideAIConfig(aiConfig);\n    }\n    async executeAction(actionType, value, options) {\n        const actionSpace = await this.getActionSpace();\n        let originalOnTaskStartTip;\n        if (options.requestId && this.agent) {\n            this.currentRequestId = options.requestId;\n            originalOnTaskStartTip = this.agent.onTaskStartTip;\n            this.agent.onTaskStartTip = (tip)=>{\n                if (this.currentRequestId !== options.requestId) return;\n                this.taskProgressTips[options.requestId] = tip;\n                if (this.progressCallback) this.progressCallback(tip);\n                if ('function' == typeof originalOnTaskStartTip) originalOnTaskStartTip(tip);\n            };\n        }\n        try {\n            const result = await executeAction(this.agent, actionType, actionSpace, value, options);\n            const response = {\n                result,\n                dump: null,\n                reportHTML: null,\n                error: null\n            };\n            try {\n                if (this.agent.dumpDataString) {\n                    const dumpString = this.agent.dumpDataString();\n                    if (dumpString) response.dump = JSON.parse(dumpString);\n                }\n                if (this.agent.reportHTMLString) response.reportHTML = this.agent.reportHTMLString() || null;\n                if (this.agent.writeOutActionDumps) this.agent.writeOutActionDumps();\n            } catch (error) {\n                console.error('Failed to get dump/reportHTML from agent:', error);\n            }\n            this.agent.resetDump();\n            return response;\n        } finally{\n            if (options.requestId) {\n                this.cleanup(options.requestId);\n                if (this.agent) this.agent.onTaskStartTip = originalOnTaskStartTip;\n            }\n        }\n    }\n    async getTaskProgress(requestId) {\n        return {\n            tip: this.taskProgressTips[requestId] || void 0\n        };\n    }\n    async cancelTask(_requestId) {\n        if (!this.agent) return {\n            error: 'No active agent found for this requestId'\n        };\n        try {\n            var _this_agent_destroy, _this_agent;\n            await (null == (_this_agent_destroy = (_this_agent = this.agent).destroy) ? void 0 : _this_agent_destroy.call(_this_agent));\n            return {\n                success: true\n            };\n        } catch (error) {\n            const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n            console.error(`Failed to cancel agent: ${errorMessage}`);\n            return {\n                error: `Failed to cancel: ${errorMessage}`\n            };\n        }\n    }\n    async getInterfaceInfo() {\n        var _this_agent;\n        if (!(null == (_this_agent = this.agent) ? void 0 : _this_agent.interface)) return null;\n        try {\n            var _this_agent_interface_describe, _this_agent_interface;\n            const type = this.agent.interface.interfaceType || 'Unknown';\n            const description = (null == (_this_agent_interface_describe = (_this_agent_interface = this.agent.interface).describe) ? void 0 : _this_agent_interface_describe.call(_this_agent_interface)) || void 0;\n            return {\n                type,\n                description\n            };\n        } catch (error) {\n            console.error('Failed to get interface info:', error);\n            return null;\n        }\n    }\n    constructor(agent){\n        super(), _define_property(this, \"agent\", void 0), _define_property(this, \"taskProgressTips\", {}), _define_property(this, \"progressCallback\", void 0), _define_property(this, \"_id\", void 0), _define_property(this, \"currentRequestId\", void 0);\n        this.agent = agent;\n        this._id = uuid();\n    }\n}\nexport { LocalExecutionAdapter };\n\n//# sourceMappingURL=local-execution.mjs.map","import { parseStructuredParams } from \"../common.mjs\";\nimport { BasePlaygroundAdapter } from \"./base.mjs\";\nfunction _define_property(obj, key, value) {\n    if (key in obj) Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n    });\n    else obj[key] = value;\n    return obj;\n}\nclass RemoteExecutionAdapter extends BasePlaygroundAdapter {\n    get id() {\n        return this._id;\n    }\n    validateParams(value, action) {\n        if (!(null == action ? void 0 : action.paramSchema)) return {\n            valid: true\n        };\n        const needsStructuredParams = this.actionNeedsStructuredParams(action);\n        if (!needsStructuredParams) return {\n            valid: true\n        };\n        if (!value.params) return {\n            valid: false,\n            errorMessage: 'Parameters are required'\n        };\n        if (action.paramSchema && 'object' == typeof action.paramSchema) {\n            const schema = action.paramSchema;\n            if (schema.shape || 'ZodObject' === schema.type) {\n                const shape = schema.shape || {};\n                const missingFields = Object.keys(shape).filter((key)=>{\n                    var _fieldDef__def, _fieldDef__def1;\n                    const fieldDef = shape[key];\n                    const isOptional = (null == fieldDef ? void 0 : fieldDef.isOptional) || (null == fieldDef ? void 0 : null == (_fieldDef__def = fieldDef._def) ? void 0 : _fieldDef__def.innerType) || (null == fieldDef ? void 0 : null == (_fieldDef__def1 = fieldDef._def) ? void 0 : _fieldDef__def1.typeName) === 'ZodOptional';\n                    return !isOptional && (void 0 === value.params[key] || '' === value.params[key]);\n                });\n                if (missingFields.length > 0) return {\n                    valid: false,\n                    errorMessage: `Missing required parameters: ${missingFields.join(', ')}`\n                };\n            }\n        }\n        return {\n            valid: true\n        };\n    }\n    async parseStructuredParams(action, params, options) {\n        return await parseStructuredParams(action, params, options);\n    }\n    formatErrorMessage(error) {\n        const message = (null == error ? void 0 : error.message) || '';\n        const androidErrors = [\n            {\n                keyword: 'adb',\n                message: 'ADB connection error. Please ensure device is connected and USB debugging is enabled.'\n            },\n            {\n                keyword: 'UIAutomator',\n                message: 'UIAutomator error. Please ensure the UIAutomator server is running on the device.'\n            }\n        ];\n        const androidError = androidErrors.find(({ keyword })=>message.includes(keyword));\n        if (androidError) return androidError.message;\n        return this.formatBasicErrorMessage(error);\n    }\n    async executeAction(actionType, value, options) {\n        if (this.serverUrl && 'undefined' != typeof window) return this.executeViaServer(actionType, value, options);\n        throw new Error('Remote execution adapter requires server URL for execution');\n    }\n    async executeViaServer(actionType, value, options) {\n        const payload = {\n            type: actionType,\n            prompt: value.prompt,\n            ...this.buildOptionalPayloadParams(options, value)\n        };\n        if (options.context) payload.context = options.context;\n        if (options.requestId && this.progressCallback) this.startProgressPolling(options.requestId, this.progressCallback);\n        try {\n            const response = await fetch(`${this.serverUrl}/execute`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(payload)\n            });\n            if (!response.ok) {\n                const errorText = await response.text().catch(()=>'Unknown error');\n                throw new Error(`Server request failed (${response.status}): ${errorText}`);\n            }\n            const result = await response.json();\n            if (options.requestId) this.stopProgressPolling(options.requestId);\n            return result;\n        } catch (error) {\n            if (options.requestId) this.stopProgressPolling(options.requestId);\n            console.error('Execute via server failed:', error);\n            throw error;\n        }\n    }\n    buildOptionalPayloadParams(options, value) {\n        const optionalParams = {};\n        const optionalFields = [\n            {\n                key: 'requestId',\n                value: options.requestId\n            },\n            {\n                key: 'deepThink',\n                value: options.deepThink\n            },\n            {\n                key: 'screenshotIncluded',\n                value: options.screenshotIncluded\n            },\n            {\n                key: 'domIncluded',\n                value: options.domIncluded\n            },\n            {\n                key: 'params',\n                value: value.params\n            }\n        ];\n        optionalFields.forEach(({ key, value })=>{\n            if (null != value && '' !== value) optionalParams[key] = value;\n        });\n        return optionalParams;\n    }\n    async getActionSpace(context) {\n        if (this.serverUrl && 'undefined' != typeof window) try {\n            const response = await fetch(`${this.serverUrl}/action-space`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    context\n                })\n            });\n            if (!response.ok) throw new Error(`Failed to get action space: ${response.statusText}`);\n            const result = await response.json();\n            return Array.isArray(result) ? result : [];\n        } catch (error) {\n            console.error('Failed to get action space from server:', error);\n        }\n        if (context && 'object' == typeof context && 'actionSpace' in context) try {\n            const actionSpaceMethod = context.actionSpace;\n            const result = await actionSpaceMethod();\n            return Array.isArray(result) ? result : [];\n        } catch (error) {\n            console.error('Failed to get action space from context:', error);\n        }\n        return [];\n    }\n    async checkStatus() {\n        if (!this.serverUrl) return false;\n        try {\n            const res = await fetch(`${this.serverUrl}/status`);\n            if (200 === res.status) {\n                try {\n                    const data = await res.json();\n                    if (data.id && 'string' == typeof data.id) this._id = data.id;\n                } catch (jsonError) {\n                    console.debug('Failed to parse status response:', jsonError);\n                }\n                return true;\n            }\n            return false;\n        } catch (error) {\n            console.warn('Server status check failed:', error);\n            return false;\n        }\n    }\n    async overrideConfig(aiConfig) {\n        if (!this.serverUrl) throw new Error('Server URL not configured');\n        try {\n            const response = await fetch(`${this.serverUrl}/config`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    aiConfig\n                })\n            });\n            if (!response.ok) throw new Error(`Failed to override server config: ${response.statusText}`);\n        } catch (error) {\n            console.error('Failed to override server config:', error);\n            throw error;\n        }\n    }\n    async getTaskProgress(requestId) {\n        if (!this.serverUrl) return {\n            tip: void 0\n        };\n        if (!(null == requestId ? void 0 : requestId.trim())) {\n            console.warn('Invalid requestId provided for task progress');\n            return {\n                tip: void 0\n            };\n        }\n        try {\n            const response = await fetch(`${this.serverUrl}/task-progress/${encodeURIComponent(requestId)}`);\n            if (!response.ok) {\n                console.warn(`Task progress request failed: ${response.statusText}`);\n                return {\n                    tip: void 0\n                };\n            }\n            return await response.json();\n        } catch (error) {\n            console.error('Failed to poll task progress:', error);\n            return {\n                tip: void 0\n            };\n        }\n    }\n    async cancelTask(requestId) {\n        this.stopProgressPolling(requestId);\n        if (!this.serverUrl) return {\n            error: 'No server URL configured'\n        };\n        if (!(null == requestId ? void 0 : requestId.trim())) return {\n            error: 'Invalid request ID'\n        };\n        try {\n            const res = await fetch(`${this.serverUrl}/cancel/${encodeURIComponent(requestId)}`, {\n                method: 'POST'\n            });\n            if (!res.ok) return {\n                error: `Cancel request failed: ${res.statusText}`\n            };\n            const result = await res.json();\n            return {\n                success: true,\n                ...result\n            };\n        } catch (error) {\n            console.error('Failed to cancel task:', error);\n            return {\n                error: 'Failed to cancel task'\n            };\n        }\n    }\n    setProgressCallback(callback) {\n        this.progressCallback = callback;\n    }\n    startProgressPolling(requestId, callback) {\n        if (this.progressPolling.has(requestId)) return;\n        let lastTip = '';\n        const interval = setInterval(async ()=>{\n            try {\n                var _progress_tip_trim, _progress_tip;\n                const progress = await this.getTaskProgress(requestId);\n                if ((null == progress ? void 0 : null == (_progress_tip = progress.tip) ? void 0 : null == (_progress_tip_trim = _progress_tip.trim) ? void 0 : _progress_tip_trim.call(_progress_tip)) && progress.tip !== lastTip) {\n                    lastTip = progress.tip;\n                    callback(progress.tip);\n                }\n            } catch (error) {\n                console.debug('Progress polling error:', error);\n            }\n        }, 500);\n        this.progressPolling.set(requestId, interval);\n    }\n    stopProgressPolling(requestId) {\n        const interval = this.progressPolling.get(requestId);\n        if (interval) {\n            clearInterval(interval);\n            this.progressPolling.delete(requestId);\n        }\n    }\n    async getScreenshot() {\n        if (!this.serverUrl) return null;\n        try {\n            const response = await fetch(`${this.serverUrl}/screenshot`);\n            if (!response.ok) {\n                console.warn(`Screenshot request failed: ${response.statusText}`);\n                return null;\n            }\n            return await response.json();\n        } catch (error) {\n            console.error('Failed to get screenshot:', error);\n            return null;\n        }\n    }\n    async getInterfaceInfo() {\n        if (!this.serverUrl) return null;\n        try {\n            const response = await fetch(`${this.serverUrl}/interface-info`);\n            if (!response.ok) {\n                console.warn(`Interface info request failed: ${response.statusText}`);\n                return null;\n            }\n            return await response.json();\n        } catch (error) {\n            console.error('Failed to get interface info:', error);\n            return null;\n        }\n    }\n    constructor(serverUrl){\n        super(), _define_property(this, \"serverUrl\", void 0), _define_property(this, \"progressPolling\", new Map()), _define_property(this, \"progressCallback\", void 0), _define_property(this, \"_id\", void 0);\n        this.serverUrl = serverUrl;\n    }\n}\nexport { RemoteExecutionAdapter };\n\n//# sourceMappingURL=remote-execution.mjs.map","function _define_property(obj, key, value) {\n    if (key in obj) Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n    });\n    else obj[key] = value;\n    return obj;\n}\nclass IndexedDBManager {\n    initDB() {\n        return new Promise((resolve, reject)=>{\n            const request = indexedDB.open(this.dbName, this.version);\n            request.onerror = ()=>reject(request.error);\n            request.onsuccess = ()=>resolve(request.result);\n            request.onupgradeneeded = (event)=>{\n                const db = event.target.result;\n                this.storeConfigs.forEach(({ name, keyPath })=>{\n                    if (!db.objectStoreNames.contains(name)) {\n                        const store = db.createObjectStore(name, {\n                            keyPath\n                        });\n                        store.createIndex('timestamp', 'timestamp', {\n                            unique: false\n                        });\n                    }\n                });\n            };\n        });\n    }\n    async withTransaction(storeNames, mode, operation) {\n        const db = await this.dbPromise;\n        const transaction = db.transaction(storeNames, mode);\n        const stores = Array.isArray(storeNames) ? storeNames.map((name)=>transaction.objectStore(name)) : transaction.objectStore(storeNames);\n        return operation(stores);\n    }\n    promisifyRequest(request) {\n        return new Promise((resolve, reject)=>{\n            request.onsuccess = ()=>resolve(request.result);\n            request.onerror = ()=>reject(request.error);\n        });\n    }\n    async put(storeName, data) {\n        await this.withTransaction(storeName, 'readwrite', async (store)=>{\n            await this.promisifyRequest(store.put(data));\n        });\n    }\n    async get(storeName, key) {\n        return this.withTransaction(storeName, 'readonly', async (store)=>this.promisifyRequest(store.get(key)));\n    }\n    async getAll(storeName, sortByTimestamp = true) {\n        return this.withTransaction(storeName, 'readonly', async (store)=>{\n            const objectStore = store;\n            const results = sortByTimestamp ? await this.promisifyRequest(objectStore.index('timestamp').getAll()) : await this.promisifyRequest(objectStore.getAll());\n            return sortByTimestamp ? results.sort((a, b)=>a.timestamp - b.timestamp) : results;\n        });\n    }\n    async clear(storeName) {\n        await this.withTransaction(storeName, 'readwrite', async (store)=>{\n            await this.promisifyRequest(store.clear());\n        });\n    }\n    async delete(storeName, key) {\n        await this.withTransaction(storeName, 'readwrite', async (store)=>{\n            await this.promisifyRequest(store.delete(key));\n        });\n    }\n    async count(storeName) {\n        return this.withTransaction(storeName, 'readonly', async (store)=>this.promisifyRequest(store.count()));\n    }\n    getDBPromise() {\n        return this.dbPromise;\n    }\n    constructor(dbName, version, storeConfigs){\n        _define_property(this, \"dbPromise\", void 0);\n        _define_property(this, \"dbName\", void 0);\n        _define_property(this, \"version\", void 0);\n        _define_property(this, \"storeConfigs\", void 0);\n        this.dbName = dbName;\n        this.version = version;\n        this.storeConfigs = storeConfigs;\n        this.dbPromise = this.initDB();\n    }\n}\nconst withErrorHandling = async (operation, errorMessage, defaultValue, onQuotaExceeded)=>{\n    try {\n        return await operation();\n    } catch (e) {\n        console.error(errorMessage, e);\n        if (e instanceof Error && 'QuotaExceededError' === e.name && onQuotaExceeded) {\n            console.log('Storage quota exceeded, running cleanup...');\n            await onQuotaExceeded();\n        }\n        return defaultValue;\n    }\n};\nconst createCleanupFunction = (dbManager, storeName, maxItems)=>async ()=>{\n        try {\n            const results = await dbManager.getAll(storeName);\n            if (results.length > maxItems) {\n                const toDelete = results.sort((a, b)=>a.timestamp - b.timestamp).slice(0, results.length - maxItems);\n                await Promise.all(toDelete.map((item)=>dbManager.delete(storeName, item.id)));\n            }\n        } catch (e) {\n            console.error(`Failed to cleanup ${storeName}:`, e);\n        }\n    };\nexport { IndexedDBManager, createCleanupFunction, withErrorHandling };\n","import { PLAYWRIGHT_EXAMPLE_CODE, YAML_EXAMPLE_CODE } from \"./example-code.mjs\";\nconst TEXT_SIZE_THRESHOLD = 9;\nconst TEXT_MAX_SIZE = 40;\nconst CONTAINER_MINI_HEIGHT = 3;\nconst CONTAINER_MINI_WIDTH = 3;\nvar constants_NodeType = /*#__PURE__*/ function(NodeType) {\n    NodeType[\"CONTAINER\"] = \"CONTAINER Node\";\n    NodeType[\"FORM_ITEM\"] = \"FORM_ITEM Node\";\n    NodeType[\"BUTTON\"] = \"BUTTON Node\";\n    NodeType[\"A\"] = \"Anchor Node\";\n    NodeType[\"IMG\"] = \"IMG Node\";\n    NodeType[\"TEXT\"] = \"TEXT Node\";\n    NodeType[\"POSITION\"] = \"POSITION Node\";\n    return NodeType;\n}({});\nconst PLAYGROUND_SERVER_PORT = 5800;\nconst SCRCPY_SERVER_PORT = 5700;\nconst WEBDRIVER_ELEMENT_ID_KEY = 'element-6066-11e4-a52e-4f735466cecf';\nconst DEFAULT_WDA_PORT = 8100;\nconst DEFAULT_WAIT_FOR_NAVIGATION_TIMEOUT = 5000;\nconst DEFAULT_WAIT_FOR_NETWORK_IDLE_TIMEOUT = 2000;\nconst DEFAULT_WAIT_FOR_NETWORK_IDLE_TIME = 300;\nconst DEFAULT_WAIT_FOR_NETWORK_IDLE_CONCURRENCY = 2;\nexport { CONTAINER_MINI_HEIGHT, CONTAINER_MINI_WIDTH, DEFAULT_WAIT_FOR_NAVIGATION_TIMEOUT, DEFAULT_WAIT_FOR_NETWORK_IDLE_CONCURRENCY, DEFAULT_WAIT_FOR_NETWORK_IDLE_TIME, DEFAULT_WAIT_FOR_NETWORK_IDLE_TIMEOUT, DEFAULT_WDA_PORT, constants_NodeType as NodeType, PLAYGROUND_SERVER_PORT, PLAYWRIGHT_EXAMPLE_CODE, SCRCPY_SERVER_PORT, TEXT_MAX_SIZE, TEXT_SIZE_THRESHOLD, WEBDRIVER_ELEMENT_ID_KEY, YAML_EXAMPLE_CODE };\n","// getDefaultExport function for compatibility with non-ESM modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};\n","var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n  __webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach((key) => { def[key] = () => (value[key]) });\n\t}\n\tdef['default'] = () => (value);\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n        if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n            Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n        }\n    }\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(\n\t\tObject.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t\t__webpack_require__.f[key](chunkId, promises);\n\t\t\treturn promises;\n\t\t}, [])\n\t);\n};","// This function allow to reference chunks\n__webpack_require__.u = (chunkId) => {\n  // return url for filenames not based on template\n  \n  // return url for filenames based on template\n  return \"static/js/async/\" + chunkId + \".\" + {\"173\": \"d4ba6f65\",\"624\": \"341d6f9f\",\"644\": \"2be92586\",\"659\": \"82465281\",\"920\": \"115aa48e\",}[chunkId] + \".js\"\n}","__webpack_require__.g = (() => {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var inProgress = {};\n\nvar dataWebpackPrefix = \"chrome-extension:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = function (url, done, key, chunkId) {\n\tif (inProgress[url]) {\n\t\tinProgress[url].push(done);\n\t\treturn;\n\t}\n\tvar script, needAttach;\n\tif (key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor (var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif (s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) {\n\t\t\t\tscript = s;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!script) {\n\t\tneedAttach = true;\n\t\t\n    script = document.createElement('script');\n    \n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\t\t\n\t\tscript.src = url;\n\t\t\n    \n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = function (prev, event) {\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns &&\n\t\t\tdoneFns.forEach(function (fn) {\n\t\t\t\treturn fn(event);\n\t\t\t});\n\t\tif (prev) return prev(event);\n\t};\n\tvar timeout = setTimeout(\n\t\tonScriptComplete.bind(null, undefined, {\n\t\t\ttype: 'timeout',\n\t\t\ttarget: script\n\t\t}),\n\t\t120000\n\t);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n  module.paths = [];\n  if (!module.children) module.children = [];\n  return module;\n};","__webpack_require__.nc = undefined;","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif (chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor (var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--)\n\t\t\tdeferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif (\n\t\t\t\t(priority & (1 === 0) || notFulfilled >= priority) &&\n\t\t\t\tObject.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))\n\t\t\t) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif (priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif (fulfilled) {\n\t\t\tdeferred.splice(i--, 1);\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};\n","__webpack_require__.p = \"/\";","__webpack_require__.rv = () => (\"1.3.12\")","__webpack_require__.b = document.baseURI || self.location.href;\n\n      // object to store loaded and loading chunks\n      // undefined = chunk not loaded, null = chunk preloaded/prefetched\n      // [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\n      var installedChunks = {\"533\": 0,};\n      \n        __webpack_require__.f.j = function (chunkId, promises) {\n          // JSONP chunk loading for javascript\nvar installedChunkData = __webpack_require__.o(installedChunks, chunkId)\n\t? installedChunks[chunkId]\n\t: undefined;\nif (installedChunkData !== 0) {\n\t// 0 means \"already installed\".\n\n\t// a Promise means \"currently loading\".\n\tif (installedChunkData) {\n\t\tpromises.push(installedChunkData[2]);\n\t} else {\n\t\tif (true) {\n\t\t\t// setup Promise in chunk cache\n\t\t\tvar promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));\n\t\t\tpromises.push((installedChunkData[2] = promise));\n\n\t\t\t// start chunk loading\n\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\tvar error = new Error();\n\t\t\tvar loadingEnded = function (event) {\n\t\t\t\tif (__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\tif (installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\tif (installedChunkData) {\n\t\t\t\t\t\tvar errorType =\n\t\t\t\t\t\t\tevent && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\terror.message =\n\t\t\t\t\t\t\t'Loading chunk ' +\n\t\t\t\t\t\t\tchunkId +\n\t\t\t\t\t\t\t' failed.\\n(' +\n\t\t\t\t\t\t\terrorType +\n\t\t\t\t\t\t\t': ' +\n\t\t\t\t\t\t\trealSrc +\n\t\t\t\t\t\t\t')';\n\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t} \n\t}\n}\n\n        }\n        __webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif (chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor (moduleId in moreModules) {\n\t\t\tif (__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif (runtime) var result = runtime(__webpack_require__);\n\t}\n\tif (parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor (; i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif (\n\t\t\t__webpack_require__.o(installedChunks, chunkId) &&\n\t\t\tinstalledChunks[chunkId]\n\t\t) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkchrome_extension\"] = self[\"webpackChunkchrome_extension\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));\n","__webpack_require__.ruid = \"bundler=rspack@1.3.12\";\n"],"names":["IndexedDBManager","SESSIONS_STORE","CONFIG_STORE","dbManager","error","console","Promise","resolve","reject","request","indexedDB","event","db","sessionsStore","Error","operation","fallback","promiseExecutor","timeoutMs","timeoutId","setTimeout","value","clearTimeout","reason","transaction","index","store","sessions","a","b","id","session","sessionId","MAX_SESSIONS","s","updates","existingSession","Date","result","undefined","config","newConfig","isRecording","events","isGloballyInitialized","globalInitPromise","initializeDB","create","Z","set","visible","loadSessionsFromStorage","loadCurrentSessionIdFromStorage","saveCurrentSessionIdToStorage","loadRecordingStateFromStorage","saveRecordingStateToStorage","useRecordingSessionStore","get","currentState","currentSessionId","recordLogger","sessionInMemory","updatedSession","state","loadEventsFromStorage","mergeEvents","oldEvents","newEvents","mergedEventsMap","Map","mergedArray","Array","saveEventsToStorage","existingEvents","combinedEvents","clearEventsFromStorage","recording","eventsToSave","T","Text","Typography","m","Number","e","Math","JSON","r","Object","globalThis","Function","window","document","Symbol","self"],"mappings":"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"}